"use strict";(self.webpackChunkpanovista=self.webpackChunkpanovista||[]).push([[6772],{28600:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>p,frontMatter:()=>s,metadata:()=>o,toc:()=>d});var i=t(74848),a=t(28453);const s={},r="datatypes",o={id:"lang/cpp/data_types/data_types",title:"datatypes",description:"All variables use data type during declaration to restrict the type of data to be stored. Therefore, we can say that data types are used to tell the variables the type of data they can store. Whenever a variable is defined in C++, the compiler allocates some memory for that variable based on the data type with which it is declared. Every data type requires a different amount of memory.",source:"@site/docs/lang/cpp/data_types/data_types.mdx",sourceDirName:"lang/cpp/data_types",slug:"/lang/cpp/data_types/",permalink:"/docs/lang/cpp/data_types/",draft:!1,unlisted:!1,editUrl:"https://github.com/wangenius/wangenius.github.io/tree/master/docs/lang/cpp/data_types/data_types.mdx",tags:[],version:"current",frontMatter:{},sidebar:"cpp",previous:{title:"Class",permalink:"/docs/lang/cpp/Class"},next:{title:"user defined types",permalink:"/docs/lang/cpp/data_types/user_defined_types"}},l={},d=[{value:"primary",id:"primary",level:2},{value:"Derived",id:"derived",level:2},{value:"user defined",id:"user-defined",level:2},{value:"Type Modifiers",id:"type-modifiers",level:2},{value:"Type Conversion",id:"type-conversion",level:2},{value:"Implicit Type Conversion",id:"implicit-type-conversion",level:3},{value:"Explicit Type Conversion",id:"explicit-type-conversion",level:3},{value:"Converting by assignment",id:"converting-by-assignment",level:4},{value:"Conversion using Cast operator",id:"conversion-using-cast-operator",level:4}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"datatypes",children:"datatypes"}),"\n",(0,i.jsx)(n.p,{children:"All variables use data type during declaration to restrict the type of data to be stored. Therefore, we can say that data types are used to tell the variables the type of data they can store. Whenever a variable is defined in C++, the compiler allocates some memory for that variable based on the data type with which it is declared. Every data type requires a different amount of memory."}),"\n",(0,i.jsx)(n.p,{children:"C++ supports a wide variety of data types and the programmer can select the data type appropriate to the needs of the application. Data types specify the size and types of values to be stored. However, storage representation and machine instructions to manipulate each data type differ from machine to machine, although C++ instructions are identical on all machines."}),"\n",(0,i.jsx)(n.h2,{id:"primary",children:"primary"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Integer"}),"\n",(0,i.jsx)(n.li,{children:"Character"}),"\n",(0,i.jsx)(n.li,{children:"Boolean"}),"\n",(0,i.jsx)(n.li,{children:"Floating Point"}),"\n",(0,i.jsx)(n.li,{children:"Double Floating Point"}),"\n",(0,i.jsx)(n.li,{children:"Void"}),"\n",(0,i.jsx)(n.li,{children:"Wide Character"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"derived",children:"Derived"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Function"}),"\n",(0,i.jsx)(n.li,{children:"Array"}),"\n",(0,i.jsx)(n.li,{children:"Pointer"}),"\n",(0,i.jsx)(n.li,{children:"Reference"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"user-defined",children:"user defined"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Class"}),"\n",(0,i.jsx)(n.li,{children:"Structure"}),"\n",(0,i.jsx)(n.li,{children:"Union"}),"\n",(0,i.jsx)(n.li,{children:"Enum"}),"\n",(0,i.jsx)(n.li,{children:"Typedef"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"type-modifiers",children:"Type Modifiers"}),"\n",(0,i.jsx)(n.p,{children:"Modifiers are used in C++ to change or give extra meaning to already existing data types. It\u2019s added to primitive data types as a prefix to change their meaning. A modifier is used to change the meaning of a basic type so that it better matches the requirements of different circumstances."}),"\n",(0,i.jsx)(n.p,{children:"Following are the C++ data type modifiers:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"signed"}),"\n",(0,i.jsx)(n.li,{children:"unsigned"}),"\n",(0,i.jsx)(n.li,{children:"short"}),"\n",(0,i.jsx)(n.li,{children:"long"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"type-conversion",children:"Type Conversion"}),"\n",(0,i.jsx)(n.p,{children:"A type cast is basically a conversion from one type to another. There are two types of type conversion:"}),"\n",(0,i.jsx)(n.h3,{id:"implicit-type-conversion",children:"Implicit Type Conversion"}),"\n",(0,i.jsx)(n.p,{children:"automatic type conversion"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Done by the compiler on its own, without any external trigger from the user."}),"\n",(0,i.jsx)(n.li,{children:"Generally takes place when in an expression more than one data type is present. In such condition type conversion (type promotion) takes place to avoid lose of data."}),"\n",(0,i.jsx)(n.li,{children:"All the data types of the variables are upgraded to the data type of the variable with largest data type."}),"\n",(0,i.jsx)(n.li,{children:"It is possible for implicit conversions to lose information, signs can be lost (when signed is implicitly converted to unsigned), and overflow can occur (when long long is implicitly converted to float)."}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"bool -> char -> short int -> int -> \nunsigned int -> long -> unsigned -> \nlong long -> float -> double -> long double\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'#include <iostream> \nusing namespace std; \n  \nint main() \n{ \n    int x = 10; // integer x \n    char y = \'a\'; // character c \n  \n    // y implicitly converted to int. ASCII \n    // value of \'a\' is 97 \n    x = x + y; \n  \n    // x is implicitly converted to float \n    float z = x + 1.0; \n  \n    cout << "x = " << x << endl \n         << "y = " << y << endl \n         << "z = " << z << endl; \n  \n    return 0; \n} \n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",metastring:'title="output"',children:"x = 107\ny = a\nz = 108\n"})}),"\n",(0,i.jsx)(n.h3,{id:"explicit-type-conversion",children:"Explicit Type Conversion"}),"\n",(0,i.jsx)(n.p,{children:"This process is also called type casting and it is user-defined. Here the user can typecast the result to make it of a particular data type. In C++, it can be done by two ways:"}),"\n",(0,i.jsx)(n.h4,{id:"converting-by-assignment",children:"Converting by assignment"}),"\n",(0,i.jsx)(n.p,{children:"This is done by explicitly defining the required type in front of the expression in parenthesis. This can be also considered as forceful casting. Syntax:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'#include <iostream> \nusing namespace std; \n  \nint main() \n{ \n    double x = 1.2; \n  \n    // Explicit conversion from double to int \n    int sum = (int)x + 1; \n  \n    cout << "Sum = " << sum; \n  \n    return 0; \n} \n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",metastring:'title="output"',children:"Sum = 2\n"})}),"\n",(0,i.jsx)(n.h4,{id:"conversion-using-cast-operator",children:"Conversion using Cast operator"}),"\n",(0,i.jsx)(n.p,{children:"A Cast operator is an unary operator which forces one data type to be converted into another data type. C++ supports four types of casting:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Static Cast"}),"\n",(0,i.jsx)(n.li,{children:"Dynamic Cast"}),"\n",(0,i.jsx)(n.li,{children:"Const Cast"}),"\n",(0,i.jsx)(n.li,{children:"Reinterpret Cast"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"#include <iostream> \nusing namespace std; \nint main() \n{ \n    float f = 3.5; \n  \n    // using cast operator \n    int b = static_cast<int>(f); \n  \n    cout << b; \n} \n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",metastring:'title="output"',children:"3\n"})})]})}function p(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>o});var i=t(96540);const a={},s=i.createContext(a);function r(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);