"use strict";(self.webpackChunkwangenius=self.webpackChunkwangenius||[]).push([[5252],{8800:(r,n,e)=>{e.r(n),e.d(n,{assets:()=>a,contentTitle:()=>i,default:()=>o,frontMatter:()=>l,metadata:()=>u,toc:()=>c});var t=e(4848),s=e(8453);const l={title:"Result",sidebar_position:4,slug:"Result"},i="Result",u={id:"lang/rust/\u9519\u8bef\u5904\u7406/Result",title:"Result",description:"Result \u662f Option \u7c7b\u578b\u7684\u66f4\u4e30\u5bcc\u7248\u672c\uff0c\u5b83\u63cf\u8ff0\u53ef\u80fd\u7684\u9519\u8bef\u800c\u4e0d\u662f\u53ef\u80fd\u7684\u7f3a\u5931\u3002",source:"@site/docs/lang/rust/\u9519\u8bef\u5904\u7406/Result.mdx",sourceDirName:"lang/rust/\u9519\u8bef\u5904\u7406",slug:"/lang/rust/\u9519\u8bef\u5904\u7406/Result",permalink:"/mainpage/docs/lang/rust/\u9519\u8bef\u5904\u7406/Result",draft:!1,unlisted:!1,editUrl:"https://github.com/wangenius/mainpage/tree/master/docs/lang/rust/\u9519\u8bef\u5904\u7406/Result.mdx",tags:[],version:"current",sidebarPosition:4,frontMatter:{title:"Result",sidebar_position:4,slug:"Result"},sidebar:"rust",previous:{title:"option&unwrap",permalink:"/mainpage/docs/lang/rust/\u9519\u8bef\u5904\u7406/option&unwrap"},next:{title:"\u591a\u79cd\u9519\u8bef\u7c7b\u578b",permalink:"/mainpage/docs/lang/rust/\u9519\u8bef\u5904\u7406/\u591a\u79cd\u9519\u8bef\u7c7b\u578b"}},a={},c=[{value:"\u5728 main \u4e2d\u4f7f\u7528 Result",id:"\u5728-main-\u4e2d\u4f7f\u7528-result",level:2},{value:"map for Result",id:"map-for-result",level:2},{value:"Result \u7684\u522b\u540d",id:"result-\u7684\u522b\u540d",level:2},{value:"\u63d0\u524d\u8fd4\u56de",id:"\u63d0\u524d\u8fd4\u56de",level:2},{value:"\u5f15\u5165 ?",id:"\u5f15\u5165-",level:2},{value:"try! \u5b8f",id:"try-\u5b8f",level:3},{value:"Result \u8fed\u4ee3",id:"result-\u8fed\u4ee3",level:2},{value:"\u4f7f\u7528 filter_map() \u5ffd\u7565\u5931\u8d25\u7684\u9879\u76ee",id:"\u4f7f\u7528-filter_map-\u5ffd\u7565\u5931\u8d25\u7684\u9879\u76ee",level:3},{value:"\u6536\u96c6 map_err() \u548c filter_map() \u5931\u8d25\u7684\u9879\u76ee",id:"\u6536\u96c6-map_err-\u548c-filter_map-\u5931\u8d25\u7684\u9879\u76ee",level:3},{value:"\u4f7f\u7528 collect() \u4f7f\u6574\u4e2a\u64cd\u4f5c\u5931\u8d25",id:"\u4f7f\u7528-collect-\u4f7f\u6574\u4e2a\u64cd\u4f5c\u5931\u8d25",level:2},{value:"\u4f7f\u7528 partition() \u6536\u96c6\u6240\u6709\u6709\u6548\u503c\u548c\u5931\u8d25\u503c",id:"\u4f7f\u7528-partition-\u6536\u96c6\u6240\u6709\u6709\u6548\u503c\u548c\u5931\u8d25\u503c",level:2}];function p(r){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...r.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"result",children:"Result"}),"\n",(0,t.jsx)(n.p,{children:"Result \u662f Option \u7c7b\u578b\u7684\u66f4\u4e30\u5bcc\u7248\u672c\uff0c\u5b83\u63cf\u8ff0\u53ef\u80fd\u7684\u9519\u8bef\u800c\u4e0d\u662f\u53ef\u80fd\u7684\u7f3a\u5931\u3002"}),"\n",(0,t.jsxs)(n.p,{children:["\u4e5f\u5c31\u662f\u8bf4\uff0c",(0,t.jsx)(n.code,{children:"Result<T, E>"})," \u53ef\u80fd\u6709\u4ee5\u4e0b\u4e24\u79cd\u7ed3\u679c\u4e4b\u4e00\uff1a"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Ok(T) \uff1a\u627e\u5230\u5143\u7d20 T"}),"\n",(0,t.jsx)(n.li,{children:"Err(E) \uff1a\u5143\u7d20 E \u53d1\u73b0\u9519\u8bef"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"\u6309\u7167\u60ef\u4f8b\uff0c\u9884\u671f\u7ed3\u679c\u662f Ok \u800c\u610f\u5916\u7ed3\u679c\u662f Err \u3002"}),"\n",(0,t.jsx)(n.p,{children:"\u4e0e Option \u4e00\u6837\uff0c Result \u6709\u8bb8\u591a\u4e0e\u4e4b\u5173\u8054\u7684\u65b9\u6cd5\u3002\u4f8b\u5982\uff0c unwrap() \u751f\u6210\u5143\u7d20 T \u6216 panic \u3002\u5bf9\u4e8e\u6848\u4f8b\u5904\u7406\uff0c Result \u548c Option \u4e4b\u95f4\u6709\u8bb8\u591a\u91cd\u53e0\u7684\u7ec4\u5408\u5668\u3002"}),"\n",(0,t.jsx)(n.p,{children:"\u5728\u4f7f\u7528 Rust \u65f6\uff0c\u60a8\u53ef\u80fd\u4f1a\u9047\u5230\u8fd4\u56de Result \u7c7b\u578b\u7684\u65b9\u6cd5\uff0c\u4f8b\u5982 parse() \u65b9\u6cd5\u3002\u53ef\u80fd\u5e76\u4e0d\u603b\u662f\u80fd\u591f\u5c06\u5b57\u7b26\u4e32\u89e3\u6790\u4e3a\u5176\u4ed6\u7c7b\u578b\uff0c\u56e0\u6b64 parse() \u8fd4\u56de Result \u6307\u793a\u53ef\u80fd\u5931\u8d25\u3002"}),"\n",(0,t.jsx)(n.p,{children:"\u8ba9\u6211\u4eec\u770b\u770b\u5f53\u6211\u4eec\u6210\u529f\u548c\u5931\u8d25 parse() \u4e00\u4e2a\u5b57\u7b26\u4e32\u65f6\u4f1a\u53d1\u751f\u4ec0\u4e48\uff1a"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'fn multiply(first_number_str: &str, second_number_str: &str) -> i32 {\r\n    // Let\'s try using `unwrap()` to get the number out. Will it bite us?\r\n    let first_number = first_number_str.parse::<i32>().unwrap();\r\n    let second_number = second_number_str.parse::<i32>().unwrap();\r\n    first_number * second_number\r\n}\r\n\r\nfn main() {\r\n    let twenty = multiply("10", "2");\r\n    println!("double is {}", twenty);\r\n\r\n    let tt = multiply("t", "2");\r\n    println!("double is {}", tt);\r\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"\u5728\u4e0d\u6210\u529f\u7684\u60c5\u51b5\u4e0b\uff0c parse() \u4f1a\u7ed9\u6211\u4eec\u5e26\u6765 unwrap() \u5230 panic \u7684\u9519\u8bef\u3002\u6b64\u5916\uff0c panic \u9000\u51fa\u6211\u4eec\u7684\u7a0b\u5e8f\u5e76\u63d0\u4f9b\u4ee4\u4eba\u4e0d\u5feb\u7684\u9519\u8bef\u6d88\u606f\u3002"}),"\n",(0,t.jsx)(n.p,{children:"\u4e3a\u4e86\u63d0\u9ad8\u9519\u8bef\u6d88\u606f\u7684\u8d28\u91cf\uff0c\u6211\u4eec\u5e94\u8be5\u66f4\u5177\u4f53\u5730\u4e86\u89e3\u8fd4\u56de\u7c7b\u578b\u5e76\u8003\u8651\u663e\u5f0f\u5904\u7406\u9519\u8bef\u3002"}),"\n",(0,t.jsx)(n.h2,{id:"\u5728-main-\u4e2d\u4f7f\u7528-result",children:"\u5728 main \u4e2d\u4f7f\u7528 Result"}),"\n",(0,t.jsx)(n.p,{children:"\u5982\u679c\u660e\u786e\u6307\u5b9a\uff0c Result \u7c7b\u578b\u4e5f\u53ef\u4ee5\u662f main \u51fd\u6570\u7684\u8fd4\u56de\u7c7b\u578b\u3002\u901a\u5e38\uff0c main \u51fd\u6570\u7684\u5f62\u5f0f\u5982\u4e0b\uff1a"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'fn main() {\r\n    println!("Hello World!");\r\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"\u4f46\u662f main \u4e5f\u53ef\u4ee5\u6709 Result \u8fd4\u56de\u7c7b\u578b\u3002\u5982\u679c main \u51fd\u6570\u4e2d\u53d1\u751f\u9519\u8bef\uff0c\u5b83\u5c06\u8fd4\u56de\u9519\u8bef\u4ee3\u7801\u5e76\u6253\u5370\u9519\u8bef\u7684\u8c03\u8bd5\u8868\u793a\uff08\u4f7f\u7528 Debug \u7279\u5f81\uff09\u3002\u4ee5\u4e0b\u793a\u4f8b\u663e\u793a\u4e86\u6b64\u7c7b\u573a\u666f\uff0c\u5e76\u6d89\u53ca\u4e0b\u4e00\u8282\u4e2d\u6db5\u76d6\u7684\u5404\u4e2a\u65b9\u9762\u3002"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'use std::num::ParseIntError;\r\n\r\nfn main() -> Result<(), ParseIntError> {\r\n    let number_str = "10";\r\n    let number = match number_str.parse::<i32>() {\r\n        Ok(number)  => number,\r\n        Err(e) => return Err(e),\r\n    };\r\n    println!("{}", number);\r\n    Ok(())\r\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"map-for-result",children:"map for Result"}),"\n",(0,t.jsx)(n.p,{children:"\u4e0a\u4e00\u4e2a\u793a\u4f8b\u7684 multiply \u4e2d\u7684\u6050\u614c\u5e76\u4e0d\u5229\u4e8e\u4ee3\u7801\u7684\u5065\u58ee\u3002\u901a\u5e38\uff0c\u6211\u4eec\u5e0c\u671b\u5c06\u9519\u8bef\u8fd4\u56de\u7ed9\u8c03\u7528\u8005\uff0c\u4ee5\u4fbf\u8c03\u7528\u8005\u53ef\u4ee5\u51b3\u5b9a\u54cd\u5e94\u9519\u8bef\u7684\u6b63\u786e\u65b9\u6cd5\u3002"}),"\n",(0,t.jsx)(n.p,{children:"\u6211\u4eec\u9996\u5148\u9700\u8981\u77e5\u9053\u6211\u4eec\u6b63\u5728\u5904\u7406\u4ec0\u4e48\u7c7b\u578b\u7684\u9519\u8bef\u7c7b\u578b\u3002\u4e3a\u4e86\u786e\u5b9a Err \u7c7b\u578b\uff0c\u6211\u4eec\u67e5\u770b parse() \uff0c\u5b83\u662f\u901a\u8fc7 i32 \u7684 FromStr \u7279\u5f81\u5b9e\u73b0\u7684\u3002\u56e0\u6b64\uff0c Err \u7c7b\u578b\u88ab\u6307\u5b9a\u4e3a ParseIntError \u3002"}),"\n",(0,t.jsx)(n.p,{children:"\u5728\u4e0b\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u7b80\u5355\u7684 match \u8bed\u53e5\u5bfc\u81f4\u4ee3\u7801\u603b\u4f53\u4e0a\u66f4\u52a0\u9ebb\u70e6\u3002"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'use std::num::ParseIntError;\r\n\r\n// With the return type rewritten, we use pattern matching without `unwrap()`.\r\nfn multiply(first_number_str: &str, second_number_str: &str) -> Result<i32, ParseIntError> {\r\n    match first_number_str.parse::<i32>() {\r\n        Ok(first_number)  => {\r\n            match second_number_str.parse::<i32>() {\r\n                Ok(second_number)  => {\r\n                    Ok(first_number * second_number)\r\n                },\r\n                Err(e) => Err(e),\r\n            }\r\n        },\r\n        Err(e) => Err(e),\r\n    }\r\n}\r\n\r\nfn print(result: Result<i32, ParseIntError>) {\r\n    match result {\r\n        Ok(n)  => println!("n is {}", n),\r\n        Err(e) => println!("Error: {}", e),\r\n    }\r\n}\r\n\r\nfn main() {\r\n    // This still presents a reasonable answer.\r\n    let twenty = multiply("10", "2");\r\n    print(twenty);\r\n\r\n    // The following now provides a much more helpful error message.\r\n    let tt = multiply("t", "2");\r\n    print(tt);\r\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"\u5e78\u8fd0\u7684\u662f\uff0c Option \u7684 map \u3001 and_then \u548c\u8bb8\u591a\u5176\u4ed6\u7ec4\u5408\u5668\u4e5f\u4e3a Result \u5b9e\u73b0\u3002 Result \u5305\u542b\u5b8c\u6574\u7684\u5217\u8868\u3002"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'use std::num::ParseIntError;\r\n\r\n// As with `Option`, we can use combinators such as `map()`.\r\n// This function is otherwise identical to the one above and reads:\r\n// Multiply if both values can be parsed from str, otherwise pass on the error.\r\nfn multiply(first_number_str: &str, second_number_str: &str) -> Result<i32, ParseIntError> {\r\n    first_number_str.parse::<i32>().and_then(|first_number| {\r\n        second_number_str.parse::<i32>().map(|second_number| first_number * second_number)\r\n    })\r\n}\r\n\r\nfn print(result: Result<i32, ParseIntError>) {\r\n    match result {\r\n        Ok(n)  => println!("n is {}", n),\r\n        Err(e) => println!("Error: {}", e),\r\n    }\r\n}\r\n\r\nfn main() {\r\n    // This still presents a reasonable answer.\r\n    let twenty = multiply("10", "2");\r\n    print(twenty);\r\n\r\n    // The following now provides a much more helpful error message.\r\n    let tt = multiply("t", "2");\r\n    print(tt);\r\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"result-\u7684\u522b\u540d",children:"Result \u7684\u522b\u540d"}),"\n",(0,t.jsx)(n.p,{children:"\u5f53\u6211\u4eec\u60f3\u8981\u591a\u6b21\u91cd\u590d\u4f7f\u7528\u7279\u5b9a\u7684 Result \u7c7b\u578b\u65f6\u8be5\u600e\u4e48\u529e\uff1f\u56de\u60f3\u4e00\u4e0b\uff0cRust \u5141\u8bb8\u6211\u4eec\u521b\u5efa\u522b\u540d\u3002\u65b9\u4fbf\u7684\u662f\uff0c\u6211\u4eec\u53ef\u4ee5\u4e3a\u6240\u8ba8\u8bba\u7684\u7279\u5b9a Result \u5b9a\u4e49\u4e00\u4e2a\u3002"}),"\n",(0,t.jsx)(n.p,{children:"\u5728\u6a21\u5757\u7ea7\u522b\uff0c\u521b\u5efa\u522b\u540d\u7279\u522b\u6709\u7528\u3002\u5728\u7279\u5b9a\u6a21\u5757\u4e2d\u53d1\u73b0\u7684\u9519\u8bef\u901a\u5e38\u5177\u6709\u76f8\u540c\u7684 Err \u7c7b\u578b\uff0c\u56e0\u6b64\u5355\u4e2a\u522b\u540d\u53ef\u4ee5\u7b80\u6d01\u5730\u5b9a\u4e49\u6240\u6709\u5173\u8054\u7684 Results \u3002\u8fd9\u975e\u5e38\u6709\u7528\uff0c std \u5e93\u751a\u81f3\u63d0\u4f9b\u4e86\u4e00\u4e2a\uff1a io::Result \uff01"}),"\n",(0,t.jsx)(n.p,{children:"\u8fd9\u662f\u4e00\u4e2a\u5c55\u793a\u8bed\u6cd5\u7684\u7b80\u5355\u793a\u4f8b\uff1a"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'use std::num::ParseIntError;\r\n\r\n// Define a generic alias for a `Result` with the error type `ParseIntError`.\r\ntype AliasedResult<T> = Result<T, ParseIntError>;\r\n\r\n// Use the above alias to refer to our specific `Result` type.\r\nfn multiply(first_number_str: &str, second_number_str: &str) -> AliasedResult<i32> {\r\n    first_number_str.parse::<i32>().and_then(|first_number| {\r\n        second_number_str.parse::<i32>().map(|second_number| first_number * second_number)\r\n    })\r\n}\r\n\r\n// Here, the alias again allows us to save some space.\r\nfn print(result: AliasedResult<i32>) {\r\n    match result {\r\n        Ok(n)  => println!("n is {}", n),\r\n        Err(e) => println!("Error: {}", e),\r\n    }\r\n}\r\n\r\nfn main() {\r\n    print(multiply("10", "2"));\r\n    print(multiply("t", "2"));\r\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"\u63d0\u524d\u8fd4\u56de",children:"\u63d0\u524d\u8fd4\u56de"}),"\n",(0,t.jsx)(n.p,{children:"\u5728\u524d\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u6211\u4eec\u4f7f\u7528\u7ec4\u5408\u5668\u663e\u5f0f\u5904\u7406\u9519\u8bef\u3002\u5904\u7406\u6b64\u6848\u4f8b\u5206\u6790\u7684\u53e6\u4e00\u79cd\u65b9\u6cd5\u662f\u4f7f\u7528 match \u8bed\u53e5\u548c\u65e9\u671f\u8fd4\u56de\u7684\u7ec4\u5408\u3002"}),"\n",(0,t.jsx)(n.p,{children:"\u4e5f\u5c31\u662f\u8bf4\uff0c\u6211\u4eec\u53ef\u4ee5\u7b80\u5355\u5730\u505c\u6b62\u6267\u884c\u8be5\u51fd\u6570\u5e76\u5728\u53d1\u751f\u9519\u8bef\u65f6\u8fd4\u56de\u9519\u8bef\u3002\u5bf9\u4e8e\u67d0\u4e9b\u4eba\u6765\u8bf4\uff0c\u8fd9\u79cd\u5f62\u5f0f\u7684\u4ee3\u7801\u66f4\u6613\u4e8e\u9605\u8bfb\u548c\u7f16\u5199\u3002\u8003\u8651\u4e0a\u4e00\u4e2a\u793a\u4f8b\u7684\u8fd9\u4e2a\u7248\u672c\uff0c\u4f7f\u7528\u65e9\u671f\u8fd4\u56de\u91cd\u5199\uff1a"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'use std::num::ParseIntError;\r\n\r\nfn multiply(first_number_str: &str, second_number_str: &str) -> Result<i32, ParseIntError> {\r\n    let first_number = match first_number_str.parse::<i32>() {\r\n        Ok(first_number)  => first_number,\r\n        Err(e) => return Err(e),\r\n    };\r\n\r\n    let second_number = match second_number_str.parse::<i32>() {\r\n        Ok(second_number)  => second_number,\r\n        Err(e) => return Err(e),\r\n    };\r\n\r\n    Ok(first_number * second_number)\r\n}\r\n\r\nfn print(result: Result<i32, ParseIntError>) {\r\n    match result {\r\n        Ok(n)  => println!("n is {}", n),\r\n        Err(e) => println!("Error: {}", e),\r\n    }\r\n}\r\n\r\nfn main() {\r\n    print(multiply("10", "2"));\r\n    print(multiply("t", "2"));\r\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"\u81f3\u6b64\uff0c\u6211\u4eec\u5df2\u7ecf\u5b66\u4f1a\u4e86\u4f7f\u7528\u7ec4\u5408\u5668\u548c\u65e9\u671f\u8fd4\u56de\u6765\u663e\u5f0f\u5904\u7406\u9519\u8bef\u3002\u867d\u7136\u6211\u4eec\u901a\u5e38\u5e0c\u671b\u907f\u514d\u6050\u614c\uff0c\u4f46\u663e\u5f0f\u5904\u7406\u6240\u6709\u9519\u8bef\u662f\u5f88\u9ebb\u70e6\u7684\u3002"}),"\n",(0,t.jsx)(n.p,{children:"\u5728\u4e0b\u4e00\u8282\u4e2d\uff0c\u6211\u4eec\u5c06\u5728\u53ea\u9700\u8981 unwrap \u800c\u4e0d\u4f1a\u5f15\u5165 panic \u7684\u60c5\u51b5\u4e0b\u5f15\u5165 ? \u3002"}),"\n",(0,t.jsx)(n.h2,{id:"\u5f15\u5165-",children:"\u5f15\u5165 ?"}),"\n",(0,t.jsx)(n.p,{children:"\u6709\u65f6\u6211\u4eec\u53ea\u60f3\u8981 unwrap \u7684\u7b80\u5355\u6027\uff0c\u800c\u4e0d\u9700\u8981 panic \u3002\u5230\u76ee\u524d\u4e3a\u6b62\uff0c unwrap \u8feb\u4f7f\u6211\u4eec\u5d4c\u5957\u5f97\u8d8a\u6765\u8d8a\u6df1\uff0c\u800c\u6211\u4eec\u771f\u6b63\u60f3\u8981\u7684\u662f\u53d6\u51fa\u53d8\u91cf\u3002\u8fd9\u6b63\u662f ? \u7684\u76ee\u7684\u3002"}),"\n",(0,t.jsx)(n.p,{children:"\u627e\u5230 Err \u540e\uff0c\u9700\u8981\u91c7\u53d6\u4e24\u4e2a\u6709\u6548\u64cd\u4f5c\uff1a"}),"\n",(0,t.jsx)(n.p,{children:"panic! \u6211\u4eec\u5df2\u7ecf\u51b3\u5b9a\u5c3d\u53ef\u80fd\u907f\u514d\r\nreturn \u56e0\u4e3a Err \u610f\u5473\u7740\u5b83\u65e0\u6cd5\u88ab\u5904\u7406\r\n? \u51e0\u4e4e\u4e0e 1 \u5b8c\u5168\u7b49\u540c\u4e8e unwrap \uff0c\u5176\u4e2d return \u800c\u4e0d\u662f Err \u56fd\u738b s\u3002\u8ba9\u6211\u4eec\u770b\u770b\u5982\u4f55\u7b80\u5316\u524d\u9762\u4f7f\u7528\u7ec4\u5408\u5668\u7684\u793a\u4f8b\uff1a"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'use std::num::ParseIntError;\r\n\r\nfn multiply(first_number_str: &str, second_number_str: &str) -> Result<i32, ParseIntError> {\r\n    let first_number = first_number_str.parse::<i32>()?;\r\n    let second_number = second_number_str.parse::<i32>()?;\r\n\r\n    Ok(first_number * second_number)\r\n}\r\n\r\nfn print(result: Result<i32, ParseIntError>) {\r\n    match result {\r\n        Ok(n)  => println!("n is {}", n),\r\n        Err(e) => println!("Error: {}", e),\r\n    }\r\n}\r\n\r\nfn main() {\r\n    print(multiply("10", "2"));\r\n    print(multiply("t", "2"));\r\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"try-\u5b8f",children:"try! \u5b8f"}),"\n",(0,t.jsx)(n.p,{children:"\u5728\u51fa\u73b0 ? \u4e4b\u524d\uff0c\u4f7f\u7528 try! \u5b8f\u5b9e\u73b0\u4e86\u76f8\u540c\u7684\u529f\u80fd\u3002\u73b0\u5728\u5efa\u8bae\u4f7f\u7528 ? \u8fd0\u7b97\u7b26\uff0c\u4f46\u5728\u67e5\u770b\u65e7\u4ee3\u7801\u65f6\u60a8\u53ef\u80fd\u4ecd\u7136\u4f1a\u627e\u5230 try! \u3002\u4f7f\u7528 try! \u4e0e\u4e0a\u4e00\u4e2a\u793a\u4f8b\u4e2d\u7684\u76f8\u540c multiply \u51fd\u6570\u5c06\u5982\u4e0b\u6240\u793a\uff1a"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'// To compile and run this example without errors, while using Cargo, change the value \r\n// of the `edition` field, in the `[package]` section of the `Cargo.toml` file, to "2015".\r\n\r\nuse std::num::ParseIntError;\r\n\r\nfn multiply(first_number_str: &str, second_number_str: &str) -> Result<i32, ParseIntError> {\r\n    let first_number = try!(first_number_str.parse::<i32>());\r\n    let second_number = try!(second_number_str.parse::<i32>());\r\n\r\n    Ok(first_number * second_number)\r\n}\r\n\r\nfn print(result: Result<i32, ParseIntError>) {\r\n    match result {\r\n        Ok(n)  => println!("n is {}", n),\r\n        Err(e) => println!("Error: {}", e),\r\n    }\r\n}\r\n\r\nfn main() {\r\n    print(multiply("10", "2"));\r\n    print(multiply("t", "2"));\r\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"result-\u8fed\u4ee3",children:"Result \u8fed\u4ee3"}),"\n",(0,t.jsx)(n.p,{children:"\u8fed\u4ee3 Result \u79d2\r\nIter::map \u64cd\u4f5c\u53ef\u80fd\u4f1a\u5931\u8d25\uff0c\u4f8b\u5982\uff1a"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'fn main() {\r\n    let strings = vec!["tofu", "93", "18"];\r\n    let numbers: Vec<_> = strings\r\n        .into_iter()\r\n        .map(|s| s.parse::<i32>())\r\n        .collect();\r\n    println!("Results: {:?}", numbers);\r\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"\u8ba9\u6211\u4eec\u9010\u6b65\u4e86\u89e3\u5904\u7406\u6b64\u95ee\u9898\u7684\u7b56\u7565\u3002"}),"\n",(0,t.jsx)(n.h3,{id:"\u4f7f\u7528-filter_map-\u5ffd\u7565\u5931\u8d25\u7684\u9879\u76ee",children:"\u4f7f\u7528 filter_map() \u5ffd\u7565\u5931\u8d25\u7684\u9879\u76ee"}),"\n",(0,t.jsx)(n.p,{children:"filter_map \u8c03\u7528\u51fd\u6570\u5e76\u8fc7\u6ee4\u6389 None \u7684\u7ed3\u679c\u3002"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'fn main() {\r\n    let strings = vec!["tofu", "93", "18"];\r\n    let numbers: Vec<_> = strings\r\n        .into_iter()\r\n        .filter_map(|s| s.parse::<i32>().ok())\r\n        .collect();\r\n    println!("Results: {:?}", numbers);\r\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"\u6536\u96c6-map_err-\u548c-filter_map-\u5931\u8d25\u7684\u9879\u76ee",children:"\u6536\u96c6 map_err() \u548c filter_map() \u5931\u8d25\u7684\u9879\u76ee"}),"\n",(0,t.jsx)(n.p,{children:"map_err \u8c03\u7528\u4e00\u4e2a\u5e26\u6709\u9519\u8bef\u7684\u51fd\u6570\uff0c\u56e0\u6b64\u901a\u8fc7\u5c06\u5176\u6dfb\u52a0\u5230\u4e4b\u524d\u7684 filter_map \u89e3\u51b3\u65b9\u6848\u4e2d\uff0c\u6211\u4eec\u53ef\u4ee5\u5728\u8fed\u4ee3\u65f6\u5c06\u5b83\u4eec\u4fdd\u5b58\u5230\u4e00\u8fb9\u3002"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'fn main() {\r\n    let strings = vec!["42", "tofu", "93", "999", "18"];\r\n    let mut errors = vec![];\r\n    let numbers: Vec<_> = strings\r\n        .into_iter()\r\n        .map(|s| s.parse::<u8>())\r\n        .filter_map(|r| r.map_err(|e| errors.push(e)).ok())\r\n        .collect();\r\n    println!("Numbers: {:?}", numbers);\r\n    println!("Errors: {:?}", errors);\r\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"\u4f7f\u7528-collect-\u4f7f\u6574\u4e2a\u64cd\u4f5c\u5931\u8d25",children:"\u4f7f\u7528 collect() \u4f7f\u6574\u4e2a\u64cd\u4f5c\u5931\u8d25"}),"\n",(0,t.jsxs)(n.p,{children:["Result \u5b9e\u73b0 FromIterator \uff0c\u4ee5\u4fbf\u7ed3\u679c\u5411\u91cf ( ",(0,t.jsx)(n.code,{children:"Vec<Result<T, E>>"})," ) \u53ef\u4ee5\u8f6c\u6362\u4e3a\u5e26\u6709\u5411\u91cf\u7684\u7ed3\u679c ( ",(0,t.jsx)(n.code,{children:"Result<Vec<T>, E>"})," )\u3002\u4e00\u65e6\u627e\u5230 Result::Err \uff0c\u8fed\u4ee3\u5c31\u4f1a\u7ec8\u6b62\u3002"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'fn main() {\r\n    let strings = vec!["tofu", "93", "18"];\r\n    let numbers: Result<Vec<_>, _> = strings\r\n        .into_iter()\r\n        .map(|s| s.parse::<i32>())\r\n        .collect();\r\n    println!("Results: {:?}", numbers);\r\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"\u540c\u6837\u7684\u6280\u672f\u4e5f\u53ef\u4ee5\u7528\u4e8e Option \u3002"}),"\n",(0,t.jsx)(n.h2,{id:"\u4f7f\u7528-partition-\u6536\u96c6\u6240\u6709\u6709\u6548\u503c\u548c\u5931\u8d25\u503c",children:"\u4f7f\u7528 partition() \u6536\u96c6\u6240\u6709\u6709\u6548\u503c\u548c\u5931\u8d25\u503c"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'fn main() {\r\n    let strings = vec!["tofu", "93", "18"];\r\n    let (numbers, errors): (Vec<_>, Vec<_>) = strings\r\n        .into_iter()\r\n        .map(|s| s.parse::<i32>())\r\n        .partition(Result::is_ok);\r\n    println!("Numbers: {:?}", numbers);\r\n    println!("Errors: {:?}", errors);\r\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"\u5f53\u60a8\u67e5\u770b\u7ed3\u679c\u65f6\uff0c\u60a8\u4f1a\u6ce8\u610f\u5230\u6240\u6709\u5185\u5bb9\u4ecd\u7136\u5305\u542b\u5728 Result \u4e2d\u3002\u4e3a\u6b64\u8fd8\u9700\u8981\u66f4\u591a\u7684\u6837\u677f\u6587\u4ef6\u3002"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'fn main() {\r\n    let strings = vec!["tofu", "93", "18"];\r\n    let (numbers, errors): (Vec<_>, Vec<_>) = strings\r\n        .into_iter()\r\n        .map(|s| s.parse::<i32>())\r\n        .partition(Result::is_ok);\r\n    let numbers: Vec<_> = numbers.into_iter().map(Result::unwrap).collect();\r\n    let errors: Vec<_> = errors.into_iter().map(Result::unwrap_err).collect();\r\n    println!("Numbers: {:?}", numbers);\r\n    println!("Errors: {:?}", errors);\r\n}\n'})})]})}function o(r={}){const{wrapper:n}={...(0,s.R)(),...r.components};return n?(0,t.jsx)(n,{...r,children:(0,t.jsx)(p,{...r})}):p(r)}},8453:(r,n,e)=>{e.d(n,{R:()=>i,x:()=>u});var t=e(6540);const s={},l=t.createContext(s);function i(r){const n=t.useContext(l);return t.useMemo((function(){return"function"==typeof r?r(n):{...n,...r}}),[n,r])}function u(r){let n;return n=r.disableParentContext?"function"==typeof r.components?r.components(s):r.components||s:i(r.components),t.createElement(l.Provider,{value:n},r.children)}}}]);