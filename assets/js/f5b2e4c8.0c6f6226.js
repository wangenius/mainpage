"use strict";(self.webpackChunkpanovista=self.webpackChunkpanovista||[]).push([[6974],{4007:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>l});var o=t(4848),s=t(8453);const a={title:"\u7ed3\u6784\u578b\u6a21\u5f0f",sidebar_position:5,slug:"\u7ed3\u6784\u578b\u6a21\u5f0f"},i="\u7ed3\u6784\u578b\u6a21\u5f0f",r={id:"lang/cpp/\u9762\u5411\u5bf9\u8c61/\u7ed3\u6784\u578b\u6a21\u5f0f",title:"\u7ed3\u6784\u578b\u6a21\u5f0f",description:"\u9002\u914d\u5668\u6a21\u5f0f",source:"@site/docs/lang/cpp/\u9762\u5411\u5bf9\u8c61/\u7ed3\u6784\u578b\u6a21\u5f0f.mdx",sourceDirName:"lang/cpp/\u9762\u5411\u5bf9\u8c61",slug:"/lang/cpp/\u9762\u5411\u5bf9\u8c61/\u7ed3\u6784\u578b\u6a21\u5f0f",permalink:"/docs/lang/cpp/\u9762\u5411\u5bf9\u8c61/\u7ed3\u6784\u578b\u6a21\u5f0f",draft:!1,unlisted:!1,editUrl:"https://github.com/wangenius/wangenius.github.io/tree/master/docs/lang/cpp/\u9762\u5411\u5bf9\u8c61/\u7ed3\u6784\u578b\u6a21\u5f0f.mdx",tags:[],version:"current",sidebarPosition:5,frontMatter:{title:"\u7ed3\u6784\u578b\u6a21\u5f0f",sidebar_position:5,slug:"\u7ed3\u6784\u578b\u6a21\u5f0f"},sidebar:"cpp",previous:{title:"\u521b\u5efa\u578b\u6a21\u5f0f",permalink:"/docs/lang/cpp/\u9762\u5411\u5bf9\u8c61/\u521b\u5efa\u578b\u6a21\u5f0f"},next:{title:"\u884c\u4e3a\u578b\u6a21\u5f0f",permalink:"/docs/lang/cpp/\u9762\u5411\u5bf9\u8c61/\u884c\u4e3a\u578b\u6a21\u5f0f"}},c={},l=[{value:"\u9002\u914d\u5668\u6a21\u5f0f",id:"\u9002\u914d\u5668\u6a21\u5f0f",level:2},{value:"\u6865\u63a5\u6a21\u5f0f",id:"\u6865\u63a5\u6a21\u5f0f",level:2},{value:"\u88c5\u9970\u6a21\u5f0f",id:"\u88c5\u9970\u6a21\u5f0f",level:2},{value:"\u7ec4\u5408\u6a21\u5f0f",id:"\u7ec4\u5408\u6a21\u5f0f",level:2},{value:"\u5916\u89c2\u6a21\u5f0f",id:"\u5916\u89c2\u6a21\u5f0f",level:2},{value:"\u4eab\u5143\u6a21\u5f0f",id:"\u4eab\u5143\u6a21\u5f0f",level:2},{value:"\u4ee3\u7406\u6a21\u5f0f",id:"\u4ee3\u7406\u6a21\u5f0f",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h1,{id:"\u7ed3\u6784\u578b\u6a21\u5f0f",children:"\u7ed3\u6784\u578b\u6a21\u5f0f"}),"\n",(0,o.jsx)(n.h2,{id:"\u9002\u914d\u5668\u6a21\u5f0f",children:"\u9002\u914d\u5668\u6a21\u5f0f"}),"\n",(0,o.jsx)(n.p,{children:"Adapter \u5c06\u4e00\u4e2a\u7c7b\u7684\u63a5\u53e3\u8f6c\u6362\u6210\u5ba2\u6237\u5e0c\u671b\u7684\u53e6\u5916\u4e00\u4e2a\u63a5\u53e3\uff0c\u4f7f\u5f97\u539f\u672c\u7531\u4e8e\u63a5\u53e3\u4e0d\u517c\u5bb9\u800c\u4e0d\u80fd\u4e00\u8d77\u5de5\u4f5c\u7684\u90a3\u4e9b\u7c7b\u80fd\u4e00\u8d77\u5de5\u4f5c\u3002"}),"\n",(0,o.jsx)(n.p,{children:"\u4f18\u70b9\n\u5ba2\u6237\u7aef\u901a\u8fc7\u9002\u914d\u5668\u53ef\u4ee5\u900f\u660e\u5730\u8c03\u7528\u76ee\u6807\u63a5\u53e3\u3002\n\u590d\u7528\u4e86\u73b0\u5b58\u7684\u7c7b\uff0c\u7a0b\u5e8f\u5458\u4e0d\u9700\u8981\u4fee\u6539\u539f\u6709\u4ee3\u7801\u800c\u91cd\u7528\u73b0\u6709\u7684\u9002\u914d\u8005\u7c7b\u3002\n\u5c06\u76ee\u6807\u7c7b\u548c\u9002\u914d\u8005\u7c7b\u89e3\u8026\uff0c\u89e3\u51b3\u4e86\u76ee\u6807\u7c7b\u548c\u9002\u914d\u8005\u7c7b\u63a5\u53e3\u4e0d\u4e00\u81f4\u7684\u95ee\u9898\u3002\n\u7f3a\u70b9\n\u5bf9\u7c7b\u9002\u914d\u5668\u6765\u8bf4\uff0c\u66f4\u6362\u9002\u914d\u5668\u7684\u5b9e\u73b0\u8fc7\u7a0b\u6bd4\u8f83\u590d\u6742\u3002\n\u5e94\u7528\u573a\u666f"}),"\n",(0,o.jsx)(n.p,{children:"\u5728\u73b0\u5b9e\u751f\u6d3b\u4e2d\uff0c\u7ecf\u5e38\u51fa\u73b0\u4e24\u4e2a\u5bf9\u8c61\u56e0\u63a5\u53e3\u4e0d\u517c\u5bb9\u800c\u4e0d\u80fd\u5728\u4e00\u8d77\u5de5\u4f5c\u7684\u5b9e\u4f8b\uff0c\u8fd9\u65f6\u9700\u8981\u7b2c\u4e09\u8005\u8fdb\u884c\u9002\u914d\u3002\u4f8b\u5982\uff0c\u8bb2\u4e2d\u6587\u7684\u4eba\u540c\u8bb2\u82f1\u6587\u7684\u4eba\u5bf9\u8bdd\u65f6\u9700\u8981\u4e00\u4e2a\u7ffb\u8bd1\uff0c\u7528\u76f4\u6d41\u7535\u7684\u7b14\u8bb0\u672c\u7535\u8111\u63a5\u4ea4\u6d41\u7535\u6e90\u65f6\u9700\u8981\u4e00\u4e2a\u7535\u6e90\u9002\u914d\u5668\uff0c\u7528\u8ba1\u7b97\u673a\u8bbf\u95ee\u7167\u76f8\u673a\u7684 SD \u5185\u5b58\u5361\u65f6\u9700\u8981\u4e00\u4e2a\u8bfb\u5361\u5668\u7b49\u3002\n\u5728\u8f6f\u4ef6\u8bbe\u8ba1\u4e2d\u4e5f\u53ef\u80fd\u51fa\u73b0\uff1a\u9700\u8981\u5f00\u53d1\u7684\u5177\u6709\u67d0\u79cd\u4e1a\u52a1\u529f\u80fd\u7684\u7ec4\u4ef6\u5728\u73b0\u6709\u7684\u7ec4\u4ef6\u5e93\u4e2d\u5df2\u7ecf\u5b58\u5728\uff0c\u4f46\u5b83\u4eec\u4e0e\u5f53\u524d\u7cfb\u7edf\u7684\u63a5\u53e3\u89c4\u8303\u4e0d\u517c\u5bb9\uff0c\u5982\u679c\u91cd\u65b0\u5f00\u53d1\u8fd9\u4e9b\u7ec4\u4ef6\u6210\u672c\u53c8\u5f88\u9ad8\uff0c\u8fd9\u65f6\u7528\u9002\u914d\u5668\u6a21\u5f0f\u80fd\u5f88\u597d\u5730\u89e3\u51b3\u8fd9\u4e9b\u95ee\u9898\u3002"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:'/**\n * \u76ee\u6807\u5b9a\u4e49\u4e86\u5ba2\u6237\u7aef\u4ee3\u7801\u4f7f\u7528\u7684\u9886\u57df\u7279\u5b9a\u63a5\u53e3\u3002\n */\nclass Target {\n public:\n  virtual ~Target() = default;\n  virtual std::string Request() const {\n    return "Target: The default target\'s behavior.";\n  }\n};\n\n/**\n * \u9002\u914d\u5668\u5305\u542b\u4e00\u4e9b\u6709\u7528\u7684\u884c\u4e3a\uff0c\u4f46\u5176\u63a5\u53e3\u4e0e\u73b0\u6709\u7684\u5ba2\u6237\u7aef\u4ee3\u7801\u4e0d\u517c\u5bb9\u3002\u9002\u914d\u5668\u9700\u8981\u5728\u5ba2\u6237\u7aef\u4ee3\u7801\u53ef\u4ee5\u4f7f\u7528\u5b83\u4e4b\u524d\u8fdb\u884c\u4e00\u4e9b\u9002\u5e94\u3002\n */\nclass Adaptee {\n public:\n  std::string SpecificRequest() const {\n    return ".eetpadA eht fo roivaheb laicepS";\n  }\n};\n\n/**\n * \u9002\u914d\u5668\u4f7f\u9002\u914d\u5668\u7684\u63a5\u53e3\u4e0e\u76ee\u6807\u7684\u63a5\u53e3\u517c\u5bb9\u3002\n */\nclass Adapter : public Target {\n private:\n  Adaptee *adaptee_;\n\n public:\n  Adapter(Adaptee *adaptee) : adaptee_(adaptee) {}\n  std::string Request() const override {\n    std::string to_reverse = this->adaptee_->SpecificRequest();\n    std::reverse(to_reverse.begin(), to_reverse.end());\n    return "Adapter: (TRANSLATED) " + to_reverse;\n  }\n};\n\n/**\n * The client code supports all classes that follow the Target interface.\n */\nvoid ClientCode(const Target *target) {\n  std::cout << target->Request();\n}\n\nint main() {\n  std::cout << "Client: \u9ed8\u8ba4\u7684\u5bf9\u8c61\u5de5\u4f5c\u5f88\u597d\uff1a\\n";\n  Target *target = new Target;\n  ClientCode(target);\n  std::cout << "\\n\\n";\n  Adaptee *adaptee = new Adaptee;\n  std::cout << "Client: The Adaptee class has a weird interface. See, I don\'t understand it:\\n";\n  std::cout << "Adaptee: " << adaptee->SpecificRequest();\n  std::cout << "\\n\\n";\n  std::cout << "Client: But I can work with it via the Adapter:\\n";\n  Adapter *adapter = new Adapter(adaptee);\n  ClientCode(adapter);\n\n  delete target;\n  delete adaptee;\n  delete adapter;\n\n  return 0;\n}\n'})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-text",metastring:'title="output"',children:"Client: I can work just fine with the Target objects:\nTarget: The default target's behavior.\n\nClient: The Adaptee class has a weird interface. See, I don't understand it:\nAdaptee: .eetpadA eht fo roivaheb laicepS\n\nClient: But I can work with it via the Adapter:\nAdapter: (TRANSLATED) Special behavior of the Adaptee.\n"})}),"\n",(0,o.jsx)(n.h2,{id:"\u6865\u63a5\u6a21\u5f0f",children:"\u6865\u63a5\u6a21\u5f0f"}),"\n",(0,o.jsx)(n.p,{children:"Bridge \u5c06\u62bd\u8c61\u4e0e\u5b9e\u73b0\u5206\u79bb\uff0c\u4f7f\u5b83\u4eec\u53ef\u4ee5\u72ec\u7acb\u53d8\u5316\u3002\u5b83\u662f\u7528\u7ec4\u5408\u5173\u7cfb\u4ee3\u66ff\u7ee7\u627f\u5173\u7cfb\u6765\u5b9e\u73b0\uff0c\u4ece\u800c\u964d\u4f4e\u4e86\u62bd\u8c61\u548c\u5b9e\u73b0\u8fd9\u4e24\u4e2a\u53ef\u53d8\u7ef4\u5ea6\u7684\u8026\u5408\u5ea6\u3002"}),"\n",(0,o.jsx)(n.p,{children:"\u4f18\u70b9\n\u7531\u4e8e\u62bd\u8c61\u4e0e\u5b9e\u73b0\u5206\u79bb\uff0c\u6240\u4ee5\u6269\u5c55\u80fd\u529b\u5f3a\uff1b\n\u5176\u5b9e\u73b0\u7ec6\u8282\u5bf9\u5ba2\u6237\u900f\u660e\u3002\n\u7f3a\u70b9\n\u8981\u6c42\u5f00\u53d1\u8005\u9488\u5bf9\u62bd\u8c61\u5316\u8fdb\u884c\u8bbe\u8ba1\u4e0e\u7f16\u7a0b\n\u5e94\u7528\u573a\u666f"}),"\n",(0,o.jsx)(n.p,{children:"\u5728\u73b0\u5b9e\u751f\u6d3b\u4e2d\uff0c\u67d0\u4e9b\u7c7b\u5177\u6709\u4e24\u4e2a\u6216\u591a\u4e2a\u7ef4\u5ea6\u7684\u53d8\u5316\uff0c\u5982\u56fe\u5f62\u65e2\u53ef\u6309\u5f62\u72b6\u5206\uff0c\u53c8\u53ef\u6309\u989c\u8272\u5206\u3002\u5982\u4f55\u8bbe\u8ba1\u7c7b\u4f3c\u4e8e Photoshop \u8fd9\u6837\u7684\u8f6f\u4ef6\uff0c\u80fd\u753b\u4e0d\u540c\u5f62\u72b6\u548c\u4e0d\u540c\u989c\u8272\u7684\u56fe\u5f62\u5462\uff1f\u5982\u679c\u7528\u7ee7\u627f\u65b9\u5f0f\uff0cm \u79cd\u5f62\u72b6\u548c n \u79cd\u989c\u8272\u7684\u56fe\u5f62\u5c31\u6709 m\xd7n \u79cd\uff0c\u4e0d\u4f46\u5bf9\u5e94\u7684\u5b50\u7c7b\u5f88\u591a\uff0c\u800c\u4e14\u6269\u5c55\u56f0\u96be\u3002\n\u8fd9\u6837\u7684\u4f8b\u5b50\u8fd8\u6709\u5f88\u591a\uff0c\u5982\u4e0d\u540c\u989c\u8272\u548c\u5b57\u4f53\u7684\u6587\u5b57\u3001\u4e0d\u540c\u54c1\u724c\u548c\u529f\u7387\u7684\u6c7d\u8f66\u3001\u4e0d\u540c\u6027\u522b\u548c\u804c\u4e1a\u7684\u7537\u5973\u3001\u652f\u6301\u4e0d\u540c\u5e73\u53f0\u548c\u4e0d\u540c\u6587\u4ef6\u683c\u5f0f\u7684\u5a92\u4f53\u64ad\u653e\u5668\u7b49\u3002"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:'/**\n * \u5b9e\u73b0\u5b9a\u4e49\u4e86\u6240\u6709\u5b9e\u73b0\u7c7b\u7684\u63a5\u53e3\u3002\u5b83\u4e0d\u5fc5\u4e0e\u62bd\u8c61\u7684\u63a5\u53e3\u5339\u914d\u3002\u4e8b\u5b9e\u4e0a\uff0c\u8fd9\u4e24\u4e2a\u63a5\u53e3\u53ef\u4ee5\u5b8c\u5168\u4e0d\u540c\u3002\u901a\u5e38\uff0c\u5b9e\u73b0\u63a5\u53e3\u4ec5\u63d0\u4f9b\u539f\u59cb\u64cd\u4f5c\uff0c\u800c\u62bd\u8c61\u6839\u636e\u8fd9\u4e9b\u539f\u59cb\u64cd\u4f5c\u5b9a\u4e49\u66f4\u9ad8\u7ea7\u522b\u7684\u64cd\u4f5c\u3002\n */\n\nclass Implementation {\n public:\n  virtual ~Implementation() {}\n  virtual std::string OperationImplementation() const = 0;\n};\n\n/**\n * Each Concrete Implementation corresponds to a specific platform and\n * implements the Implementation interface using that platform\'s API.\n */\nclass ConcreteImplementationA : public Implementation {\n public:\n  std::string OperationImplementation() const override {\n    return "ConcreteImplementationA: Here\'s the result on the platform A.\\n";\n  }\n};\nclass ConcreteImplementationB : public Implementation {\n public:\n  std::string OperationImplementation() const override {\n    return "ConcreteImplementationB: Here\'s the result on the platform B.\\n";\n  }\n};\n\n/**\n * The Abstraction defines the interface for the "control" part of the two class\n * hierarchies. It maintains a reference to an object of the Implementation\n * hierarchy and delegates all of the real work to this object.\n */\n\nclass Abstraction {\n  /**\n   * @var Implementation\n   */\n protected:\n  Implementation* implementation_;\n\n public:\n  Abstraction(Implementation* implementation) : implementation_(implementation) {\n  }\n\n  virtual ~Abstraction() {\n  }\n\n  virtual std::string Operation() const {\n    return "Abstraction: Base operation with:\\n" +\n           this->implementation_->OperationImplementation();\n  }\n};\n/**\n * You can extend the Abstraction without changing the Implementation classes.\n */\nclass ExtendedAbstraction : public Abstraction {\n public:\n  ExtendedAbstraction(Implementation* implementation) : Abstraction(implementation) {\n  }\n  std::string Operation() const override {\n    return "ExtendedAbstraction: Extended operation with:\\n" +\n           this->implementation_->OperationImplementation();\n  }\n};\n\n/**\n * Except for the initialization phase, where an Abstraction object gets linked\n * with a specific Implementation object, the client code should only depend on\n * the Abstraction class. This way the client code can support any abstraction-\n * implementation combination.\n */\nvoid ClientCode(const Abstraction& abstraction) {\n  // ...\n  std::cout << abstraction.Operation();\n  // ...\n}\n/**\n * The client code should be able to work with any pre-configured abstraction-\n * implementation combination.\n */\n\nint main() {\n  Implementation* implementation = new ConcreteImplementationA;\n  Abstraction* abstraction = new Abstraction(implementation);\n  ClientCode(*abstraction);\n  std::cout << std::endl;\n  delete implementation;\n  delete abstraction;\n\n  implementation = new ConcreteImplementationB;\n  abstraction = new ExtendedAbstraction(implementation);\n  ClientCode(*abstraction);\n\n  delete implementation;\n  delete abstraction;\n\n  return 0;\n}\n'})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-text",metastring:'title="output"',children:"Abstraction: Base operation with:\nConcreteImplementationA: Here's the result on the platform A.\n\nExtendedAbstraction: Extended operation with:\nConcreteImplementationB: Here's the result on the platform B.\n"})}),"\n",(0,o.jsx)(n.h2,{id:"\u88c5\u9970\u6a21\u5f0f",children:"\u88c5\u9970\u6a21\u5f0f"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:'/**\n * The base Component interface defines operations that can be altered by\n * decorators.\n */\nclass Component {\n public:\n  virtual ~Component() {}\n  virtual std::string Operation() const = 0;\n};\n/**\n * Concrete Components provide default implementations of the operations. There\n * might be several variations of these classes.\n */\nclass ConcreteComponent : public Component {\n public:\n  std::string Operation() const override {\n    return "ConcreteComponent";\n  }\n};\n/**\n * The base Decorator class follows the same interface as the other components.\n * The primary purpose of this class is to define the wrapping interface for all\n * concrete decorators. The default implementation of the wrapping code might\n * include a field for storing a wrapped component and the means to initialize\n * it.\n */\nclass Decorator : public Component {\n  /**\n   * @var Component\n   */\n protected:\n  Component* component_;\n\n public:\n  Decorator(Component* component) : component_(component) {\n  }\n  /**\n   * The Decorator delegates all work to the wrapped component.\n   */\n  std::string Operation() const override {\n    return this->component_->Operation();\n  }\n};\n/**\n * Concrete Decorators call the wrapped object and alter its result in some way.\n */\nclass ConcreteDecoratorA : public Decorator {\n  /**\n   * Decorators may call parent implementation of the operation, instead of\n   * calling the wrapped object directly. This approach simplifies extension of\n   * decorator classes.\n   */\n public:\n  ConcreteDecoratorA(Component* component) : Decorator(component) {\n  }\n  std::string Operation() const override {\n    return "ConcreteDecoratorA(" + Decorator::Operation() + ")";\n  }\n};\n/**\n * Decorators can execute their behavior either before or after the call to a\n * wrapped object.\n */\nclass ConcreteDecoratorB : public Decorator {\n public:\n  ConcreteDecoratorB(Component* component) : Decorator(component) {\n  }\n\n  std::string Operation() const override {\n    return "ConcreteDecoratorB(" + Decorator::Operation() + ")";\n  }\n};\n/**\n * The client code works with all objects using the Component interface. This\n * way it can stay independent of the concrete classes of components it works\n * with.\n */\nvoid ClientCode(Component* component) {\n  // ...\n  std::cout << "RESULT: " << component->Operation();\n  // ...\n}\n\nint main() {\n  /**\n   * This way the client code can support both simple components...\n   */\n  Component* simple = new ConcreteComponent;\n  std::cout << "Client: I\'ve got a simple component:\\n";\n  ClientCode(simple);\n  std::cout << "\\n\\n";\n  /**\n   * ...as well as decorated ones.\n   *\n   * Note how decorators can wrap not only simple components but the other\n   * decorators as well.\n   */\n  Component* decorator1 = new ConcreteDecoratorA(simple);\n  Component* decorator2 = new ConcreteDecoratorB(decorator1);\n  std::cout << "Client: Now I\'ve got a decorated component:\\n";\n  ClientCode(decorator2);\n  std::cout << "\\n";\n\n  delete simple;\n  delete decorator1;\n  delete decorator2;\n\n  return 0;\n}\n'})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-text",metastring:'title="output"',children:"Client: I've got a simple component:\nRESULT: ConcreteComponent\n\nClient: Now I've got a decorated component:\nRESULT: ConcreteDecoratorB(ConcreteDecoratorA(ConcreteComponent))\n"})}),"\n",(0,o.jsx)(n.h2,{id:"\u7ec4\u5408\u6a21\u5f0f",children:"\u7ec4\u5408\u6a21\u5f0f"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:'#include <algorithm>\n#include <iostream>\n#include <list>\n#include <string>\n/**\n * The base Component class declares common operations for both simple and\n * complex objects of a composition.\n */\nclass Component {\n  /**\n   * @var Component\n   */\n protected:\n  Component *parent_;\n  /**\n   * Optionally, the base Component can declare an interface for setting and\n   * accessing a parent of the component in a tree structure. It can also\n   * provide some default implementation for these methods.\n   */\n public:\n  virtual ~Component() {}\n  void SetParent(Component *parent) {\n    this->parent_ = parent;\n  }\n  Component *GetParent() const {\n    return this->parent_;\n  }\n  /**\n   * In some cases, it would be beneficial to define the child-management\n   * operations right in the base Component class. This way, you won\'t need to\n   * expose any concrete component classes to the client code, even during the\n   * object tree assembly. The downside is that these methods will be empty for\n   * the leaf-level components.\n   */\n  virtual void Add(Component *component) {}\n  virtual void Remove(Component *component) {}\n  /**\n   * You can provide a method that lets the client code figure out whether a\n   * component can bear children.\n   */\n  virtual bool IsComposite() const {\n    return false;\n  }\n  /**\n   * The base Component may implement some default behavior or leave it to\n   * concrete classes (by declaring the method containing the behavior as\n   * "abstract").\n   */\n  virtual std::string Operation() const = 0;\n};\n/**\n * The Leaf class represents the end objects of a composition. A leaf can\'t have\n * any children.\n *\n * Usually, it\'s the Leaf objects that do the actual work, whereas Composite\n * objects only delegate to their sub-components.\n */\nclass Leaf : public Component {\n public:\n  std::string Operation() const override {\n    return "Leaf";\n  }\n};\n/**\n * The Composite class represents the complex components that may have children.\n * Usually, the Composite objects delegate the actual work to their children and\n * then "sum-up" the result.\n */\nclass Composite : public Component {\n  /**\n   * @var \\SplObjectStorage\n   */\n protected:\n  std::list<Component *> children_;\n\n public:\n  /**\n   * A composite object can add or remove other components (both simple or\n   * complex) to or from its child list.\n   */\n  void Add(Component *component) override {\n    this->children_.push_back(component);\n    component->SetParent(this);\n  }\n  /**\n   * Have in mind that this method removes the pointer to the list but doesn\'t\n   * frees the\n   *     memory, you should do it manually or better use smart pointers.\n   */\n  void Remove(Component *component) override {\n    children_.remove(component);\n    component->SetParent(nullptr);\n  }\n  bool IsComposite() const override {\n    return true;\n  }\n  /**\n   * The Composite executes its primary logic in a particular way. It traverses\n   * recursively through all its children, collecting and summing their results.\n   * Since the composite\'s children pass these calls to their children and so\n   * forth, the whole object tree is traversed as a result.\n   */\n  std::string Operation() const override {\n    std::string result;\n    for (const Component *c : children_) {\n      if (c == children_.back()) {\n        result += c->Operation();\n      } else {\n        result += c->Operation() + "+";\n      }\n    }\n    return "Branch(" + result + ")";\n  }\n};\n/**\n * The client code works with all of the components via the base interface.\n */\nvoid ClientCode(Component *component) {\n  // ...\n  std::cout << "RESULT: " << component->Operation();\n  // ...\n}\n\n/**\n * Thanks to the fact that the child-management operations are declared in the\n * base Component class, the client code can work with any component, simple or\n * complex, without depending on their concrete classes.\n */\nvoid ClientCode2(Component *component1, Component *component2) {\n  // ...\n  if (component1->IsComposite()) {\n    component1->Add(component2);\n  }\n  std::cout << "RESULT: " << component1->Operation();\n  // ...\n}\n\n/**\n * This way the client code can support the simple leaf components...\n */\n\nint main() {\n  Component *simple = new Leaf;\n  std::cout << "Client: I\'ve got a simple component:\\n";\n  ClientCode(simple);\n  std::cout << "\\n\\n";\n  /**\n   * ...as well as the complex composites.\n   */\n\n  Component *tree = new Composite;\n  Component *branch1 = new Composite;\n\n  Component *leaf_1 = new Leaf;\n  Component *leaf_2 = new Leaf;\n  Component *leaf_3 = new Leaf;\n  branch1->Add(leaf_1);\n  branch1->Add(leaf_2);\n  Component *branch2 = new Composite;\n  branch2->Add(leaf_3);\n  tree->Add(branch1);\n  tree->Add(branch2);\n  std::cout << "Client: Now I\'ve got a composite tree:\\n";\n  ClientCode(tree);\n  std::cout << "\\n\\n";\n\n  std::cout << "Client: I don\'t need to check the components classes even when managing the tree:\\n";\n  ClientCode2(tree, simple);\n  std::cout << "\\n";\n\n  delete simple;\n  delete tree;\n  delete branch1;\n  delete branch2;\n  delete leaf_1;\n  delete leaf_2;\n  delete leaf_3;\n\n  return 0;\n}\n'})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-text",metastring:'title="output"',children:"Client: I've got a simple component:\nRESULT: Leaf\n\nClient: Now I've got a composite tree:\nRESULT: Branch(Branch(Leaf+Leaf)+Branch(Leaf))\n\nClient: I don't need to check the components classes even when managing the tree:\nRESULT: Branch(Branch(Leaf+Leaf)+Branch(Leaf)+Leaf)\n"})}),"\n",(0,o.jsx)(n.h2,{id:"\u5916\u89c2\u6a21\u5f0f",children:"\u5916\u89c2\u6a21\u5f0f"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:'/**\n * The Subsystem can accept requests either from the facade or client directly.\n * In any case, to the Subsystem, the Facade is yet another client, and it\'s not\n * a part of the Subsystem.\n */\nclass Subsystem1 {\n public:\n  std::string Operation1() const {\n    return "Subsystem1: Ready!\\n";\n  }\n  // ...\n  std::string OperationN() const {\n    return "Subsystem1: Go!\\n";\n  }\n};\n/**\n * Some facades can work with multiple subsystems at the same time.\n */\nclass Subsystem2 {\n public:\n  std::string Operation1() const {\n    return "Subsystem2: Get ready!\\n";\n  }\n  // ...\n  std::string OperationZ() const {\n    return "Subsystem2: Fire!\\n";\n  }\n};\n\n/**\n * The Facade class provides a simple interface to the complex logic of one or\n * several subsystems. The Facade delegates the client requests to the\n * appropriate objects within the subsystem. The Facade is also responsible for\n * managing their lifecycle. All of this shields the client from the undesired\n * complexity of the subsystem.\n */\nclass Facade {\n protected:\n  Subsystem1 *subsystem1_;\n  Subsystem2 *subsystem2_;\n  /**\n   * Depending on your application\'s needs, you can provide the Facade with\n   * existing subsystem objects or force the Facade to create them on its own.\n   */\n public:\n  /**\n   * In this case we will delegate the memory ownership to Facade Class\n   */\n  Facade(\n      Subsystem1 *subsystem1 = nullptr,\n      Subsystem2 *subsystem2 = nullptr) {\n    this->subsystem1_ = subsystem1 ?: new Subsystem1;\n    this->subsystem2_ = subsystem2 ?: new Subsystem2;\n  }\n  ~Facade() {\n    delete subsystem1_;\n    delete subsystem2_;\n  }\n  /**\n   * The Facade\'s methods are convenient shortcuts to the sophisticated\n   * functionality of the subsystems. However, clients get only to a fraction of\n   * a subsystem\'s capabilities.\n   */\n  std::string Operation() {\n    std::string result = "Facade initializes subsystems:\\n";\n    result += this->subsystem1_->Operation1();\n    result += this->subsystem2_->Operation1();\n    result += "Facade orders subsystems to perform the action:\\n";\n    result += this->subsystem1_->OperationN();\n    result += this->subsystem2_->OperationZ();\n    return result;\n  }\n};\n\n/**\n * The client code works with complex subsystems through a simple interface\n * provided by the Facade. When a facade manages the lifecycle of the subsystem,\n * the client might not even know about the existence of the subsystem. This\n * approach lets you keep the complexity under control.\n */\nvoid ClientCode(Facade *facade) {\n  // ...\n  std::cout << facade->Operation();\n  // ...\n}\n/**\n * The client code may have some of the subsystem\'s objects already created. In\n * this case, it might be worthwhile to initialize the Facade with these objects\n * instead of letting the Facade create new instances.\n */\n\nint main() {\n  Subsystem1 *subsystem1 = new Subsystem1;\n  Subsystem2 *subsystem2 = new Subsystem2;\n  Facade *facade = new Facade(subsystem1, subsystem2);\n  ClientCode(facade);\n\n  delete facade;\n\n  return 0;\n}\n'})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-text",metastring:'title="output"',children:"Facade initializes subsystems:\nSubsystem1: Ready!\nSubsystem2: Get ready!\nFacade orders subsystems to perform the action:\nSubsystem1: Go!\nSubsystem2: Fire!\n"})}),"\n",(0,o.jsx)(n.h2,{id:"\u4eab\u5143\u6a21\u5f0f",children:"\u4eab\u5143\u6a21\u5f0f"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:'/**\n * Flyweight Design Pattern\n *\n * Intent: Lets you fit more objects into the available amount of RAM by sharing\n * common parts of state between multiple objects, instead of keeping all of the\n * data in each object.\n */\n\nstruct SharedState\n{\n    std::string brand_;\n    std::string model_;\n    std::string color_;\n\n    SharedState(const std::string &brand, const std::string &model, const std::string &color)\n        : brand_(brand), model_(model), color_(color)\n    {\n    }\n\n    friend std::ostream &operator<<(std::ostream &os, const SharedState &ss)\n    {\n        return os << "[ " << ss.brand_ << " , " << ss.model_ << " , " << ss.color_ << " ]";\n    }\n};\n\nstruct UniqueState\n{\n    std::string owner_;\n    std::string plates_;\n\n    UniqueState(const std::string &owner, const std::string &plates)\n        : owner_(owner), plates_(plates)\n    {\n    }\n\n    friend std::ostream &operator<<(std::ostream &os, const UniqueState &us)\n    {\n        return os << "[ " << us.owner_ << " , " << us.plates_ << " ]";\n    }\n};\n\n/**\n * The Flyweight stores a common portion of the state (also called intrinsic\n * state) that belongs to multiple real business entities. The Flyweight accepts\n * the rest of the state (extrinsic state, unique for each entity) via its\n * method parameters.\n */\nclass Flyweight\n{\nprivate:\n    SharedState *shared_state_;\n\npublic:\n    Flyweight(const SharedState *shared_state) : shared_state_(new SharedState(*shared_state))\n    {\n    }\n    Flyweight(const Flyweight &other) : shared_state_(new SharedState(*other.shared_state_))\n    {\n    }\n    ~Flyweight()\n    {\n        delete shared_state_;\n    }\n    SharedState *shared_state() const\n    {\n        return shared_state_;\n    }\n    void Operation(const UniqueState &unique_state) const\n    {\n        std::cout << "Flyweight: Displaying shared (" << *shared_state_ << ") and unique (" << unique_state << ") state.\\n";\n    }\n};\n/**\n * The Flyweight Factory creates and manages the Flyweight objects. It ensures\n * that flyweights are shared correctly. When the client requests a flyweight,\n * the factory either returns an existing instance or creates a new one, if it\n * doesn\'t exist yet.\n */\nclass FlyweightFactory\n{\n    /**\n     * @var Flyweight[]\n     */\nprivate:\n    std::unordered_map<std::string, Flyweight> flyweights_;\n    /**\n     * Returns a Flyweight\'s string hash for a given state.\n     */\n    std::string GetKey(const SharedState &ss) const\n    {\n        return ss.brand_ + "_" + ss.model_ + "_" + ss.color_;\n    }\n\npublic:\n    FlyweightFactory(std::initializer_list<SharedState> share_states)\n    {\n        for (const SharedState &ss : share_states)\n        {\n            this->flyweights_.insert(std::make_pair<std::string, Flyweight>(this->GetKey(ss), Flyweight(&ss)));\n        }\n    }\n\n    /**\n     * Returns an existing Flyweight with a given state or creates a new one.\n     */\n    Flyweight GetFlyweight(const SharedState &shared_state)\n    {\n        std::string key = this->GetKey(shared_state);\n        if (this->flyweights_.find(key) == this->flyweights_.end())\n        {\n            std::cout << "FlyweightFactory: Can\'t find a flyweight, creating new one.\\n";\n            this->flyweights_.insert(std::make_pair(key, Flyweight(&shared_state)));\n        }\n        else\n        {\n            std::cout << "FlyweightFactory: Reusing existing flyweight.\\n";\n        }\n        return this->flyweights_.at(key);\n    }\n    void ListFlyweights() const\n    {\n        size_t count = this->flyweights_.size();\n        std::cout << "\\nFlyweightFactory: I have " << count << " flyweights:\\n";\n        for (std::pair<std::string, Flyweight> pair : this->flyweights_)\n        {\n            std::cout << pair.first << "\\n";\n        }\n    }\n};\n\n// ...\nvoid AddCarToPoliceDatabase(\n    FlyweightFactory &ff, const std::string &plates, const std::string &owner,\n    const std::string &brand, const std::string &model, const std::string &color)\n{\n    std::cout << "\\nClient: Adding a car to database.\\n";\n    const Flyweight &flyweight = ff.GetFlyweight({brand, model, color});\n    // The client code either stores or calculates extrinsic state and passes it\n    // to the flyweight\'s methods.\n    flyweight.Operation({owner, plates});\n}\n\n/**\n * The client code usually creates a bunch of pre-populated flyweights in the\n * initialization stage of the application.\n */\n\nint main()\n{\n    FlyweightFactory *factory = new FlyweightFactory({{"Chevrolet", "Camaro2018", "pink"}, {"Mercedes Benz", "C300", "black"}, {"Mercedes Benz", "C500", "red"}, {"BMW", "M5", "red"}, {"BMW", "X6", "white"}});\n    factory->ListFlyweights();\n\n    AddCarToPoliceDatabase(*factory,\n                            "CL234IR",\n                            "James Doe",\n                            "BMW",\n                            "M5",\n                            "red");\n\n    AddCarToPoliceDatabase(*factory,\n                            "CL234IR",\n                            "James Doe",\n                            "BMW",\n                            "X1",\n                            "red");\n    factory->ListFlyweights();\n    delete factory;\n\n    return 0;\n}\n'})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-text",metastring:'title="output"',children:"FlyweightFactory: I have 5 flyweights:\nBMW_X6_white\nMercedes Benz_C500_red\nMercedes Benz_C300_black\nBMW_M5_red\nChevrolet_Camaro2018_pink\n\nClient: Adding a car to database.\nFlyweightFactory: Reusing existing flyweight.\nFlyweight: Displaying shared ([ BMW , M5 , red ]) and unique ([ CL234IR , James Doe ]) state.\n\nClient: Adding a car to database.\nFlyweightFactory: Can't find a flyweight, creating new one.\nFlyweight: Displaying shared ([ BMW , X1 , red ]) and unique ([ CL234IR , James Doe ]) state.\n\nFlyweightFactory: I have 6 flyweights:\nBMW_X1_red\nMercedes Benz_C300_black\nBMW_X6_white\nMercedes Benz_C500_red\nBMW_M5_red\nChevrolet_Camaro2018_pink\n"})}),"\n",(0,o.jsx)(n.h2,{id:"\u4ee3\u7406\u6a21\u5f0f",children:"\u4ee3\u7406\u6a21\u5f0f"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:'#include <iostream>\n/**\n * The Subject interface declares common operations for both RealSubject and the\n * Proxy. As long as the client works with RealSubject using this interface,\n * you\'ll be able to pass it a proxy instead of a real subject.\n */\nclass Subject {\n public:\n  virtual void Request() const = 0;\n};\n/**\n * The RealSubject contains some core business logic. Usually, RealSubjects are\n * capable of doing some useful work which may also be very slow or sensitive -\n * e.g. correcting input data. A Proxy can solve these issues without any\n * changes to the RealSubject\'s code.\n */\nclass RealSubject : public Subject {\n public:\n  void Request() const override {\n    std::cout << "RealSubject: Handling request.\\n";\n  }\n};\n/**\n * The Proxy has an interface identical to the RealSubject.\n */\nclass Proxy : public Subject {\n  /**\n   * @var RealSubject\n   */\n private:\n  RealSubject *real_subject_;\n\n  bool CheckAccess() const {\n    // Some real checks should go here.\n    std::cout << "Proxy: Checking access prior to firing a real request.\\n";\n    return true;\n  }\n  void LogAccess() const {\n    std::cout << "Proxy: Logging the time of request.\\n";\n  }\n\n  /**\n   * The Proxy maintains a reference to an object of the RealSubject class. It\n   * can be either lazy-loaded or passed to the Proxy by the client.\n   */\n public:\n  Proxy(RealSubject *real_subject) : real_subject_(new RealSubject(*real_subject)) {\n  }\n\n  ~Proxy() {\n    delete real_subject_;\n  }\n  /**\n   * The most common applications of the Proxy pattern are lazy loading,\n   * caching, controlling the access, logging, etc. A Proxy can perform one of\n   * these things and then, depending on the result, pass the execution to the\n   * same method in a linked RealSubject object.\n   */\n  void Request() const override {\n    if (this->CheckAccess()) {\n      this->real_subject_->Request();\n      this->LogAccess();\n    }\n  }\n};\n/**\n * The client code is supposed to work with all objects (both subjects and\n * proxies) via the Subject interface in order to support both real subjects and\n * proxies. In real life, however, clients mostly work with their real subjects\n * directly. In this case, to implement the pattern more easily, you can extend\n * your proxy from the real subject\'s class.\n */\nvoid ClientCode(const Subject &subject) {\n  // ...\n  subject.Request();\n  // ...\n}\n\nint main() {\n  std::cout << "Client: Executing the client code with a real subject:\\n";\n  RealSubject *real_subject = new RealSubject;\n  ClientCode(*real_subject);\n  std::cout << "\\n";\n  std::cout << "Client: Executing the same client code with a proxy:\\n";\n  Proxy *proxy = new Proxy(real_subject);\n  ClientCode(*proxy);\n\n  delete real_subject;\n  delete proxy;\n  return 0;\n}\n'})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-text",metastring:'title="output"',children:"Client: Executing the client code with a real subject:\nRealSubject: Handling request.\n\nClient: Executing the same client code with a proxy:\nProxy: Checking access prior to firing a real request.\nRealSubject: Handling request.\nProxy: Logging the time of request.\n"})})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>r});var o=t(6540);const s={},a=o.createContext(s);function i(e){const n=o.useContext(a);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),o.createElement(a.Provider,{value:n},e.children)}}}]);