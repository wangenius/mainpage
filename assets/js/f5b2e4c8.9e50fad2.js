"use strict";(self.webpackChunkwangenius=self.webpackChunkwangenius||[]).push([[6974],{4007:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>i,toc:()=>l});var r=t(4848),o=t(8453);const s={title:"\u7ed3\u6784\u578b\u6a21\u5f0f",sidebar_position:5,slug:"\u7ed3\u6784\u578b\u6a21\u5f0f"},a="\u7ed3\u6784\u578b\u6a21\u5f0f",i={id:"lang/cpp/\u9762\u5411\u5bf9\u8c61/\u7ed3\u6784\u578b\u6a21\u5f0f",title:"\u7ed3\u6784\u578b\u6a21\u5f0f",description:"\u9002\u914d\u5668\u6a21\u5f0f",source:"@site/docs/lang/cpp/\u9762\u5411\u5bf9\u8c61/\u7ed3\u6784\u578b\u6a21\u5f0f.mdx",sourceDirName:"lang/cpp/\u9762\u5411\u5bf9\u8c61",slug:"/lang/cpp/\u9762\u5411\u5bf9\u8c61/\u7ed3\u6784\u578b\u6a21\u5f0f",permalink:"/mainpage/docs/lang/cpp/\u9762\u5411\u5bf9\u8c61/\u7ed3\u6784\u578b\u6a21\u5f0f",draft:!1,unlisted:!1,editUrl:"https://github.com/wangenius/mainpage/tree/master/docs/lang/cpp/\u9762\u5411\u5bf9\u8c61/\u7ed3\u6784\u578b\u6a21\u5f0f.mdx",tags:[],version:"current",sidebarPosition:5,frontMatter:{title:"\u7ed3\u6784\u578b\u6a21\u5f0f",sidebar_position:5,slug:"\u7ed3\u6784\u578b\u6a21\u5f0f"},sidebar:"cpp",previous:{title:"\u521b\u5efa\u578b\u6a21\u5f0f",permalink:"/mainpage/docs/lang/cpp/\u9762\u5411\u5bf9\u8c61/\u521b\u5efa\u578b\u6a21\u5f0f"},next:{title:"\u884c\u4e3a\u578b\u6a21\u5f0f",permalink:"/mainpage/docs/lang/cpp/\u9762\u5411\u5bf9\u8c61/\u884c\u4e3a\u578b\u6a21\u5f0f"}},c={},l=[{value:"\u9002\u914d\u5668\u6a21\u5f0f",id:"\u9002\u914d\u5668\u6a21\u5f0f",level:2},{value:"\u6865\u63a5\u6a21\u5f0f",id:"\u6865\u63a5\u6a21\u5f0f",level:2},{value:"\u88c5\u9970\u6a21\u5f0f",id:"\u88c5\u9970\u6a21\u5f0f",level:2},{value:"\u7ec4\u5408\u6a21\u5f0f",id:"\u7ec4\u5408\u6a21\u5f0f",level:2},{value:"\u5916\u89c2\u6a21\u5f0f",id:"\u5916\u89c2\u6a21\u5f0f",level:2},{value:"\u4eab\u5143\u6a21\u5f0f",id:"\u4eab\u5143\u6a21\u5f0f",level:2},{value:"\u4ee3\u7406\u6a21\u5f0f",id:"\u4ee3\u7406\u6a21\u5f0f",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h1,{id:"\u7ed3\u6784\u578b\u6a21\u5f0f",children:"\u7ed3\u6784\u578b\u6a21\u5f0f"}),"\n",(0,r.jsx)(n.h2,{id:"\u9002\u914d\u5668\u6a21\u5f0f",children:"\u9002\u914d\u5668\u6a21\u5f0f"}),"\n",(0,r.jsx)(n.p,{children:"Adapter \u5c06\u4e00\u4e2a\u7c7b\u7684\u63a5\u53e3\u8f6c\u6362\u6210\u5ba2\u6237\u5e0c\u671b\u7684\u53e6\u5916\u4e00\u4e2a\u63a5\u53e3\uff0c\u4f7f\u5f97\u539f\u672c\u7531\u4e8e\u63a5\u53e3\u4e0d\u517c\u5bb9\u800c\u4e0d\u80fd\u4e00\u8d77\u5de5\u4f5c\u7684\u90a3\u4e9b\u7c7b\u80fd\u4e00\u8d77\u5de5\u4f5c\u3002"}),"\n",(0,r.jsx)(n.p,{children:"\u4f18\u70b9\r\n\u5ba2\u6237\u7aef\u901a\u8fc7\u9002\u914d\u5668\u53ef\u4ee5\u900f\u660e\u5730\u8c03\u7528\u76ee\u6807\u63a5\u53e3\u3002\r\n\u590d\u7528\u4e86\u73b0\u5b58\u7684\u7c7b\uff0c\u7a0b\u5e8f\u5458\u4e0d\u9700\u8981\u4fee\u6539\u539f\u6709\u4ee3\u7801\u800c\u91cd\u7528\u73b0\u6709\u7684\u9002\u914d\u8005\u7c7b\u3002\r\n\u5c06\u76ee\u6807\u7c7b\u548c\u9002\u914d\u8005\u7c7b\u89e3\u8026\uff0c\u89e3\u51b3\u4e86\u76ee\u6807\u7c7b\u548c\u9002\u914d\u8005\u7c7b\u63a5\u53e3\u4e0d\u4e00\u81f4\u7684\u95ee\u9898\u3002\r\n\u7f3a\u70b9\r\n\u5bf9\u7c7b\u9002\u914d\u5668\u6765\u8bf4\uff0c\u66f4\u6362\u9002\u914d\u5668\u7684\u5b9e\u73b0\u8fc7\u7a0b\u6bd4\u8f83\u590d\u6742\u3002\r\n\u5e94\u7528\u573a\u666f"}),"\n",(0,r.jsx)(n.p,{children:"\u5728\u73b0\u5b9e\u751f\u6d3b\u4e2d\uff0c\u7ecf\u5e38\u51fa\u73b0\u4e24\u4e2a\u5bf9\u8c61\u56e0\u63a5\u53e3\u4e0d\u517c\u5bb9\u800c\u4e0d\u80fd\u5728\u4e00\u8d77\u5de5\u4f5c\u7684\u5b9e\u4f8b\uff0c\u8fd9\u65f6\u9700\u8981\u7b2c\u4e09\u8005\u8fdb\u884c\u9002\u914d\u3002\u4f8b\u5982\uff0c\u8bb2\u4e2d\u6587\u7684\u4eba\u540c\u8bb2\u82f1\u6587\u7684\u4eba\u5bf9\u8bdd\u65f6\u9700\u8981\u4e00\u4e2a\u7ffb\u8bd1\uff0c\u7528\u76f4\u6d41\u7535\u7684\u7b14\u8bb0\u672c\u7535\u8111\u63a5\u4ea4\u6d41\u7535\u6e90\u65f6\u9700\u8981\u4e00\u4e2a\u7535\u6e90\u9002\u914d\u5668\uff0c\u7528\u8ba1\u7b97\u673a\u8bbf\u95ee\u7167\u76f8\u673a\u7684 SD \u5185\u5b58\u5361\u65f6\u9700\u8981\u4e00\u4e2a\u8bfb\u5361\u5668\u7b49\u3002\r\n\u5728\u8f6f\u4ef6\u8bbe\u8ba1\u4e2d\u4e5f\u53ef\u80fd\u51fa\u73b0\uff1a\u9700\u8981\u5f00\u53d1\u7684\u5177\u6709\u67d0\u79cd\u4e1a\u52a1\u529f\u80fd\u7684\u7ec4\u4ef6\u5728\u73b0\u6709\u7684\u7ec4\u4ef6\u5e93\u4e2d\u5df2\u7ecf\u5b58\u5728\uff0c\u4f46\u5b83\u4eec\u4e0e\u5f53\u524d\u7cfb\u7edf\u7684\u63a5\u53e3\u89c4\u8303\u4e0d\u517c\u5bb9\uff0c\u5982\u679c\u91cd\u65b0\u5f00\u53d1\u8fd9\u4e9b\u7ec4\u4ef6\u6210\u672c\u53c8\u5f88\u9ad8\uff0c\u8fd9\u65f6\u7528\u9002\u914d\u5668\u6a21\u5f0f\u80fd\u5f88\u597d\u5730\u89e3\u51b3\u8fd9\u4e9b\u95ee\u9898\u3002"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:'/**\r\n * \u76ee\u6807\u5b9a\u4e49\u4e86\u5ba2\u6237\u7aef\u4ee3\u7801\u4f7f\u7528\u7684\u9886\u57df\u7279\u5b9a\u63a5\u53e3\u3002\r\n */\r\nclass Target {\r\n public:\r\n  virtual ~Target() = default;\r\n  virtual std::string Request() const {\r\n    return "Target: The default target\'s behavior.";\r\n  }\r\n};\r\n\r\n/**\r\n * \u9002\u914d\u5668\u5305\u542b\u4e00\u4e9b\u6709\u7528\u7684\u884c\u4e3a\uff0c\u4f46\u5176\u63a5\u53e3\u4e0e\u73b0\u6709\u7684\u5ba2\u6237\u7aef\u4ee3\u7801\u4e0d\u517c\u5bb9\u3002\u9002\u914d\u5668\u9700\u8981\u5728\u5ba2\u6237\u7aef\u4ee3\u7801\u53ef\u4ee5\u4f7f\u7528\u5b83\u4e4b\u524d\u8fdb\u884c\u4e00\u4e9b\u9002\u5e94\u3002\r\n */\r\nclass Adaptee {\r\n public:\r\n  std::string SpecificRequest() const {\r\n    return ".eetpadA eht fo roivaheb laicepS";\r\n  }\r\n};\r\n\r\n/**\r\n * \u9002\u914d\u5668\u4f7f\u9002\u914d\u5668\u7684\u63a5\u53e3\u4e0e\u76ee\u6807\u7684\u63a5\u53e3\u517c\u5bb9\u3002\r\n */\r\nclass Adapter : public Target {\r\n private:\r\n  Adaptee *adaptee_;\r\n\r\n public:\r\n  Adapter(Adaptee *adaptee) : adaptee_(adaptee) {}\r\n  std::string Request() const override {\r\n    std::string to_reverse = this->adaptee_->SpecificRequest();\r\n    std::reverse(to_reverse.begin(), to_reverse.end());\r\n    return "Adapter: (TRANSLATED) " + to_reverse;\r\n  }\r\n};\r\n\r\n/**\r\n * The client code supports all classes that follow the Target interface.\r\n */\r\nvoid ClientCode(const Target *target) {\r\n  std::cout << target->Request();\r\n}\r\n\r\nint main() {\r\n  std::cout << "Client: \u9ed8\u8ba4\u7684\u5bf9\u8c61\u5de5\u4f5c\u5f88\u597d\uff1a\\n";\r\n  Target *target = new Target;\r\n  ClientCode(target);\r\n  std::cout << "\\n\\n";\r\n  Adaptee *adaptee = new Adaptee;\r\n  std::cout << "Client: The Adaptee class has a weird interface. See, I don\'t understand it:\\n";\r\n  std::cout << "Adaptee: " << adaptee->SpecificRequest();\r\n  std::cout << "\\n\\n";\r\n  std::cout << "Client: But I can work with it via the Adapter:\\n";\r\n  Adapter *adapter = new Adapter(adaptee);\r\n  ClientCode(adapter);\r\n\r\n  delete target;\r\n  delete adaptee;\r\n  delete adapter;\r\n\r\n  return 0;\r\n}\n'})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",metastring:'title="output"',children:"Client: I can work just fine with the Target objects:\r\nTarget: The default target's behavior.\r\n\r\nClient: The Adaptee class has a weird interface. See, I don't understand it:\r\nAdaptee: .eetpadA eht fo roivaheb laicepS\r\n\r\nClient: But I can work with it via the Adapter:\r\nAdapter: (TRANSLATED) Special behavior of the Adaptee.\n"})}),"\n",(0,r.jsx)(n.h2,{id:"\u6865\u63a5\u6a21\u5f0f",children:"\u6865\u63a5\u6a21\u5f0f"}),"\n",(0,r.jsx)(n.p,{children:"Bridge \u5c06\u62bd\u8c61\u4e0e\u5b9e\u73b0\u5206\u79bb\uff0c\u4f7f\u5b83\u4eec\u53ef\u4ee5\u72ec\u7acb\u53d8\u5316\u3002\u5b83\u662f\u7528\u7ec4\u5408\u5173\u7cfb\u4ee3\u66ff\u7ee7\u627f\u5173\u7cfb\u6765\u5b9e\u73b0\uff0c\u4ece\u800c\u964d\u4f4e\u4e86\u62bd\u8c61\u548c\u5b9e\u73b0\u8fd9\u4e24\u4e2a\u53ef\u53d8\u7ef4\u5ea6\u7684\u8026\u5408\u5ea6\u3002"}),"\n",(0,r.jsx)(n.p,{children:"\u4f18\u70b9\r\n\u7531\u4e8e\u62bd\u8c61\u4e0e\u5b9e\u73b0\u5206\u79bb\uff0c\u6240\u4ee5\u6269\u5c55\u80fd\u529b\u5f3a\uff1b\r\n\u5176\u5b9e\u73b0\u7ec6\u8282\u5bf9\u5ba2\u6237\u900f\u660e\u3002\r\n\u7f3a\u70b9\r\n\u8981\u6c42\u5f00\u53d1\u8005\u9488\u5bf9\u62bd\u8c61\u5316\u8fdb\u884c\u8bbe\u8ba1\u4e0e\u7f16\u7a0b\r\n\u5e94\u7528\u573a\u666f"}),"\n",(0,r.jsx)(n.p,{children:"\u5728\u73b0\u5b9e\u751f\u6d3b\u4e2d\uff0c\u67d0\u4e9b\u7c7b\u5177\u6709\u4e24\u4e2a\u6216\u591a\u4e2a\u7ef4\u5ea6\u7684\u53d8\u5316\uff0c\u5982\u56fe\u5f62\u65e2\u53ef\u6309\u5f62\u72b6\u5206\uff0c\u53c8\u53ef\u6309\u989c\u8272\u5206\u3002\u5982\u4f55\u8bbe\u8ba1\u7c7b\u4f3c\u4e8e Photoshop \u8fd9\u6837\u7684\u8f6f\u4ef6\uff0c\u80fd\u753b\u4e0d\u540c\u5f62\u72b6\u548c\u4e0d\u540c\u989c\u8272\u7684\u56fe\u5f62\u5462\uff1f\u5982\u679c\u7528\u7ee7\u627f\u65b9\u5f0f\uff0cm \u79cd\u5f62\u72b6\u548c n \u79cd\u989c\u8272\u7684\u56fe\u5f62\u5c31\u6709 m\xd7n \u79cd\uff0c\u4e0d\u4f46\u5bf9\u5e94\u7684\u5b50\u7c7b\u5f88\u591a\uff0c\u800c\u4e14\u6269\u5c55\u56f0\u96be\u3002\r\n\u8fd9\u6837\u7684\u4f8b\u5b50\u8fd8\u6709\u5f88\u591a\uff0c\u5982\u4e0d\u540c\u989c\u8272\u548c\u5b57\u4f53\u7684\u6587\u5b57\u3001\u4e0d\u540c\u54c1\u724c\u548c\u529f\u7387\u7684\u6c7d\u8f66\u3001\u4e0d\u540c\u6027\u522b\u548c\u804c\u4e1a\u7684\u7537\u5973\u3001\u652f\u6301\u4e0d\u540c\u5e73\u53f0\u548c\u4e0d\u540c\u6587\u4ef6\u683c\u5f0f\u7684\u5a92\u4f53\u64ad\u653e\u5668\u7b49\u3002"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:'/**\r\n * \u5b9e\u73b0\u5b9a\u4e49\u4e86\u6240\u6709\u5b9e\u73b0\u7c7b\u7684\u63a5\u53e3\u3002\u5b83\u4e0d\u5fc5\u4e0e\u62bd\u8c61\u7684\u63a5\u53e3\u5339\u914d\u3002\u4e8b\u5b9e\u4e0a\uff0c\u8fd9\u4e24\u4e2a\u63a5\u53e3\u53ef\u4ee5\u5b8c\u5168\u4e0d\u540c\u3002\u901a\u5e38\uff0c\u5b9e\u73b0\u63a5\u53e3\u4ec5\u63d0\u4f9b\u539f\u59cb\u64cd\u4f5c\uff0c\u800c\u62bd\u8c61\u6839\u636e\u8fd9\u4e9b\u539f\u59cb\u64cd\u4f5c\u5b9a\u4e49\u66f4\u9ad8\u7ea7\u522b\u7684\u64cd\u4f5c\u3002\r\n */\r\n\r\nclass Implementation {\r\n public:\r\n  virtual ~Implementation() {}\r\n  virtual std::string OperationImplementation() const = 0;\r\n};\r\n\r\n/**\r\n * Each Concrete Implementation corresponds to a specific platform and\r\n * implements the Implementation interface using that platform\'s API.\r\n */\r\nclass ConcreteImplementationA : public Implementation {\r\n public:\r\n  std::string OperationImplementation() const override {\r\n    return "ConcreteImplementationA: Here\'s the result on the platform A.\\n";\r\n  }\r\n};\r\nclass ConcreteImplementationB : public Implementation {\r\n public:\r\n  std::string OperationImplementation() const override {\r\n    return "ConcreteImplementationB: Here\'s the result on the platform B.\\n";\r\n  }\r\n};\r\n\r\n/**\r\n * The Abstraction defines the interface for the "control" part of the two class\r\n * hierarchies. It maintains a reference to an object of the Implementation\r\n * hierarchy and delegates all of the real work to this object.\r\n */\r\n\r\nclass Abstraction {\r\n  /**\r\n   * @var Implementation\r\n   */\r\n protected:\r\n  Implementation* implementation_;\r\n\r\n public:\r\n  Abstraction(Implementation* implementation) : implementation_(implementation) {\r\n  }\r\n\r\n  virtual ~Abstraction() {\r\n  }\r\n\r\n  virtual std::string Operation() const {\r\n    return "Abstraction: Base operation with:\\n" +\r\n           this->implementation_->OperationImplementation();\r\n  }\r\n};\r\n/**\r\n * You can extend the Abstraction without changing the Implementation classes.\r\n */\r\nclass ExtendedAbstraction : public Abstraction {\r\n public:\r\n  ExtendedAbstraction(Implementation* implementation) : Abstraction(implementation) {\r\n  }\r\n  std::string Operation() const override {\r\n    return "ExtendedAbstraction: Extended operation with:\\n" +\r\n           this->implementation_->OperationImplementation();\r\n  }\r\n};\r\n\r\n/**\r\n * Except for the initialization phase, where an Abstraction object gets linked\r\n * with a specific Implementation object, the client code should only depend on\r\n * the Abstraction class. This way the client code can support any abstraction-\r\n * implementation combination.\r\n */\r\nvoid ClientCode(const Abstraction& abstraction) {\r\n  // ...\r\n  std::cout << abstraction.Operation();\r\n  // ...\r\n}\r\n/**\r\n * The client code should be able to work with any pre-configured abstraction-\r\n * implementation combination.\r\n */\r\n\r\nint main() {\r\n  Implementation* implementation = new ConcreteImplementationA;\r\n  Abstraction* abstraction = new Abstraction(implementation);\r\n  ClientCode(*abstraction);\r\n  std::cout << std::endl;\r\n  delete implementation;\r\n  delete abstraction;\r\n\r\n  implementation = new ConcreteImplementationB;\r\n  abstraction = new ExtendedAbstraction(implementation);\r\n  ClientCode(*abstraction);\r\n\r\n  delete implementation;\r\n  delete abstraction;\r\n\r\n  return 0;\r\n}\n'})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",metastring:'title="output"',children:"Abstraction: Base operation with:\r\nConcreteImplementationA: Here's the result on the platform A.\r\n\r\nExtendedAbstraction: Extended operation with:\r\nConcreteImplementationB: Here's the result on the platform B.\n"})}),"\n",(0,r.jsx)(n.h2,{id:"\u88c5\u9970\u6a21\u5f0f",children:"\u88c5\u9970\u6a21\u5f0f"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:'/**\r\n * The base Component interface defines operations that can be altered by\r\n * decorators.\r\n */\r\nclass Component {\r\n public:\r\n  virtual ~Component() {}\r\n  virtual std::string Operation() const = 0;\r\n};\r\n/**\r\n * Concrete Components provide default implementations of the operations. There\r\n * might be several variations of these classes.\r\n */\r\nclass ConcreteComponent : public Component {\r\n public:\r\n  std::string Operation() const override {\r\n    return "ConcreteComponent";\r\n  }\r\n};\r\n/**\r\n * The base Decorator class follows the same interface as the other components.\r\n * The primary purpose of this class is to define the wrapping interface for all\r\n * concrete decorators. The default implementation of the wrapping code might\r\n * include a field for storing a wrapped component and the means to initialize\r\n * it.\r\n */\r\nclass Decorator : public Component {\r\n  /**\r\n   * @var Component\r\n   */\r\n protected:\r\n  Component* component_;\r\n\r\n public:\r\n  Decorator(Component* component) : component_(component) {\r\n  }\r\n  /**\r\n   * The Decorator delegates all work to the wrapped component.\r\n   */\r\n  std::string Operation() const override {\r\n    return this->component_->Operation();\r\n  }\r\n};\r\n/**\r\n * Concrete Decorators call the wrapped object and alter its result in some way.\r\n */\r\nclass ConcreteDecoratorA : public Decorator {\r\n  /**\r\n   * Decorators may call parent implementation of the operation, instead of\r\n   * calling the wrapped object directly. This approach simplifies extension of\r\n   * decorator classes.\r\n   */\r\n public:\r\n  ConcreteDecoratorA(Component* component) : Decorator(component) {\r\n  }\r\n  std::string Operation() const override {\r\n    return "ConcreteDecoratorA(" + Decorator::Operation() + ")";\r\n  }\r\n};\r\n/**\r\n * Decorators can execute their behavior either before or after the call to a\r\n * wrapped object.\r\n */\r\nclass ConcreteDecoratorB : public Decorator {\r\n public:\r\n  ConcreteDecoratorB(Component* component) : Decorator(component) {\r\n  }\r\n\r\n  std::string Operation() const override {\r\n    return "ConcreteDecoratorB(" + Decorator::Operation() + ")";\r\n  }\r\n};\r\n/**\r\n * The client code works with all objects using the Component interface. This\r\n * way it can stay independent of the concrete classes of components it works\r\n * with.\r\n */\r\nvoid ClientCode(Component* component) {\r\n  // ...\r\n  std::cout << "RESULT: " << component->Operation();\r\n  // ...\r\n}\r\n\r\nint main() {\r\n  /**\r\n   * This way the client code can support both simple components...\r\n   */\r\n  Component* simple = new ConcreteComponent;\r\n  std::cout << "Client: I\'ve got a simple component:\\n";\r\n  ClientCode(simple);\r\n  std::cout << "\\n\\n";\r\n  /**\r\n   * ...as well as decorated ones.\r\n   *\r\n   * Note how decorators can wrap not only simple components but the other\r\n   * decorators as well.\r\n   */\r\n  Component* decorator1 = new ConcreteDecoratorA(simple);\r\n  Component* decorator2 = new ConcreteDecoratorB(decorator1);\r\n  std::cout << "Client: Now I\'ve got a decorated component:\\n";\r\n  ClientCode(decorator2);\r\n  std::cout << "\\n";\r\n\r\n  delete simple;\r\n  delete decorator1;\r\n  delete decorator2;\r\n\r\n  return 0;\r\n}\n'})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",metastring:'title="output"',children:"Client: I've got a simple component:\r\nRESULT: ConcreteComponent\r\n\r\nClient: Now I've got a decorated component:\r\nRESULT: ConcreteDecoratorB(ConcreteDecoratorA(ConcreteComponent))\n"})}),"\n",(0,r.jsx)(n.h2,{id:"\u7ec4\u5408\u6a21\u5f0f",children:"\u7ec4\u5408\u6a21\u5f0f"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:'#include <algorithm>\r\n#include <iostream>\r\n#include <list>\r\n#include <string>\r\n/**\r\n * The base Component class declares common operations for both simple and\r\n * complex objects of a composition.\r\n */\r\nclass Component {\r\n  /**\r\n   * @var Component\r\n   */\r\n protected:\r\n  Component *parent_;\r\n  /**\r\n   * Optionally, the base Component can declare an interface for setting and\r\n   * accessing a parent of the component in a tree structure. It can also\r\n   * provide some default implementation for these methods.\r\n   */\r\n public:\r\n  virtual ~Component() {}\r\n  void SetParent(Component *parent) {\r\n    this->parent_ = parent;\r\n  }\r\n  Component *GetParent() const {\r\n    return this->parent_;\r\n  }\r\n  /**\r\n   * In some cases, it would be beneficial to define the child-management\r\n   * operations right in the base Component class. This way, you won\'t need to\r\n   * expose any concrete component classes to the client code, even during the\r\n   * object tree assembly. The downside is that these methods will be empty for\r\n   * the leaf-level components.\r\n   */\r\n  virtual void Add(Component *component) {}\r\n  virtual void Remove(Component *component) {}\r\n  /**\r\n   * You can provide a method that lets the client code figure out whether a\r\n   * component can bear children.\r\n   */\r\n  virtual bool IsComposite() const {\r\n    return false;\r\n  }\r\n  /**\r\n   * The base Component may implement some default behavior or leave it to\r\n   * concrete classes (by declaring the method containing the behavior as\r\n   * "abstract").\r\n   */\r\n  virtual std::string Operation() const = 0;\r\n};\r\n/**\r\n * The Leaf class represents the end objects of a composition. A leaf can\'t have\r\n * any children.\r\n *\r\n * Usually, it\'s the Leaf objects that do the actual work, whereas Composite\r\n * objects only delegate to their sub-components.\r\n */\r\nclass Leaf : public Component {\r\n public:\r\n  std::string Operation() const override {\r\n    return "Leaf";\r\n  }\r\n};\r\n/**\r\n * The Composite class represents the complex components that may have children.\r\n * Usually, the Composite objects delegate the actual work to their children and\r\n * then "sum-up" the result.\r\n */\r\nclass Composite : public Component {\r\n  /**\r\n   * @var \\SplObjectStorage\r\n   */\r\n protected:\r\n  std::list<Component *> children_;\r\n\r\n public:\r\n  /**\r\n   * A composite object can add or remove other components (both simple or\r\n   * complex) to or from its child list.\r\n   */\r\n  void Add(Component *component) override {\r\n    this->children_.push_back(component);\r\n    component->SetParent(this);\r\n  }\r\n  /**\r\n   * Have in mind that this method removes the pointer to the list but doesn\'t\r\n   * frees the\r\n   *     memory, you should do it manually or better use smart pointers.\r\n   */\r\n  void Remove(Component *component) override {\r\n    children_.remove(component);\r\n    component->SetParent(nullptr);\r\n  }\r\n  bool IsComposite() const override {\r\n    return true;\r\n  }\r\n  /**\r\n   * The Composite executes its primary logic in a particular way. It traverses\r\n   * recursively through all its children, collecting and summing their results.\r\n   * Since the composite\'s children pass these calls to their children and so\r\n   * forth, the whole object tree is traversed as a result.\r\n   */\r\n  std::string Operation() const override {\r\n    std::string result;\r\n    for (const Component *c : children_) {\r\n      if (c == children_.back()) {\r\n        result += c->Operation();\r\n      } else {\r\n        result += c->Operation() + "+";\r\n      }\r\n    }\r\n    return "Branch(" + result + ")";\r\n  }\r\n};\r\n/**\r\n * The client code works with all of the components via the base interface.\r\n */\r\nvoid ClientCode(Component *component) {\r\n  // ...\r\n  std::cout << "RESULT: " << component->Operation();\r\n  // ...\r\n}\r\n\r\n/**\r\n * Thanks to the fact that the child-management operations are declared in the\r\n * base Component class, the client code can work with any component, simple or\r\n * complex, without depending on their concrete classes.\r\n */\r\nvoid ClientCode2(Component *component1, Component *component2) {\r\n  // ...\r\n  if (component1->IsComposite()) {\r\n    component1->Add(component2);\r\n  }\r\n  std::cout << "RESULT: " << component1->Operation();\r\n  // ...\r\n}\r\n\r\n/**\r\n * This way the client code can support the simple leaf components...\r\n */\r\n\r\nint main() {\r\n  Component *simple = new Leaf;\r\n  std::cout << "Client: I\'ve got a simple component:\\n";\r\n  ClientCode(simple);\r\n  std::cout << "\\n\\n";\r\n  /**\r\n   * ...as well as the complex composites.\r\n   */\r\n\r\n  Component *tree = new Composite;\r\n  Component *branch1 = new Composite;\r\n\r\n  Component *leaf_1 = new Leaf;\r\n  Component *leaf_2 = new Leaf;\r\n  Component *leaf_3 = new Leaf;\r\n  branch1->Add(leaf_1);\r\n  branch1->Add(leaf_2);\r\n  Component *branch2 = new Composite;\r\n  branch2->Add(leaf_3);\r\n  tree->Add(branch1);\r\n  tree->Add(branch2);\r\n  std::cout << "Client: Now I\'ve got a composite tree:\\n";\r\n  ClientCode(tree);\r\n  std::cout << "\\n\\n";\r\n\r\n  std::cout << "Client: I don\'t need to check the components classes even when managing the tree:\\n";\r\n  ClientCode2(tree, simple);\r\n  std::cout << "\\n";\r\n\r\n  delete simple;\r\n  delete tree;\r\n  delete branch1;\r\n  delete branch2;\r\n  delete leaf_1;\r\n  delete leaf_2;\r\n  delete leaf_3;\r\n\r\n  return 0;\r\n}\n'})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",metastring:'title="output"',children:"Client: I've got a simple component:\r\nRESULT: Leaf\r\n\r\nClient: Now I've got a composite tree:\r\nRESULT: Branch(Branch(Leaf+Leaf)+Branch(Leaf))\r\n\r\nClient: I don't need to check the components classes even when managing the tree:\r\nRESULT: Branch(Branch(Leaf+Leaf)+Branch(Leaf)+Leaf)\n"})}),"\n",(0,r.jsx)(n.h2,{id:"\u5916\u89c2\u6a21\u5f0f",children:"\u5916\u89c2\u6a21\u5f0f"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:'/**\r\n * The Subsystem can accept requests either from the facade or client directly.\r\n * In any case, to the Subsystem, the Facade is yet another client, and it\'s not\r\n * a part of the Subsystem.\r\n */\r\nclass Subsystem1 {\r\n public:\r\n  std::string Operation1() const {\r\n    return "Subsystem1: Ready!\\n";\r\n  }\r\n  // ...\r\n  std::string OperationN() const {\r\n    return "Subsystem1: Go!\\n";\r\n  }\r\n};\r\n/**\r\n * Some facades can work with multiple subsystems at the same time.\r\n */\r\nclass Subsystem2 {\r\n public:\r\n  std::string Operation1() const {\r\n    return "Subsystem2: Get ready!\\n";\r\n  }\r\n  // ...\r\n  std::string OperationZ() const {\r\n    return "Subsystem2: Fire!\\n";\r\n  }\r\n};\r\n\r\n/**\r\n * The Facade class provides a simple interface to the complex logic of one or\r\n * several subsystems. The Facade delegates the client requests to the\r\n * appropriate objects within the subsystem. The Facade is also responsible for\r\n * managing their lifecycle. All of this shields the client from the undesired\r\n * complexity of the subsystem.\r\n */\r\nclass Facade {\r\n protected:\r\n  Subsystem1 *subsystem1_;\r\n  Subsystem2 *subsystem2_;\r\n  /**\r\n   * Depending on your application\'s needs, you can provide the Facade with\r\n   * existing subsystem objects or force the Facade to create them on its own.\r\n   */\r\n public:\r\n  /**\r\n   * In this case we will delegate the memory ownership to Facade Class\r\n   */\r\n  Facade(\r\n      Subsystem1 *subsystem1 = nullptr,\r\n      Subsystem2 *subsystem2 = nullptr) {\r\n    this->subsystem1_ = subsystem1 ?: new Subsystem1;\r\n    this->subsystem2_ = subsystem2 ?: new Subsystem2;\r\n  }\r\n  ~Facade() {\r\n    delete subsystem1_;\r\n    delete subsystem2_;\r\n  }\r\n  /**\r\n   * The Facade\'s methods are convenient shortcuts to the sophisticated\r\n   * functionality of the subsystems. However, clients get only to a fraction of\r\n   * a subsystem\'s capabilities.\r\n   */\r\n  std::string Operation() {\r\n    std::string result = "Facade initializes subsystems:\\n";\r\n    result += this->subsystem1_->Operation1();\r\n    result += this->subsystem2_->Operation1();\r\n    result += "Facade orders subsystems to perform the action:\\n";\r\n    result += this->subsystem1_->OperationN();\r\n    result += this->subsystem2_->OperationZ();\r\n    return result;\r\n  }\r\n};\r\n\r\n/**\r\n * The client code works with complex subsystems through a simple interface\r\n * provided by the Facade. When a facade manages the lifecycle of the subsystem,\r\n * the client might not even know about the existence of the subsystem. This\r\n * approach lets you keep the complexity under control.\r\n */\r\nvoid ClientCode(Facade *facade) {\r\n  // ...\r\n  std::cout << facade->Operation();\r\n  // ...\r\n}\r\n/**\r\n * The client code may have some of the subsystem\'s objects already created. In\r\n * this case, it might be worthwhile to initialize the Facade with these objects\r\n * instead of letting the Facade create new instances.\r\n */\r\n\r\nint main() {\r\n  Subsystem1 *subsystem1 = new Subsystem1;\r\n  Subsystem2 *subsystem2 = new Subsystem2;\r\n  Facade *facade = new Facade(subsystem1, subsystem2);\r\n  ClientCode(facade);\r\n\r\n  delete facade;\r\n\r\n  return 0;\r\n}\n'})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",metastring:'title="output"',children:"Facade initializes subsystems:\r\nSubsystem1: Ready!\r\nSubsystem2: Get ready!\r\nFacade orders subsystems to perform the action:\r\nSubsystem1: Go!\r\nSubsystem2: Fire!\n"})}),"\n",(0,r.jsx)(n.h2,{id:"\u4eab\u5143\u6a21\u5f0f",children:"\u4eab\u5143\u6a21\u5f0f"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:'/**\r\n * Flyweight Design Pattern\r\n *\r\n * Intent: Lets you fit more objects into the available amount of RAM by sharing\r\n * common parts of state between multiple objects, instead of keeping all of the\r\n * data in each object.\r\n */\r\n\r\nstruct SharedState\r\n{\r\n    std::string brand_;\r\n    std::string model_;\r\n    std::string color_;\r\n\r\n    SharedState(const std::string &brand, const std::string &model, const std::string &color)\r\n        : brand_(brand), model_(model), color_(color)\r\n    {\r\n    }\r\n\r\n    friend std::ostream &operator<<(std::ostream &os, const SharedState &ss)\r\n    {\r\n        return os << "[ " << ss.brand_ << " , " << ss.model_ << " , " << ss.color_ << " ]";\r\n    }\r\n};\r\n\r\nstruct UniqueState\r\n{\r\n    std::string owner_;\r\n    std::string plates_;\r\n\r\n    UniqueState(const std::string &owner, const std::string &plates)\r\n        : owner_(owner), plates_(plates)\r\n    {\r\n    }\r\n\r\n    friend std::ostream &operator<<(std::ostream &os, const UniqueState &us)\r\n    {\r\n        return os << "[ " << us.owner_ << " , " << us.plates_ << " ]";\r\n    }\r\n};\r\n\r\n/**\r\n * The Flyweight stores a common portion of the state (also called intrinsic\r\n * state) that belongs to multiple real business entities. The Flyweight accepts\r\n * the rest of the state (extrinsic state, unique for each entity) via its\r\n * method parameters.\r\n */\r\nclass Flyweight\r\n{\r\nprivate:\r\n    SharedState *shared_state_;\r\n\r\npublic:\r\n    Flyweight(const SharedState *shared_state) : shared_state_(new SharedState(*shared_state))\r\n    {\r\n    }\r\n    Flyweight(const Flyweight &other) : shared_state_(new SharedState(*other.shared_state_))\r\n    {\r\n    }\r\n    ~Flyweight()\r\n    {\r\n        delete shared_state_;\r\n    }\r\n    SharedState *shared_state() const\r\n    {\r\n        return shared_state_;\r\n    }\r\n    void Operation(const UniqueState &unique_state) const\r\n    {\r\n        std::cout << "Flyweight: Displaying shared (" << *shared_state_ << ") and unique (" << unique_state << ") state.\\n";\r\n    }\r\n};\r\n/**\r\n * The Flyweight Factory creates and manages the Flyweight objects. It ensures\r\n * that flyweights are shared correctly. When the client requests a flyweight,\r\n * the factory either returns an existing instance or creates a new one, if it\r\n * doesn\'t exist yet.\r\n */\r\nclass FlyweightFactory\r\n{\r\n    /**\r\n     * @var Flyweight[]\r\n     */\r\nprivate:\r\n    std::unordered_map<std::string, Flyweight> flyweights_;\r\n    /**\r\n     * Returns a Flyweight\'s string hash for a given state.\r\n     */\r\n    std::string GetKey(const SharedState &ss) const\r\n    {\r\n        return ss.brand_ + "_" + ss.model_ + "_" + ss.color_;\r\n    }\r\n\r\npublic:\r\n    FlyweightFactory(std::initializer_list<SharedState> share_states)\r\n    {\r\n        for (const SharedState &ss : share_states)\r\n        {\r\n            this->flyweights_.insert(std::make_pair<std::string, Flyweight>(this->GetKey(ss), Flyweight(&ss)));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns an existing Flyweight with a given state or creates a new one.\r\n     */\r\n    Flyweight GetFlyweight(const SharedState &shared_state)\r\n    {\r\n        std::string key = this->GetKey(shared_state);\r\n        if (this->flyweights_.find(key) == this->flyweights_.end())\r\n        {\r\n            std::cout << "FlyweightFactory: Can\'t find a flyweight, creating new one.\\n";\r\n            this->flyweights_.insert(std::make_pair(key, Flyweight(&shared_state)));\r\n        }\r\n        else\r\n        {\r\n            std::cout << "FlyweightFactory: Reusing existing flyweight.\\n";\r\n        }\r\n        return this->flyweights_.at(key);\r\n    }\r\n    void ListFlyweights() const\r\n    {\r\n        size_t count = this->flyweights_.size();\r\n        std::cout << "\\nFlyweightFactory: I have " << count << " flyweights:\\n";\r\n        for (std::pair<std::string, Flyweight> pair : this->flyweights_)\r\n        {\r\n            std::cout << pair.first << "\\n";\r\n        }\r\n    }\r\n};\r\n\r\n// ...\r\nvoid AddCarToPoliceDatabase(\r\n    FlyweightFactory &ff, const std::string &plates, const std::string &owner,\r\n    const std::string &brand, const std::string &model, const std::string &color)\r\n{\r\n    std::cout << "\\nClient: Adding a car to database.\\n";\r\n    const Flyweight &flyweight = ff.GetFlyweight({brand, model, color});\r\n    // The client code either stores or calculates extrinsic state and passes it\r\n    // to the flyweight\'s methods.\r\n    flyweight.Operation({owner, plates});\r\n}\r\n\r\n/**\r\n * The client code usually creates a bunch of pre-populated flyweights in the\r\n * initialization stage of the application.\r\n */\r\n\r\nint main()\r\n{\r\n    FlyweightFactory *factory = new FlyweightFactory({{"Chevrolet", "Camaro2018", "pink"}, {"Mercedes Benz", "C300", "black"}, {"Mercedes Benz", "C500", "red"}, {"BMW", "M5", "red"}, {"BMW", "X6", "white"}});\r\n    factory->ListFlyweights();\r\n\r\n    AddCarToPoliceDatabase(*factory,\r\n                            "CL234IR",\r\n                            "James Doe",\r\n                            "BMW",\r\n                            "M5",\r\n                            "red");\r\n\r\n    AddCarToPoliceDatabase(*factory,\r\n                            "CL234IR",\r\n                            "James Doe",\r\n                            "BMW",\r\n                            "X1",\r\n                            "red");\r\n    factory->ListFlyweights();\r\n    delete factory;\r\n\r\n    return 0;\r\n}\n'})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",metastring:'title="output"',children:"FlyweightFactory: I have 5 flyweights:\r\nBMW_X6_white\r\nMercedes Benz_C500_red\r\nMercedes Benz_C300_black\r\nBMW_M5_red\r\nChevrolet_Camaro2018_pink\r\n\r\nClient: Adding a car to database.\r\nFlyweightFactory: Reusing existing flyweight.\r\nFlyweight: Displaying shared ([ BMW , M5 , red ]) and unique ([ CL234IR , James Doe ]) state.\r\n\r\nClient: Adding a car to database.\r\nFlyweightFactory: Can't find a flyweight, creating new one.\r\nFlyweight: Displaying shared ([ BMW , X1 , red ]) and unique ([ CL234IR , James Doe ]) state.\r\n\r\nFlyweightFactory: I have 6 flyweights:\r\nBMW_X1_red\r\nMercedes Benz_C300_black\r\nBMW_X6_white\r\nMercedes Benz_C500_red\r\nBMW_M5_red\r\nChevrolet_Camaro2018_pink\n"})}),"\n",(0,r.jsx)(n.h2,{id:"\u4ee3\u7406\u6a21\u5f0f",children:"\u4ee3\u7406\u6a21\u5f0f"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:'#include <iostream>\r\n/**\r\n * The Subject interface declares common operations for both RealSubject and the\r\n * Proxy. As long as the client works with RealSubject using this interface,\r\n * you\'ll be able to pass it a proxy instead of a real subject.\r\n */\r\nclass Subject {\r\n public:\r\n  virtual void Request() const = 0;\r\n};\r\n/**\r\n * The RealSubject contains some core business logic. Usually, RealSubjects are\r\n * capable of doing some useful work which may also be very slow or sensitive -\r\n * e.g. correcting input data. A Proxy can solve these issues without any\r\n * changes to the RealSubject\'s code.\r\n */\r\nclass RealSubject : public Subject {\r\n public:\r\n  void Request() const override {\r\n    std::cout << "RealSubject: Handling request.\\n";\r\n  }\r\n};\r\n/**\r\n * The Proxy has an interface identical to the RealSubject.\r\n */\r\nclass Proxy : public Subject {\r\n  /**\r\n   * @var RealSubject\r\n   */\r\n private:\r\n  RealSubject *real_subject_;\r\n\r\n  bool CheckAccess() const {\r\n    // Some real checks should go here.\r\n    std::cout << "Proxy: Checking access prior to firing a real request.\\n";\r\n    return true;\r\n  }\r\n  void LogAccess() const {\r\n    std::cout << "Proxy: Logging the time of request.\\n";\r\n  }\r\n\r\n  /**\r\n   * The Proxy maintains a reference to an object of the RealSubject class. It\r\n   * can be either lazy-loaded or passed to the Proxy by the client.\r\n   */\r\n public:\r\n  Proxy(RealSubject *real_subject) : real_subject_(new RealSubject(*real_subject)) {\r\n  }\r\n\r\n  ~Proxy() {\r\n    delete real_subject_;\r\n  }\r\n  /**\r\n   * The most common applications of the Proxy pattern are lazy loading,\r\n   * caching, controlling the access, logging, etc. A Proxy can perform one of\r\n   * these things and then, depending on the result, pass the execution to the\r\n   * same method in a linked RealSubject object.\r\n   */\r\n  void Request() const override {\r\n    if (this->CheckAccess()) {\r\n      this->real_subject_->Request();\r\n      this->LogAccess();\r\n    }\r\n  }\r\n};\r\n/**\r\n * The client code is supposed to work with all objects (both subjects and\r\n * proxies) via the Subject interface in order to support both real subjects and\r\n * proxies. In real life, however, clients mostly work with their real subjects\r\n * directly. In this case, to implement the pattern more easily, you can extend\r\n * your proxy from the real subject\'s class.\r\n */\r\nvoid ClientCode(const Subject &subject) {\r\n  // ...\r\n  subject.Request();\r\n  // ...\r\n}\r\n\r\nint main() {\r\n  std::cout << "Client: Executing the client code with a real subject:\\n";\r\n  RealSubject *real_subject = new RealSubject;\r\n  ClientCode(*real_subject);\r\n  std::cout << "\\n";\r\n  std::cout << "Client: Executing the same client code with a proxy:\\n";\r\n  Proxy *proxy = new Proxy(real_subject);\r\n  ClientCode(*proxy);\r\n\r\n  delete real_subject;\r\n  delete proxy;\r\n  return 0;\r\n}\n'})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",metastring:'title="output"',children:"Client: Executing the client code with a real subject:\r\nRealSubject: Handling request.\r\n\r\nClient: Executing the same client code with a proxy:\r\nProxy: Checking access prior to firing a real request.\r\nRealSubject: Handling request.\r\nProxy: Logging the time of request.\n"})})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>i});var r=t(6540);const o={},s=r.createContext(o);function a(e){const n=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);