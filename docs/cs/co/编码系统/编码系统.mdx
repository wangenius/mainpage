程序的生命周期从**源程序（源文件）**开始。源程序实际上就是由 0 和 1 组成的位序列。

一般用 **ASCII 标准**来表示**文本字符**，实际上是用一个字节的整数值来表示一种字符。

源文件中每个文本行都是以看不见的 '\n' 结束的。

只由 ASCII 字符组成的文件成为**文本文件**，其他都是**二进制文件**。.cpp 文件就是文本文件。

系统中的所有信息都是由一串比特（bit：位）表示的，区分不同数据对象的**唯一方法**就是根据上下文。

## 定点数

大多数计算机系统采用补码来表示机器数，符号位加入运算，加法方便实现减法，零的表示唯一，多表示一个负数

分为无符号数和有符号数。无符号数所有位都是数值位，有符号数的最高位一位是符号位。无符号整数都是二进制非负数，不需要过多的解释。重点在于有符号数。

关于有符号数，正数的符号为`0`，三码（原码，反码，补码）相同，数值=真值。负数的符号`1`，反码和原码分别对应每位求反，补码是在反码的基础上，末位加`1`。

简化反码的中间步骤，关于原码和补码的转化规则如下：**`1`内取反，负数生效。**意思是将二进制码最左边的1和最右边的1中间的所有位取反。在负数时生效即最左边的1即符号位的1.

例如：原码`10010110`的补码是`11101010`。

补码的符号位相同时，数值位越大，码值越大。且不同于反码和原码的两种，`0`的补码只有一种，所以可以多表示一个`-128`。

移码是补码的符号位取反，实际含义是真值+偏移值

## 一些需要记忆的常用值

1. 无符号：`1B = 0~255` `2B = 0~65535` `4B = 0~4294967295`

2. 有符号：`1B = -128~127` `2B = -32768~32767` `4B = -2147483648~2147483647`

### 移位运算

1. **逻辑移位**`shl eax,1;shl ebx, cl;`**：无符号数，空位补零**

2. **算数移位：正数三码空位补零，负数原0反1，补码左0右1.**

算术移位中，补码左移的前提条件是，原最高有效位和原符号位相同

双符号位的移位操作，只有低符号位需要参加移位操作

### 加减运算

1. 加减运算(补码)

2. 3. 原码 符号位和数值位判断求之

溢出判断

1. 加数符号相同，结果符号不同，产生溢出。

2. 最高数值位进位和符号位进位异或，结果为1则溢出。

3. 变形补码：两符号位进行判断：符号位不同表示溢出，高位符号位代表真正的符号。

### 乘法运算

乘法是通过加法和移位操作进行的，两个n位数相乘，需要进行n次加法操作和n次移位操作

```Rust
1. 符号位 单独异或运算
2. 数值位 X Y
res = 0.00000
X = 0.ABCDE
Y = 0.abcde
for(i in edcba){
	res = res + i * X;
    res >> 1;//因为都是绝对值，没有正负，所以移位都是高位补零，所以是逻辑移位
}
3. 整合符号位和数值位
// Y的每一位起判断作用，每判断一次，Y的最低位就没用了
// 因此ACC和MQ的寄存器放一起，ACC放乘积高位，MQ放乘数和乘积低位
```

```Rust
// 矫正法
Y是正数按照原码运算规则，移位按照补码的算数移位进行。
Y是负数按照原码运算规则，移位按照补码的算数移位进行，在最后结果上加上[-x]_b进行矫正

// 比较法
双符号位 例题看王道e2.8
R = 00.00000
X = UU.ABCDE
Y = N.abcde_f
while ._没相遇{
if	e_f == 0_0 RY >>1
if e_f == 1_0 RY + [-x]_b >>1
if e_f == 0_1 RY + x_b >>1
if e_f == 1_1 Ry >>1
}
._相遇 完成最后一次加法操作
合并RY即为所求补码
```

### 除法运算

具有`N`位尾数的合法除法，逻辑移位`N`次，上商`N+1`次

## 浮点数

IEEE754 **：**`1+8+23`格式，尾数原码**纯小数**，**阶码定点正数：移码 指数e真值要减去127**

**偏移量127 因为阶码全0表示指数负无穷，阶码全1表示正无穷大**

浮点数规格化

1. 左移阶码-1，右移阶码+1

溢出判断：

1. 对阶操作不会引起溢出

2. 右归和尾数舍入都可能引起阶码上溢

3. 左归时可能引起阶码下溢

4. 尾数溢出时结果不一定溢出

### 加减运算

1. 对阶

2. 尾数求和

3. 规格化 _溢出风险_

4. 舍入 _溢出风险_

# 指令

## 指令格式

指令字长取决于操作码的长度，操作数地址的长度以及操作数地址的个数 **。**

`OP`：定长操作码当`IR = 32b,OP = 8b`

`AD`：地址码应该指出操作数的地址、运算结果需存放的地址、下一条指令的地址。可以使主存地址、寄存器地址、甚至可以使IO设备地址。

1. 零地址：控制令、停机、关中断、堆栈计算机中的零地址运算类指令

定长指令字机器：机器中的所有指令都一样字长，规整型指令。大多是`32b`指令字。

不定常指令字机器：指令有长短，但每条指令的长度一般都是8的倍数。

定长操作码指令格式：指令字的最高位部分分配固定的若干位为操作码。

不定长操作码指令格式：不允许较短的操作码是较长的操作码的前缀赫夫曼树；通常情况下，对使用频率较高的指令，分配较短的操作码

## 指令寻址方式

![https://www.yuque.com/api/services/graph/generate_redirect/latex?(PC)%2B1%20%5Cto%20PC](编码系统+c156333b-96de-414f-877f-607979f881af/latex 4)

跳跃寻址：立即寻址，相对寻址，间接寻址

## 数据寻址方式

![https://www.yuque.com/api/services/graph/generate_redirect/latex?(EA)](编码系统+c156333b-96de-414f-877f-607979f881af/latex 5)

1. **立即数**：指令直接给出操作数，用**补码**表示。寻址方式通常用#表示，其他的寻址方式不用特殊符号表示，立即数，通常用于对某寄存器或内存单元赋初值

2. **隐含寻址**：最典型的例子是一地址格式的加法指令，ADD仅给出一个操作码，另一个在ACC中，缩短指令字长

IO指令

是机器指令的一类，其指令格式和其他指令既有相似又有不同。必须反映出多台IO设备之间的选择。操作码字段可以作为IO指令和其他指令的判别代码，命令码体现IO设备的具体操作，设备码是多台IO设备的选择码（地址码）。

## 中断隐指令

中断隐指令不属于系统指令，它是CPU在中断周期内由硬件自动完成的一条指令。

1. *开中断指令*将`EINT`置1

2. *关中断指令*将`EINT`置0。

## 指令集



**指令集架构**是对 CPU 硬件的抽象，使用这个抽象，CPU 看起来好像一次只执行机器代码程序的一条指令，实际上底层硬件并行地执行多条指令。

**虚拟机**是对整个计算机系统的抽象，包括操作系统、处理器和程序。

![](/res/abstract.png)

CISC 复杂指令集，RISC 是精简指令集。

CISC（Complex Instruction Set Computer）：复杂指令系统计算机

1. 指令系统复杂庞大，指令长度不固定，指令格式多，寻址方式多。
2. 可以访存的指令不受限制，各种指令使用的相差频度大，执行时间相差大。
3. 采用微程序控制，难以用优化编译生成高效的目标代码程序。

RISC（Reduced Instruction Set Computer）：精简指令系统计算机

1. 选取使用频率最高的一些简单指令，复杂指令由简单指令构成
2. 指令长度固定，指令格式种类少，寻址方式种类少
3. 只有取数存数指令访存
4. CPU 中通用寄存器数量多
5. 采用流水线
6. 硬布线 特别注意编译优化

`CISC`：除了寄存器少之外，其余特点均与多、大、不固定有关

`RISC`：一定采用流水线

|                                                                  | CISC（复杂指令集计算机）                           | RISC（简单指令集计算机）                                                                                                         |
| ---------------------------------------------------------------- | -------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------- |
| 指令系统指令数寻址方式可访存指令各种指令使用频率各种指令执行时间 | 复杂,庞大一般大于200不固定不加限制相差很大相差很大 | 简单,精简一般小于100固定32位只有LOAD/STORE指令相差不大绝大多数在一个机器周期完成                                                 |
| 优化编译实现                                                     | 很难                                               | 较容易                                                                                                                           |
| 程序源代码长度                                                   | 较短                                               | 较长                                                                                                                             |
| 控制逻辑实现方式                                                 | 绝大多数为微程序控制                               | 绝大多数为硬连线控制，应用流水线技术                                                                                             |
|                                                                  |                                                    | RISC机的主要优点可归纳如下(1)充分利用VLSI芯片的面积(2)提高了计算机运行速度(3)便于设计,降低成本,提高可靠性(4)有效支持高级语言程序 |

```Rust
//非访存
CLA 0->ACC
COM !ACC->ACC
SHR ACC>>1
CSL R(ACC)->L(ACC),ACC0->ACCn
STP 0->G
//访存
ADD Ad(IR)->MAR,1->R;M(MAR)->MDR;(ACC)+(MDR)->ACC
STA Ad(IR)->MAR,1->W;(ACC)->MDR;(MDR)->M(MAR)
LDA Ad(IR)->MAR,1->R;M(MAR)->MDR;(MDR)->ACC
// 转移
JMP Ad(IR)->PC
BAN A0*Ad(IR)+!A0*(PC)->PC
```
