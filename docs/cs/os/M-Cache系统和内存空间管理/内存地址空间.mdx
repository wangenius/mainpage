
:::success 备注
多道程序设计进行有效的内存管理，不仅方便用户使用存储器，提高内存利用率，通过虚拟技术从逻辑上扩充存储器。操作系统的内存管理模块负责逻辑地址和物理地址的转换，因此该部分需要紧密结合
:::

## 地址空间

主存中的每个字节都由一个整数物理地址所指定，物理地址的集合叫做*物理地址空间*。它的范围通常为0到`N-1`，其中`N`是主存的大小。

许多操作系统提供虚拟内存，也就是说程序永远不需要处理物理地址，也不需要知道有多少物理内存是有效的。作为代替，*程序处理虚拟地址*，它被编码为从0到`M-1`，其中`M`是有效虚拟地址的大小。虚拟地址空间的大小取决于所处的操作系统和硬件。

Q：为什么32位操作系统给进程分配的是4G的虚拟地址空间？A：32位操作系统一共有32根地址线，每个地址线能模拟的数字位0/1。

### 虚拟内存

传统：一次性和驻留性，

虚拟内存：多次性对换性虚拟性

局部性原理：块表、页高速缓存及虚拟内存技术使用高速缓存技术，高速缓存技术依赖局部性原理

1. 空间局部性、时间局部性

2. 虚拟内存技术建立了内存-外存两极存储结构，利用局部性原理实现高速缓存

虚拟内存的实现

1. 一定容量的内存和外存

2. 页表机制，离散分配

3. 中断机构：缺页内部异常，缺页进程阻塞，调页完成唤醒。

4. 地址变换机构（需要硬件支持）

容量：**虚拟存储器的容量（地址空间）由计算机地址总线的数量来决定**。虚拟存储器的页表是虚地址到内存地址或者外存地址的映射。通过页表项的`status`位来决定。缺页中断将外存中的块置入内存。

虚存实际容量由CPU地址长度和外存容量决定。一般情况下CPU的地址长度能表示的大小都大于外存容量。

1. 当CPU的地址长度能表示的大小远远大于外存容量时，虚存的实际容量为内存和外存容量之和

2. 当外存容量远大于CPU字长能表示的大小时，虚存的实际容量由CPU字长决定



机器级程序将内存视为一个庞大的字节数组，称为**虚拟内存**。

内存的每个字节由地址来标识，所有可能地址的集合就是**虚拟地址空间。**

虚拟内存使每个进程都以为自己独占了主存。每个进程看到的内存都是**一致的**，即**虚拟地址空间**。

在linux中，每个进程看到的虚拟地址空间由以下几个部分组成：

1.  **程序代码和数据**
2.  **堆（运行时堆）**
3.  **共享库**
4.  **栈（用户栈）**
5.  **内核虚拟内存**

地址从低到高，最高层的**内核虚拟内存**保存的是操作系统中的代码和数据，这部分每个进程都一样。



**程序代码和数据**

对所有进程来说，代码都是从同一个固定地址开始，紧接着是与全局变量对应的数据区。代码和数据区都是按照可执行文件的内容初始化的。代码和数据区在进程开始运行时就被指定了大小。

**堆**

而运行时堆是根据 malloc 和 free 函数的调用在运行时**动态地**扩展和收缩的。

**共享库**

地址空间的中间部分用来存放共享库的代码和数据。如 C 标准库、数学库等都属于共享库

**栈**

用户栈和堆一样，在程序执行期间可以**动态的扩展和收缩**，编译器用它来**实现函数调用**。当调用函数时，栈增长，从函数返回时，栈收缩

### 地址翻译

**地址变换机构是内存管理单元**`MMU`**中将逻辑地址映射为内存中物理地址的硬件系统。大多数处理器提供了内存管理单元**`MMU`**，位于CPU和主存之间。**`MMU`**在**`VA`**和**`PA`**之间执行快速的翻译。**

逻辑地址`logical address`是程序产生的与段相关的偏移地址部分。源代码经过complie编译：生成可执行代码，产生若干代码块Object Module后，目标程序所用的地址就是逻辑地址。逻辑地址的范围叫逻辑地址空间。物理地址`physical address`在CPU外部地址总线上的寻址物理内存的地址信号。物理地址用户透明，转换过程硬件自动完成，转换过程叫做地址重定位。

**当cache作用时：**

逻辑地址是由程序员给出的。经过查询快表页表得到物理地址。但此时的物理地址并不一定是最终地址，因为如果cache命中则需要再转换成cache地址。转换后的开始中的地址才是最终地址。但如果开始不命中，则仍需要按原来经过代表或者业表得到的地址去直接访存。得到物理地址（内存地址）后，先访问cache，如果命中，转换成cache地址访问，如果没命中，则进行访存。

