- 系统内核（Kernel）

    其实也是一组程序，这组程序重点在于管理计算机的所有活动以及驱动系统中的所有硬件

    比如，你的内核不支持 TCP/IP 协议，那么无论你购买什么网卡都不能支持上网。

    

- 系统调用（System Call）

    所有的硬件由内核管理，那么开发程序就由参考硬件函数变为参考内核功能， 所以操作系统通常都会提供一整组开发接口给工程师使用。

    那么操作系统的角色就分为以下几个：

    1. 硬件

    2. 内核：主要管理硬件，提供合理的计算机系统资源分配（CPU、内存使用资源等）

    3. 系统调用

    4. 应用程序

    操作系统就是内核和系统调用

    为了保护内核，提供了一整组开发接口，这就是系统调用层。

- 操作系统的内核层直接参考硬件规格写成，所以同一个操作系统程序不能够在不一样的硬件架构下运行

- 操作系统只是在管理整个硬件资源：所以需要各种应用程序来驱动它工作

- 应用程序的开发都是参考操作系统提供的接口，所以不能夸操作系统：如 win 上的程序不能再 linux 上运行

- 内核功能

    内核主要负责计算机系统相关的资源分配与管理，最重要的就是 CPU 与内存了，所以至少有以下几个功能：

    - 系统调用接口（System call interface）

    - 程序管理（Process control）

        如多任务环境下，需要管理 CPU 什么时候执行哪个任务的指令

    - 内存管理（Memory management）

        内存很重要，当内存不足时，内核一般都会提供虚拟内存的功能，使用内存交换（Swap）功能

    - 文件系统（Filesystem management）

        例如数据的输入输出（I/O）等工作

    - 设备驱动（Device driver）

        硬件的管理是内核主要工作之一，驱动程序就是需要做的事情，现在有可加载模块功能， 可以将驱动程序编写成模块，就不需要重新编译内核了（后面会讲到）

# 运行环境

刚开机是内核态，然后操作系统主动让出`cpu`使用权

1. 内核态→用户态：中断返回指令

2. 用户态→内核态：中断引发，硬件自动完成变态功能，操作系统将重新夺回CPU使用权。用户堆栈切换为系统堆栈，这个系统堆栈也是属于该进程的。

    3. 系统调用：中断来实现

    4. 异常：缺页等

    5. IO设备中断

6. 内核包括：时钟管理`CLK`，中断机制`INT`，原语`Atomic Operation`，系统控制的状态信息的数据结构（`JCB`、`PCB`、`DCB`、链表、消息队列、缓冲区、空闲区登记表、内存分配表等）



    特权指令：仅允许内核使用。

        1. **IO设备**启动、测试、控制指令

        2. 访问程序状态`PSW`指令

        3. 存取特殊寄存器指令:**中断寄存器、时钟寄存器**

        4. **原语**:进程控制用的程序段，执行期间不允许中断，它是一个不可分割的基本单位。通过关中断指令和开中断指令实现原语的原子性，执行期间不会被中断。



# 中断

让操作系统夺回CPU使用权的唯一途径，没有中断就没有并发，没有操作系统，中断处理程序一定是内核程序，不可屏蔽中断和内部异常在关中断模式下也会被响应。机制：中断处理程序一定是内核程序

1. 内中断（异常）：和当前执行的指令有关，来自**主机**内部。地址非法校验错误非法指令

2. 

    3. 陷入`trap`软中断：程序想要内核服务，主动将CPU控制权还给内核，系统调用通过陷入指令完成

    4. 故障`fault`缺页中断：错误条件引起，内核可修复，会返回控制权，故障处理后返回当前指令

    5. 终止`abort`：硬件致命错误引起，内核无法修复，不会返回控制权除数为零自行中断

6. 外中断：外中断可以发生在用户态。中断的断点是下一条指令的地址，和异常的断点不同。

7. 

    8. 时钟中断：由时钟部件发来的中断信号，实现程序并发运行

    9. IO中断：由输入输出设备发来中断信号

指令中断和缺页中断的区别？

1. 指令中断周期结束后执行下一条指令

2. 缺页中断结束后访问当前页

3. 中断源：发出中断请求的IO设备。

4. 设备编码器（中断向量地址形成部件）：IO设备一但响应了IO中断，就要暂停现行程序，转去执行该设备的中断服务程序。不同设备有不同的中断服务程序，每个服务程序都有一个入口地址，CPU必须找到这个入口地址。

5. 中断服务程序：每个中断源都有对应的处理程序。

6. 中断向量：中断服务程序的入口地址称为中断向量。

7. 中断向量表：所有中断向量构成一个表。

8. 中断向量地址：中断向量表每个表项所在的内存地址或表项的索引值，称为向量地址或中断类型号。每个中断都有唯一的类型号。

9. 中断请求标记触发器`INTR`中断源向CPU提出中断请求：`INTR = 1`中断源有请求。`INTR`可屏蔽中断，`NMI`不可屏蔽中断。

10. 中断触发器`EINT`CPU响应中断条件：开中断指令置1，关中断指令置0，屏蔽可屏蔽中断。

11. 屏蔽字触发器`MASK`：每个中断源一个`MASK`，1表示屏蔽该中断请求，所有触发器组成屏蔽字寄存器。

## 中断判优

1. 硬件向量法软件实现（按优先级查询各中断源是否有中断请求，转向中断服务程序入口地址）：CPU响应中断时，利用硬件产生向量地址，再由向量地址找到中断服务程序入口地址。

2. 

    3. CPU响应中断，只要将向量地址送至PC，执行这条指令，便可无条件地转向某服务程序的入口

    4. 向量地址表

5. 响应优先级和处理优先级

6. 

    7. 无屏蔽技术条件下，CPU理论上执行中断的顺序

    8. 在屏蔽技术的加持下`MASK`，CPU实际执行中断的顺序

## 中断过程

中断隐指令不属于系统指令，它是CPU在中断周期内由硬件自动完成的一条指令。

1. 中断源发出中断请求，`INTR = 1`

2. 中断响应判优

3. CPU响应中断：当`EINT=1`时，在指令执行周期结束后，查询中断。硬件引导中断服务程序。

4. 

    5. 关中断指令

    6. 保存断点

    7. 中断服务程序寻址：识别中断源获得中断类型号

8. 中断程序

9. 

    10. 保存现场和`MASK`

    11. 开中断指令

    12. 执行中断服务程序

    13. 关中断指令

    14. 恢复现场和`MASK`

    15. 开中断指令

    16. 中断返回

中断程序执行过程中，新的中断请求？

1. 不理，关中断

2. 中断嵌套：提前设置开中断指令，新的优先级要高。

3. 屏蔽技术

