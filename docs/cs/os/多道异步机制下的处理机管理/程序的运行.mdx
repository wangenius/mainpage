---
title : 程序的运行
sidebar_position : 1
slug : 程序的运行
---
# 程序的运行

## 程序装入

:::success 例子
我们用下面这个程序来举例:
```cpp title="main.cpp"
#include <iostream>
#include "name.h"

int main(){
    std::cout << name() << std::endl; 
    return 0;
}
```
```cpp title="name.h"
#include <string>
string name(){
    return "wangenius";
}
```
:::

1. 编译：生成可执行代码，产生若干代码块`Object Module`. 具体查看编译原理部分.
2. 链接：目标代码块链接形成完整的装入模块`Load Module`
    1. 静态链接：运行前连接成一个完整的`exe`文件
    2. 装入时动态链接：边装入边链接
    3. 运行时动态链接：对某些目标模块链接，需要才链接，便于修改、更新、共享。与虚拟内存相关。
3. 装入：将装入模块装入内存 ，地址重定位的过程。
    1. 绝对装入：`compile`时绝对定位，不适用于批处理操作系统
    2. 静态重定位：`load`时进行定位，在装入时一次性完成地址变换，必须分配要求的全部内存空间，不能移动，适用于分区分配。不需要`MMU`。
    3. 动态重定位：`execute`时重定位，内存中的所有地址都是相对地址，可以将程序分配到不连续的存储区中，适用于分页,分段分配内存。需要附加硬件重定位寄存器的支持。

## 程序以进程的形态运行

进程是进程实体的**动态**（最基本的特征）运行过程，进程是能**独立**运行、独立获得资源（进程是资源分配，拥有资源的基本单位）、独立接受调度（通常使用线程完成）的基本单位



**进程：**对操作系统正在运行的程序的一种抽象。

**并发运行：**一个进程的指令和另一个进程的指令是交错执行的。

一个系统可以同时运行多个进程，实际上这些进程是并发运行的。

操作系统通过**上下文切换**来实现并发运行。上下文是跟踪进程运行所需的所有**状态信息**，可能存在于PC、寄存器文件、主存等地方。

**任何时刻，单处理器只能执行一个进程的代码。**

操作系统**内核**是操作系统代码常驻主存的部分，从一个进程到另一个进程的转换是由内核管理的。

内核不是一个独立的进程，是一系列代码和数据结构的集合。

当应用程序需要操作系统的某些操作时，就把控制权传递给内核，内核执行完操作后返回应用程序。



一个进程可以创建若干新进程，为了描述进程之间的创建关系，引入进程前趋图（进程树或进程家族树）。

**PCB**：进程存在的唯一标志，标识符(PID，UID...)，分配资源信息(内存，IO，文件)，控制和管理信息(当前状态、优先级、代码运行入口地址、外存地址、信号量使用、CPU使用时间，磁盘使用情况，网络流量使用情况等)，处理机相关信息（CPU上下文、中断现场，通用寄存器值、地址寄存器值、控制寄存器值、标志寄存器值等）的数据结构，称作进程控制块。系统通过PCB对进程进行控制

`idle`：优先级最低，不需要CPU之外的资源，不会被阻塞

### 上下文

切换CPU到另一个进程，需要保存当前进程状态，并恢复另一个进程的状态。上下文是指某一时刻，CPU寄存器和程序计数器的内容。他需要相当可观的CPU时间。有的处理器提供多个寄存器组，这样上下文切换就只需要改变当前寄存器组的指针。模式切换是指用户态和内核态的切换。

进程切换一定会进行上下文切换，产生中断，进行处理器模式切换，从用户态进入内核态再返回用户态；但是处理器模式的切换不一定产生进程的切换，系统调用同样会产生处理器模式的切换，但在逻辑上仍然是同一进程。

程序执行时的一个实例，资源分配的独立单位，拥有独立的地址空间。

多道程序环境下多个程序并发执行。他们失去了封闭性，并具有间接性和不可再现性的特征。为了保证程序在并发执行的过程中实现可再现性和封闭性的要求，引入进程的概念，实现操作系统的并发性和共享性。

为了保证程序在并发执行的过程中实现可再现性和封闭性的要求，引入进程的概念，实现操作系统的并发性和共享性。进程是进程映像的运行过程，进程是能独立运行、独立获得资源（进程是资源分配，拥有资源的基本单位）、独立接受调度（通常使用线程完成）的基本单位。

一个进程实体（进程映像）由PCB、程序段、数据段组成的静态映像。

## 线程

减小程序在并发执行时所付出的时空开销，提高操作系统的并发性能。基本的CPU执行单元，是程序执行流的最小单元。

1. 线程是基本的CPU执行单元，是程序执行流的最小单元，由线程ID，程序计数器PC，寄存器集合以及堆栈组成。

2. 提升了并发度。对于单线程进程，只能运行在一个处理机上，对于多线程进程可以将进程中的多个线程分配到多个处理机上执行；

3. 调度不需要进行CPU上下文切换，时空开销小，引入线程的操作系统中，线程是独立调度的基本单位。

4. 进程并发需要切换进程的运行环境，系统开销很大，线程间并发，如果是同一进程内的线程切换，则不需要切换进程环境，系统开销小。

5. 线程无法拥有资源，进程是拥有资源的基本单位，同一个进程的所有线程共享该进程的所有资源。

TCB：标识符、寄存器组`(PC,PSW,Xs)`、运行状态、优先级、线程专有存储区、堆栈指针（用于过程调用时保存局部变量和返回地址）

**KLT：**操作系统内核空间管理线程。**可以发挥多处理机内核的优势**，同时调度同一进程中的多个线程并行运行。一个内核级线程由于IO操作阻塞时，**不会影响其他线程的运行**。处理器**分配时间片的对象是线程**，所以有多个线程的进程将会获得更多的处理器时间。线程切换开销小，但是系统开销大，一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到内核态，线程管理成本高，开销大

**ULT：**效率高，用户级代码级线程，由用户实现，与OS无关，线程阻塞则进程阻塞，不能发挥多处理机的优势。内核也并不知道它的存在，所以所有对用户级线程的管理和调度都是在用户空间来进行的。不仅无需通过中断进入操作系统的内核，而且切换的规程也远比进程调度和切换的规则来得简单，用户级线程的切换速度特别快。但是一个用户级线程若执行了阻塞系统调用就会导致该线程所属的进程阻塞。此时如果采用的是内核级线程，则调度室以线程为单位。当一个线程调用一个系统调用时，内核把系统调用只看做是该线程的行为，因而封锁该线程，于是可以再调度该进程中的其他线程执行。

组合模型

1. 多对一模型：线程管理在用户空间进行，因而效率比较高

2. 一对一模型：并发能力强，每创建一个线程，相应地就需要创建一个内核线程，管理开销大

3. 多对多模型：以上两个模型的优点，用户线程大于内核线程

[https://zhuanlan.zhihu.com/p/670803961](https://zhuanlan.zhihu.com/p/670803961)





## 关于进程和线程概念的区别和理解
> 自己做了一个模型用于理解
:::info 定义
作业：上小学，成为一个合格的小学毕业生
进程PCB：老师
进程1：语文老师代课，学语文和美术
1. 语文
2. 美术

进程2：数学老师代课，学数学和科学
1. 数学
2. 科学

进程3：另一个数学老师代课，学奥数

进程4：品德老师代课，学品德

操作系统：学校

CPU：你

寄存器资源：黑板

其他上下文：正在的老师不需要上课老师

其他资源：多媒体，书柜，储藏空间等等

os给进程（内核级线程）分配的时间片：课时

os用于上下文切换时的系统开销：课间，比如上一课老师要离开，下一课老师进入，擦黑板等等

进程：同一老师（PCB）任课。进程为多道程序并发执行诞生（你在上小学期间同时学语文，数学，奥数班）。
:::

### 基本概念的解读
提高CPU（你）的利用率：利用CPU（你）空闲（课后玩耍）的时间上奥数班。

进程2（数学）和进程3（奥数）是同步关系。进程3需要进程2的部分结果（基础数学知识）才能执行，否则阻塞。

进程1（语文）和进程2（数学）可能是互斥关系（语文老师上完语文课没有归还多媒体钥匙，下节数学老师就不能使用多媒体，直到语文老师归还）。

进程间切换要换cpu的工作环境（你需要擦黑板，换老师，上厕所）

进程是拥有资源的基本单位（黑板，多媒体等跟随进程（科目）变化而变化）

PCB是进程存在的唯一标识（老师不在就不能上该课）

### 内核级线程：独立的课程

对于同一个进程（同一个老师代课，拿语文老师为例），语文和美术是两个科目，进程（老师）向os（学校）申请了独立的语文课程和美术课程（内核级线程）。

调度：os（学校）内核划分为了若干课时（时间片）用于调度，分配对象是内核级线程（在支持内核级线程的os中，进程不作为调度的具体对象，即进程在os的调度中是看做内核级线程对待的），因此有多个内核级线程的进程获得更多的时间片（比如语文老师进程有5节语文，2节美术，数学老师进程有5节数学，显然，语文老师获得更多的时间片）。

时间开销：使用时间片（课时）作为调度切换的单位，所以内核级线程需要系统开销（课间）的。

多线程共享一个进程资源：多媒体钥匙都在语文老师手里，即美术课也可以用多媒体。

内核级线程的阻塞不会影响其他线程：第一节是语文课，这节语文课并没有把备课内容讲完，但不影响下一节美术课的进度[^1]。

内核线程切换的几种情况：

上下两节课老师没变（第一节语文，第二节美术）：进程没发生切换而线程发生切换，老师不需要换，只需要擦黑板就行。系统开销比进程间切换小。
上下两节课老师变了（第一节语文，第二节数学）：进程间的线程发生切换，老师也要换（比如可能迟到？），所以开销很大
用户级线程
数学老师任课有很多任务，微积分（用户级线程），线代（用户级线程），概率论（用户级线程），计算机（用户级线程）等。[^2] 这些任务在数学老师申请的数学课和科学课（内核级线程）中完成。

用户级线程的阻塞会导致整个（内核级）线程等待：如果数学老师上节数学课有遗留问题没弄完，这节课无法开新内容。

### 硬件线程
KLT和ULT属于软件线程，是在os层级以上的。硬件线程：有两个或多个完整的寄存器集，允许它代表两个或多个进程（内核级线程）执行指令。

牵强的比喻：原来只有一块黑板（上下文寄存器集），变成了教室前和教室后两块，下一节课可以保留上一节课的黑板内容，因此在进程（内核线程）切换的过程中，减少了恢复上下文的操作（擦黑板等）。

### 其他
从上文便能更好的理解软件线程中的三种模型了。

多对一模型：品德老师只讲品德课，品德课（内核级线程）所讲内容包括\{思想道德，法律\}
一对一模型：语文老师讲语文课和美术课。语文课（内核级线程）讲课文（唯一用户级线程），美术课（内核级线程）上画画（唯一用户级线程）
多对多模型：数学老师讲数学课和科学课。数学课（内核级线程）包括\{微积分，线代，概率论\}，科学课（内核级线程）包括\{计算机，生命科学...\}
综上，线程是一个比进程小的执行单元（相对独立的控制流序列，可以单独执行）。单论不加定语的线程，我更愿意理解为是一种相对概念，一个线程之内还可能有多代线程嵌套。

仅供理解，如有问题请指教

[^1]: 当然是理论上，有些老师可能霸占美术课
[^2]: 小学学这些不过分吧