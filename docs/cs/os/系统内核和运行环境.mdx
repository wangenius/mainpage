---
title : 系统内核和运行环境
sidebar_position : 3
slug : 系统内核和运行环境
---
# 系统内核和运行环境


## 操作系统内核
1. 系统内核(Kernel):其实也是一组程序，这组程序重点在于管理计算机的所有活动以及驱动系统中的所有硬件. 比如，你的内核不支持 TCP/IP 协议，那么无论你购买什么网卡都不能支持上网。
2. 系统调用（System Call）:所有的硬件由内核管理，那么开发程序就由参考硬件函数变为参考内核功能， 所以操作系统通常都会提供一整组开发接口给工程师使用。
    那么操作系统的角色就分为以下几个：
    1. 硬件
    2. 内核：主要管理硬件，提供合理的计算机系统资源分配（CPU、内存使用资源等）
    3. 系统调用
    4. 应用程序
    操作系统就是内核和系统调用
    为了保护内核，提供了一整组开发接口，这就是系统调用层。

- 操作系统的内核层直接参考硬件规格写成，所以同一个操作系统程序不能够在不一样的硬件架构下运行

- 操作系统只是在管理整个硬件资源：所以需要各种应用程序来驱动它工作

- 应用程序的开发都是参考操作系统提供的接口，所以不能夸操作系统：如 win 上的程序不能再 linux 上运行

- 内核功能

    内核主要负责计算机系统相关的资源分配与管理，最重要的就是 CPU 与内存了，所以至少有以下几个功能：

    - 系统调用接口（System call interface）

    - 程序管理（Process control）

        如多任务环境下，需要管理 CPU 什么时候执行哪个任务的指令

    - 内存管理（Memory management）

        内存很重要，当内存不足时，内核一般都会提供虚拟内存的功能，使用内存交换（Swap）功能

    - 文件系统（Filesystem management）

        例如数据的输入输出（I/O）等工作

    - 设备驱动（Device driver）

        硬件的管理是内核主要工作之一，驱动程序就是需要做的事情，现在有可加载模块功能， 可以将驱动程序编写成模块，就不需要重新编译内核了（后面会讲到）

### 内核结构 
1. 分层结构。便于调试和验证，扩充和维护。效率低，不能跨层调用，系统调用执行时间长。

2. 模块化。模块之间逻辑清晰，易于维护，多模块可以同时开发。支持动态加载新的内核模块，比如设备驱动程序文件、系统模块到内核，增强os适用性。任何模块都可以直接调用其他模块，无需进行消息传递通信，效率高。模块接口定义不一定合理。模块间相互依赖，不利于调试和验证。

3. 宏内核。性能高，内核内部功能可以相互调用。庞大功能复杂难维护。内核中一个功能模块出错，可能导致整个系统崩溃。

4. 微内核。内核小功能少易维护可靠。内核外的某个功能模块出错不会导致系统崩溃。性能低，需要频繁切换用户态和核心态。用户态下的功能模块不可以直接相互调用，只能通过内核的消息传递来间接通信。

5. 外核。外核可以直接给用户进程分配实体具象的硬件资源。进程可以更灵活的使用硬件资源。减少了虚拟硬件资源的映射层，提高效率。降低了系统的一致性，使系统变得复杂。


## 运行环境

刚开机是内核态，然后操作系统主动让出`cpu`使用权

1. 内核态→用户态：中断返回指令

2. 用户态→内核态：中断引发，硬件自动完成变态功能，操作系统将重新夺回CPU使用权。用户堆栈切换为系统堆栈，这个系统堆栈也是属于该进程的。

    3. 系统调用：中断来实现

    4. 异常：缺页等

    5. IO设备中断

6. 内核包括：时钟管理`CLK`，中断机制`INT`，原语`Atomic Operation`，系统控制的状态信息的数据结构（`JCB`、`PCB`、`DCB`、链表、消息队列、缓冲区、空闲区登记表、内存分配表等）



    特权指令：仅允许内核使用。

        1. **IO设备**启动、测试、控制指令

        2. 访问程序状态`PSW`指令

        3. 存取特殊寄存器指令:**中断寄存器、时钟寄存器**

        4. **原语**:进程控制用的程序段，执行期间不允许中断，它是一个不可分割的基本单位。通过关中断指令和开中断指令实现原语的原子性，执行期间不会被中断。



