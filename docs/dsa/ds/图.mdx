---
sidebar_position : 4
title : 图
slug : 图
---

# 图

# 存储结构

邻接表`Node`要链接`first_edge`,`Edge`要链接`next_edge`,`A_node`,`B_node`.

邻接多重表在邻接表的基础上`Edge`的`next_edge`有两个,`A_next`,`B_next`,`A_node`,`B_node`.

十字链表在邻接多重表的基础上,`Node`有两种`out_first`,`in_first`

邻接矩阵和邻接表，是多对多的关系，分为有向图和无向图。


:::success 邻接矩阵和邻接表的对比
邻接矩阵表示法：在一个一维数组中存储所有的点，在一个二维数组中存储顶点之间的边的权值

邻接表表示法：图中顶点用一个一维数组存储，图中每个顶点vi的所有邻接点构成单链表

对比

1）在邻接矩阵表示中，无向图的邻接矩阵是对称的。矩阵中第 i 行或 第 i 列有效元素个数之和就是顶点的度。

在有向图中 第 i 行有效元素个数之和是顶点的出度，第 i 列有效元素个数之和是顶点的入度。

2）在邻接表的表示中，无向图的同一条边在邻接表中存储的两次。如果想要知道顶点的度，只需要求出所对应链表的结点个数即可。

有向图中每条边在邻接表中只出现一次，求顶点的出度只需要遍历所对应链表即可。求入度则需要遍历其他顶点的链表。

3）邻接矩阵与邻接表优缺点：

邻接矩阵的优点是可以快速判断两个顶点之间是否存在边，可以快速添加边或者删除边。而其缺点是如果顶点之间的边比较少，会比较浪费空间。因为是一个 n∗n 的矩阵。

而邻接表的优点是节省空间，只存储实际存在的边。其缺点是关注顶点的度时，就可能需要遍历一个链表。
:::

```Rust
typedef struct {
    Info info;
}Node;
typedef struct {
    Node node[maxSize];
    int edges[maxSize][maxSize];//带权图 float 使用\infin代表不存在边
    int nodes,edges;
}Graph;
//无权图:1有边,0无边,自身0
//有权图:∞无边,权值有边,自身0
```


```Rust
typedef int Info;
typedef struct Edge{
    Info info;//weight or something else
    int from_node,to_node;
    struct Edge next;
}Edge;

typedef struct Node{
    Info info;
    Edge first;
}Node;

typedef struct Graph{
    struct info{
        int node_num,edge_num;
    }
    Node node[maxSize];

}Graph;
```


```Rust
//无向图的一种链式存储结构
typedef struct Edge{
	char info;
	Node *A, *B;
	Edge *A_next,*B_next;
}Edge;
typedef struct Node{
	char data;
	Edge *first;
}Node;
typedef struct Graph{
    Node node[maxSize];
    int nodes,edges;
}Graph;
```


```Rust
//有向图的一种链式存储结构
typedef struct Edge{
	char info;
	Node *from,*to;
	Edge *from_next,*to_next;
}
typedef struct Node{
	char data;
	Edge *out_first,*in_first;
}
typedef struct Graph{
    Node node[maxSize];
    int nodes,edges;
}Graph;
```


# 遍历

## 深度优先DFS

```Rust
bool visited[maxSize];//访问标记
Edge edge;//边指针

// 非连通图循环访问
void traverse(Graph &G){
    for(int i=0;i<G.info.node_num;++i)
        if(visit[i]==0)
            DFS(G,i);
}
//递归算法
void DFS(Graph &G, int id){
    //访问
    visit[id] = 1;
    edge = G.node[id].first;
    while(edge){
        if(visit[edge.to_node]==0) DFS(G,edge.to_node);
        edge=edge.next;
    }
}
```


## 广度优先BFS

```Rust
bool visited[MAXSIZE];//访问标记
int Q[MAXSIZE],front=0,rear=0;
Edge edge;

void enQue(int v){
    rear=(rear + 1) % MAXSIZE;
    Q[rear]=v;
}

void deQue(int &v){
    front=(front+1) % maxSize;
    v=Q[front];
}

void isEmpty(){
    return front==rear?1:0
        }

void visit(int v){
    visited[v] = TRUE;
}

// 非连通图循环访问
void traverse(Graph &G){
    for(int i = 0;i<G.info.node_num;++i)
        if(visit[i]==0) BFS(g,i)
            }

void BFS（Graph &G,int id){
    //访问
    visit(id);
    //入队
    enQue(id);
    //循环遍历
    while(!isEmpty()){
        deQue(v);
        edge=G.nodes[id].first;
        while(edge){
            if(!visited[edge.to_node]){
                visit(edge.to_node);
                enQue(edge.to_node);
            }
            edge=edge.next;
        }
    }
}
```


# 最小生成树`MST`

一个带权连通无向图的生成树中边的权值之和最小的那个叫做图的最小生成树`MST`

## 普里姆算法`Prim`

无向图稠密图

正面战场

![https://cdn.nlark.com/yuque/__latex/788a6a1c2e659004f53073bd49e60ef0.svg](https://cdn.nlark.com/yuque/__latex/788a6a1c2e659004f53073bd49e60ef0.svg)

```Rust
vset[node_num];顶点已经并入生成树
lowcost[node_num];当前生成树到剩余各顶点最短边的权值
```


## 克鲁斯卡尔算法`Kruskal`

稀疏图并查集

每次查找**并查集**找出候选边中权值最小的边，并入生成树

:::success 最小生成树算法的比较
最小生成树： 最小生成树来自于无向网。 无向图在边上加上权值就成了无向网。 一个无向图可以有多种不同姿态连接的生成树。 最小生成树就是–各边上权值之和最小的生成树。

普里姆算法(Prim)和克鲁斯卡尔(Kruskal)算法

普里姆算法的基本思想:（简单的说就是一直加点） 取图中任意一个顶点 v 作为生成树的根，之后往生成树上添加新的顶点 w。添加顶点w的条件为：w 和已在生成树上的顶点v 之间必定存在一条边，并且该边的权值在所有连通顶点 v 和 w 之间的边中取值最小。之后继续往生成树上添加顶点，直至生成树上含有 n-1 个顶点为止。

克鲁斯卡尔算法的基本思想：（简单的说就是找不围成圈的最小的边）

考虑问题的出发点: 为使生成树上边的权值之和达到最小，则应使生成树中每一条边的权值尽可能地小。

具体做法: 先构造一个只含 n 个顶点的子图 SG，然后从权值最小的边开始，若它的添加不使SG 中产生回路，则在 SG 上加上这条边，如此重复，直至加上 n-1 条边为止。
:::

当带权连通图的任意一个环中所包含的权值均不相同时最小生成树唯一



## 深度优先和广度优先算法的对比

深度优先搜索(回溯法) 算法思路 深度优先搜索(DFS,Depth-First Search)是搜索的手段之一 它从某个状态开始,不断地转移状态直到无法转移,然后回退到前一步状态,继续转移到其他状态,如此不断重复,直到找到最终的解.根据深度优先搜索的特点,采用递归函数(隐式地利用了栈进行计算)实现比较简单.

算法效率 深度优先搜索从最开始的状态出发,遍历所有可以到达的状态.由此可以对所有的状态进行操作,或列举出所有的状态.作为搜索算法的一种,DFS对于寻找一个解的NP(包括NPC)问题作用很大.

但是,搜索算法毕竟是时间复杂度是O(n!)的阶乘级算法，它的效率比较低,在数据规模变大时,这种算法就显得力不从心了.关于深度优先搜索的效率问题,有多种解决方法.最具有通用性的是**剪枝(prunning),**也就是去除没有用的搜索分支.有可行性剪枝和最优性剪枝两种.此外,对于很多问题,可以把搜索与动态规划(DP,dynamic programming)、完备匹配(匈牙利算法)等高效算法结合.

2.宽度优先搜索(分支限界法) 算法思路 宽度优先搜索(BFS,Breadth-First Search)也是搜索的手段之一.他与深度优先搜索类似,从某个状态出发搜索所有可以到达的状态.根据宽度优先搜索的特点,采用队列实现比较简单.

算法效率 与深度优先不同之处在与搜索的顺序,宽度优先搜索总是先搜索距离初始状态近的状态.也就是说,它是按照开始状态->只需1次转移就可以到达的所有状态->只需2次转移就可以到达的所有状态->…这样的顺序进行搜索.对于同一个状态,宽度优先搜索只经过一次,因此复杂度为

O(状态数*转移的方式).很容易地用来求最短路径、最少操作之类问题的答案.

广度搜索的判断重复如果直接判断十分耗时,我们一般借助哈希表来优化时间复杂度.

3.Death-Breadth总结 宽度优先搜索与深度优先搜索一样,都会生成所有能够遍历到的状态,因此需要对所有状态进行处理时使用宽度优先也是可以的.但是递归函数可以很简短地编写,而且状态的管理也更简单,所以大多数情况下还是用深度优先搜索实现.反之,在求取最短路时深度优先搜索需要反复经过同样的状态,所以还是使用宽度优先搜索比较好.

宽度优先搜索会把状态逐个加入队列,因此通常需要与状态数成正比的内存空间.反之,深度优先搜索是与最大的递归深度成正比的.一般与状态数相比,递归的深度并不会太大,所以可以认为深度优先搜索更加节省内存.

# 最短路径（有向图）

## 迪杰斯特拉算法Dijkstra

某点到其余各点的最小距离最小路径

![https://cdn.nlark.com/yuque/__latex/f2d5f588234eb61a559ff90c41511b85.svg](https://cdn.nlark.com/yuque/__latex/f2d5f588234eb61a559ff90c41511b85.svg)

组织扩充模型,挑选关系最好近的人成为新成员，关系最近的人成为新成员，新成员的关系网纳入发展对象,并更新已经是发展对象的人的关系距离。

## 弗洛伊德算法Floyd

![https://cdn.nlark.com/yuque/__latex/a77815a52a2d0050828079fb142b1410.svg](https://cdn.nlark.com/yuque/__latex/a77815a52a2d0050828079fb142b1410.svg)

```Rust
//维护A[node_num][node_num]和Path[node_num][node_num]
loop(node_num){
    A[i][j] = min(A[i][j],A[i][mid]+A[mid][j]);
    if(change)Path[i][j]=mid
        }
```
:::success Dijkstra 算法与 Prim 算法的区别
1. prim算法过程：prim算法是最小生成树算法，它运用的是贪心原理，设置两个点集合，一个集合为要求的生成树的点集合A，另一个集合为未加入生成树的点B。
     1. 所有的点都在集合B中，A集合为空。(memset(visited,0,sizeof(visited)))
     2. 任意以一个点为开始，把这个初始点加入集合A中，从集合B中减去这个点(visited[1]=1)。寻找与它相邻的点中路径最短的点，如后把这个点也加入集合A中,从集合B中减去这个点（visited[pos]=1）。 
     3. 更新未被访问的节点的dist[]值。 
     4. 重复上述过程。一直到所有的点都在A集合中结束。

2. dijkstra算法过程：
     1. 初始时，S只包含源点v，即S=v。U包含除v外的其他顶点，U中顶点u距离为边上的权（若v与u有边）或（若u不是v的出边邻接点）。 
     2. 从U中选取一个距离v最小的顶点k，把k，加入S中（该选定的距离就是v到k的最短路径长度）。
     3. 以k为新考虑的中间点，修改U中各顶点的距离；若从源点v到顶点u（u U）的距离（经过顶点k）比原来距离（不经过顶点k）短，则修改顶点u的距离值，修改后的距离值的顶点k的距离加上边上的权。 
     4. 重复步骤（2）和（3）直到所有顶点都包含在S中。

3. 小总结
    1. Prim是计算最小生成树的算法，Dijkstra是计算最短路径的算法
    2. 都是使用贪婪(一个局部最优解也是全局最优解)和线性规划(主问题包含n个子问题，而且其中有重叠的子问题。)，每一步都是选择权值/花费最小的边。 
:::

# 应用

## 拓扑排序

循环删除没有入边的点

## 关键路径

最迟发生时间是在不推迟整个工程完成的前提下的最迟必须发生时间,剩余时间=最迟发生时间-最早发生时间

