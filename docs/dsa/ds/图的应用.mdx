---
title : 图的应用
sidebar_position : 4.3
slug : 图的应用
---
# 图的应用


## 最小生成树

一个带权连通无向图的生成树中边的权值之和最小的那个叫做图的最小生成树`MST`

### 普里姆算法

`Prim`
无向图稠密图

正面战场

```cpp
vset[node_num];//顶点已经并入生成树
lowcost[node_num];//当前生成树到剩余各顶点最短边的权值
```

### 克鲁斯卡尔算法
`Kruskal`
稀疏图并查集

每次查找并查集找出候选边中权值最小的边，并入生成树

:::success 最小生成树算法的比较
最小生成树： 最小生成树来自于无向网。 无向图在边上加上权值就成了无向网。 一个无向图可以有多种不同姿态连接的生成树。 最小生成树就是–各边上权值之和最小的生成树。

普里姆算法(Prim)和克鲁斯卡尔(Kruskal)算法

普里姆算法的基本思想:（简单的说就是一直加点） 取图中任意一个顶点 v 作为生成树的根，之后往生成树上添加新的顶点 w。添加顶点w的条件为：w 和已在生成树上的顶点v 之间必定存在一条边，并且该边的权值在所有连通顶点 v 和 w 之间的边中取值最小。之后继续往生成树上添加顶点，直至生成树上含有 `n-1` 个顶点为止。

克鲁斯卡尔算法的基本思想：（简单的说就是找不围成圈的最小的边）

考虑问题的出发点: 为使生成树上边的权值之和达到最小，则应使生成树中每一条边的权值尽可能地小。

具体做法: 先构造一个只含 n 个顶点的子图 SG，然后从权值最小的边开始，若它的添加不使SG 中产生回路，则在 SG 上加上这条边，如此重复，直至加上 `n-1` 条边为止。
:::

当带权连通图的任意一个环中所包含的权值均不相同时最小生成树唯一



## 最短路径（有向图）

### 迪杰斯特拉算法
Dijkstra
某点到其余各点的最小距离最小路径

组织扩充模型,挑选关系最好近的人成为新成员，关系最近的人成为新成员，新成员的关系网纳入发展对象,并更新已经是发展对象的人的关系距离。

### 弗洛伊德算法

Floyd

```cpp
//维护A[node_num][node_num]和Path[node_num][node_num]
loop(node_num){
    A[i][j] = min(A[i][j],A[i][mid]+A[mid][j]);
    if(change)Path[i][j]=mid;
        };
```

:::success Dijkstra 算法与 Prim 算法的区别

1. prim算法过程：prim算法是最小生成树算法，它运用的是贪心原理，设置两个点集合，一个集合为要求的生成树的点集合A，另一个集合为未加入生成树的点B。

   1. 所有的点都在集合B中，A集合为空。(memset(visited,0,sizeof(visited)))
   2. 任意以一个点为开始，把这个初始点加入集合A中，从集合B中减去这个点(visited[1]=1)。寻找与它相邻的点中路径最短的点，如后把这个点也加入集合A中,从集合B中减去这个点（visited[pos]=1）。
   3. 更新未被访问的节点的dist[]值。
   4. 重复上述过程。一直到所有的点都在A集合中结束。

2. dijkstra算法过程：

   1. 初始时，S只包含源点v，即S=v。U包含除v外的其他顶点，U中顶点u距离为边上的权（若v与u有边）或（若u不是v的出边邻接点）。
   2. 从U中选取一个距离v最小的顶点k，把k，加入S中（该选定的距离就是v到k的最短路径长度）。
   3. 以k为新考虑的中间点，修改U中各顶点的距离；若从源点v到顶点u（u U）的距离（经过顶点k）比原来距离（不经过顶点k）短，则修改顶点u的距离值，修改后的距离值的顶点k的距离加上边上的权。
   4. 重复步骤（2）和（3）直到所有顶点都包含在S中。

3. 小总结1. Prim是计算最小生成树的算法，Dijkstra是计算最短路径的算法2. 都是使用贪婪(一个局部最优解也是全局最优解)和线性规划(主问题包含n个子问题，而且其中有重叠的子问题。)，每一步都是选择权值/花费最小的边。
:::

## 应用

### 拓扑排序

循环删除没有入边的点

### 关键路径

最迟发生时间是在不推迟整个工程完成的前提下的最迟必须发生时间,剩余时间=最迟发生时间-最早发生时间
