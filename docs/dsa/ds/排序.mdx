---
sidebar_position: 5
title: 排序
slug: 排序
---

import { Img } from "@components";

# 排序

| 排序算法 | 平均时间复杂度 | 最差时间复杂度 | 空间复杂度   | 数据对象稳定性       |
| -------- | -------------- | -------------- | ------------ | -------------------- |
| 冒泡排序 | $O(n^2) $       | $O(n^2) $       | $O(1) $      | 稳定                 |
| 选择排序 | $O(n^2) $       | $O(n^2) $       | $O(1) $      | 数组不稳定、链表稳定 |
| 插入排序 | $O(n^2) $       | $O(n^2) $       | $O(1) $      | 稳定                 |
| 快速排序 | $O(n\log_2n)$  | $O(n^2) $       | $O(\log_2n)$ | 不稳定               |
| 堆排序   | $O(n\log_2n)$  | $O(n\log_2n) $ | $O(1) $      | 不稳定               |
| 归并排序 | $O(n\log_2n)$  | $O(n\log_2n) $ | $O(n) $      | 稳定                 |
| 希尔排序 | $O(n\log_2n)$  | $O(n^2) $       | $O(1) $      | 不稳定               |
| 计数排序 | $O(n+m) $      | $O(n+m) $      | $O(n+m) $    | 稳定                 |
| 桶排序   | $O(n) $        | $O(n) $        | $O(m) $      | 稳定                 |
| 基数排序 | $O(k \times n) $   | $ O(n^2) $      |              | 稳定                 |

# 内部排序

插，换，选，归，基

1. **插入排序**：在最一趟排序前，没有任何关键字到达最终位置

$$
O(n) ~ O(n^2) = O(n^2)
$$

$$
O(n\log_2n) ~ O(n^2) = O(n^2)
$$

缩小增量直接插入排序：无序→基本有序→全局有序

2. **交换排序**

$$
O(n) ~ O(n^2) = O(n^2)
$$

$$
O(\log_2n)
$$

3. **选择排序**

$$
O(n)
$$

$$
O(n\log_2n)
$$

4. **归并排序**

$$
O(n\log_2n)
$$

$$
O(d(n+r_d))
$$

### 排序特性

5. 稳定：直接插入，冒泡交换

6. 不稳定：希尔插入，快速交换，简单选择，堆选择

$$
O(n^2)
$$

7. 空间复杂度快排式log。 归并排序是ON。 基数排序是。 Ord。 其他都是。 O1。

8. 交换类的排序排序趟数和原始序列有关。基本有序时，冒泡交换有利，快速交换不利。

9. 简单选择和折半插入的关键字比较次数和原始序列无关。

10. 与初始排列序列无关的是基数排序。

11. 冒泡交换、快速交换、简单选择，堆选择可以使经过一趟排序能够保证一个关键词到达最终位置。

![排序比较](/res/compared_sorts.jpeg)

# 外部排序

![外部排序](/res/外部排序.png)

12. **置换选择排序**：用于*生成初始归并段*。根据buffer大小初始化归并段。每所有记录都要进行两次`I/O`操作。

13. **最佳归并树**BMT：使用huffman树的构造方法来构造BMT，用于减少归并次数。

冒泡排序法 插入排序法 堆排序法 二叉树排序法

O(n^2) O(n^2) O(nlog2n) 最差 O(n2) 平均 O(nlog2n)

快速排序法 希尔排序法

最差 O(n^2) 平均 O(nlog2n) O(nlog n) 不稳定

排序算法的稳定性:若待排序的序列中，存在多个具有相同关键字的记录，经过排序，这些记录的相对次序保持不变，则称该算法是稳定的；若经排序后，记录的相对次序发生了改变，则称该算法是不稳定的。

稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序

不是稳定的排序算法：选择排序、快速排序、希尔排序、堆排序

## 选择排序算法的准则

一般而言，需要考虑的因素有以下四点：

设待排序元素的个数为n.

1. 当n较大，则应采用时间复杂度为O(nlog2n)的排序方法：快速排序、堆排序或归并排序序。
2. 当n较大，内存空间允许，且要求稳定性：归并排序
3. 当n较小，可采用直接插入或直接选择排序。
   1. 直接插入排序：当元素分布有序，直接插入排序将大大减少比较次数和移动记录的次数。
   2. 直接选择排序 ：元素分布有序，如果不要求稳定性，选择直接选择排序
4. 一般不使用或不直接使用传统的冒泡排序。
5. 基数排序 它是一种稳定的排序算法，但有一定的局限性：
   1. 关键字可分解。
   2. 记录的关键字位数较少，如果密集更好
   3. 如果是数字时，最好是无符号的

## 循环和递归

递归和循环两者完全可以互换。不能完全决定性地说循环地效率比递归的效率高。

递归算法

优点：代码简洁、清晰，并且容易验证正确性。

缺点：它的运行需要较多次数的函数调用，如果调用层数比较深，需要增加额外的堆栈处理（还有可能出现堆栈溢出的情况），比如参数传递需要压栈等操作，会对执行效率有一定影响。 但是，对于某些问题，如果不使用递归，那将是极端难看的代码。在编译器优化后，对于多次调用的函数处理会有非常好的效率优化，效率未必低于循环。

循环算法

优点：速度快，结构简单。

缺点：并不能解决所有的问题。有的问题适合使用递归而不是循环。如果使用循环并不困难的话，最好使用循环。
