---
sidebar_position: 3
---

# 树

图论中的树和现实生活中的树长得一样，只不过我们习惯于处理问题的时候把树根放到上方来考虑。这种数据结构看起来像是一个倒挂的树，因此得名。


一个没有固定根结点的树称为 无根树（unrooted tree）。无根树有几种等价的形式化定义：

有 n 个结点，n-1 条边的连通无向图

无向无环的连通图

任意两个结点之间有且仅有一条简单路径的无向图

任何边均为桥的连通图

没有圈，且在任意不同两点间添加一条边之后所得图含唯一的一个圈的图

在无根树的基础上，指定一个结点称为 根，则形成一棵 有根树（rooted tree）。有根树在很多时候仍以无向图表示，只是规定了结点之间的上下级关系，详见下文。


适用于无根树和有根树
森林（forest）：每个连通分量（连通块）都是树的图。按照定义，一棵树也是森林。

生成树（spanning tree）：一个连通无向图的生成子图，同时要求是树。也即在图的边集中选择 n - 1 条，将所有顶点连通。

无根树的叶结点（leaf node）：度数不超过 1 的结点。

为什么不是度数恰为 1？
考虑 n = 1。

有根树的叶结点（leaf node）：没有子结点的结点。

树的存储结构

1. 顺序存储结构: 双亲表示法
2. 链式存储结构: 常规表示方法

## 二叉树

几个基本的关系:

```cpp
Tree& tree = new Tree();
assert(tree.branches.length == tree.nodes.length - 1);
assert(tree.layers(i).nodes.length == 2 ** (i - 1));
assert(tree.layers(0,n).nodes.length == 2 ** n - 1);
assert(tree.layers.length == floor(log(tree.nodes.length))+1);
assert(tree.layers.length == ceil(log(tree.nodes.length + 1)));
```

:::success 补充
满二叉树的高度$$h(n) =\dfrac{C_{2n}^n}{n+1}$$
:::

```cpp title="二叉树的结构"
struct TreeNode {
    int val;          // 节点值
    TreeNode *left;   // 左子节点指针
    TreeNode *right;  // 右子节点指针
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};
```

### 遍历

#### 递归算法

```cpp title="先序遍历"
void preorder(TreeNode *root){
    if (root == nullptr)
        return;
    vec.push_back(root->val);
    preOrder(root->left);
    preOrder(root->right);
}
```

```cpp title="中序遍历"
void inOrder(TreeNode *root) {
    if (root == nullptr)
        return;
    inOrder(root->left);
    vec.push_back(root->val);
    inOrder(root->right);
}
```

```cpp title="后序遍历"
void postOrder(TreeNode *root) {
    if (root == nullptr)
        return;
    postOrder(root->left);
    postOrder(root->right);
    vec.push_back(root->val);
}
```

```cpp title="层次遍历: 辅助队列,出队时访问,分别将左右子树入队."
vector<int> levelOrder(TreeNode *root) {
    // 初始化队列，加入根节点
    queue<TreeNode *> queue;
    queue.push(root);
    // 初始化一个列表，用于保存遍历序列
    vector<int> vec;
    while (!queue.empty()) {
        TreeNode *node = queue.front();
        queue.pop();              // 队列出队
        vec.push_back(node->val); // 保存节点值
        if (node->left != nullptr)
            queue.push(node->left); // 左子节点入队
        if (node->right != nullptr)
            queue.push(node->right); // 右子节点入队
    }
    return vec;
}
```

#### 非递归算法

```cpp title="前序遍历"
vector<int> preorder(TreeNode *node){
  stack<TreeNode *> stack;
  vector<int> res;
  stack.push(node);
  TreeNode * temp;
  while(!stack.empty()){
    temp = stack.top();
    stack.pop();
    if(temp -> right != nullptr) stack.push(temp -> right);
    if(temp -> left != nullptr) stack.push(temp -> left);
  };
  return res;
}
```

:::success 线索二叉树
`tree` 结构体中多了一个 `tag` 位. `tag = 1`,指向前驱后继，`tag = 0`,指向左右子树
:::





## 赫夫曼树

6. 结点带权，权值越大离根越近

7. 正则二叉树

8. 带权路径`WPL`最短

9. 构造：最小权结点做兄弟，父结点权值=权值之和。

```cpp
loop{选择最小的两个结点构造棵树,根节点的权值和等于两结点的权值和}
```

10. 结点总数2n-1

11. 哈夫曼树中没有度=1的结点

## 赫夫曼编码

不可做前缀

# 决策树

Decision Tree


## 并查集

并查集是一种用于管理元素所属集合的数据结构，实现为一个森林，其中每棵树表示一个集合，树中的节点表示对应集合中的元素。

顾名思义，并查集支持两种操作：

合并（Union）：合并两个元素所属集合（合并对应的树）
查询（Find）：查询某个元素所属集合（查询对应的树的根节点），这可以用于判断两个元素是否属于同一集合
并查集在经过修改后可以支持单个元素的删除、移动；使用动态开点线段树还可以实现可持久化并查集。

> 并查集无法以较低复杂度实现集合的分离。

