---
title: 概述
sidebar_position: 1
slug: 概述
---


# 概述

:::success 语言
关于数据结构和算法部分,默认采用的语言是C++. 如果需要其他语言请联系作者.
:::

数据结构是以某种特定的布局方式存储数据的容器。这种“布局方式”决定了数据结构对于某些操作是高效的，而对于其他操作则是低效的。首先我们需要理解各种数据结构，才能在处理实际问题时选取最合适的数据结构。数据是计算机科学当中最关键的实体，而数据结构则可以将数据以某种组织形式存储，因此，数据结构的价值不言而喻。
无论你以何种方式解决何种问题，你都需要处理数据——无论是涉及员工薪水、股票价格、购物清单，还是只是简单的电话簿问题。
数据需要根据不同的场景，按照特定的格式进行存储。有很多数据结构能够满足以不同格式存储数据的需求。



:::info 数据结构
1. 数据元素：数据的基本单位，在程序中通常作为一个整体进行考虑处理。
2. 数据项：数据结构中最小单位。
3. 数据对象：性质相同的数据元素的集合，是数据的一个子集。
4. 数据结构：
1. 逻辑结构：集合，表，树，图
2. 存储结构：顺序，链式，索引，散列
3. 对数据的运算
:::

### 数据结构三要素
1. 逻辑结构：探讨数据元素之间的逻辑关系
集合：各个元素同属于一个集合，别无其他关系
线性结构：
数据元素之间是一对一的关系
除了第一个元素，所有元素都有唯一前驱
除了最后一个元素，所有元素都有唯一后继
树形结构：数据元素之间是一对多的关系
图状结构（网状结构）：数据元素之间是多对多的关系
2. 物理结构（存储结构）：探讨如何用计算机表示数据元素的逻辑关系？
顺序存储
链式存储
索引存储
散列存储
根据元素的关键字直接计算出该元素的存储地址，又称为哈希（Hash）存储
3. 数据的运算

import {Tag,To} from '@components'


## 常见的数据结构

### 数组
最简单、也是使用最广泛的数据结构。栈、队列等其他数据结构均由数组演变而来。
每个数据元素都关联一个正数值，我们称之为索引，它表明数组中每个元素所在的位置。大部分语言将初始索引定义为零。
数组的基本操作：

```text
Insert——在指定索引位置插入一个元素
Get——返回指定索引位置的元素
Delete——删除指定索引位置的元素
Size——得到数组所有元素的数量
```


### 栈

后进先出
```text
Push——在顶部插入一个元素
Pop——返回并移除栈顶元素
isEmpty——如果栈为空，则返回true
Top——返回顶部元素，但并不移除它
```
### 队列

与栈相似，队列是另一种顺序存储元素的线性数据结构。栈与队列的最大差别在于栈是LIFO（后进先出），而队列是FIFO，即先进先出。
队列的基本操作
```text
Enqueue -> 在队列尾部插入元素
Dequeue() -> 移除队列头部的元素
isEmpty() -> 如果队列为空，则返回true
Top() -> 返回队列的第一个元素
```

### 链表

链表是另一个重要的线性数据结构，乍一看可能有点像数组，但在内存分配、内部结构以及数据插入和删除的基本操作方面均有所不同。

链表就像一个节点链，其中每个节点包含着数据和指向后续节点的指针。 链表还包含一个头指针，它指向链表的第一个元素，但当列表为空时，它指向null或无具体内容。
链表一般用于实现文件系统、哈希表和邻接表。
链表包括以下类型：
单链表（单向）
双向链表（双向）
```text
InsertAtEnd - 在链表的末尾插入指定元素
InsertAtHead - 在链接列表的开头/头部插入指定元素
Delete - 从链接列表中删除指定元素
DeleteAtHead - 删除链接列表的第一个元素
Search - 从链表中返回指定元素
isEmpty - 如果链表为空，则返回true
```


:::success 数组和链表的区别
从逻辑结构上来看，数组必须实现定于固定的长度，不能适应数据动态增减的情况，即数组的大小一旦定义就不能改变。当数据增加是，可能超过原先定义的元素的个数；当数据减少时，造成内存浪费；链表动态进行存储分配，可以适应数据动态地增减的情况，且可以方便地插入、删除数据项。

从内存存储的角度看；数组从栈中分配空间（用new则在堆上创建），对程序员方便快速，但是自由度小；链表从堆中分配空间，自由度大但是申请管理比较麻烦。

从访问方式类看，数组在内存中是连续的存储，因此可以利用下标索引进行访问；链表是链式存储结构，在访问元素时候只能够通过线性方式由前到后顺序的访问，所以访问效率比数组要低。
:::

### 树

树形结构是一种层级式的数据结构，由顶点（节点）和连接它们的边组成。 树类似于图，但区分树和图的重要特征是树中不存在环路。
树形结构被广泛应用于人工智能和复杂算法，它可以提供解决问题的有效存储机制。
Root - 根节点
Parent - 父节点
Child - 子节点
Leaf - 叶子节点
Sibling - 兄弟节点

### 图

图是一组以网络形式相互连接的节点。节点也称为顶点。 一对节点（x，y）称为边（edge），表示顶点x连接到顶点y。边可以包含权重/成本，显示从顶点x到y所需的成本。

在程序语言中，图可以用两种形式表示：
邻接矩阵
邻接表
常见图遍历算法
广度优先搜索
深度优先搜索

### 字典树Trie
这是一种高效的树形结构，但值得单独说明

字典树，也称为“前缀树”，是一种特殊的树状数据结构，对于解决字符串相关问题非常有效。它能够提供快速检索，主要用于搜索字典中的单词，在搜索引擎中自动提供建议，甚至被用于IP的路由。

### 散列表（哈希表）

哈希法（Hashing）是一个用于唯一标识对象并将每个对象存储在一些预先计算的唯一索引（称为“键（key）”）中的过程。因此，对象以键值对的形式存储，这些键值对的集合被称为“字典”。可以使用键搜索每个对象。基于哈希法有很多不同的数据结构，但最常用的数据结构是哈希表。
哈希表通常使用数组实现。
散列数据结构的性能取决于以下三个因素：
1. 哈希函数
2. 哈希表的大小
3. 碰撞处理方法

:::success 顺序结构和链式结构的区别？
顺序结构是指内存连续的存储单元进行存储，而链式结构是指 内存不连续的结构，通过一个节点指向另外一个节点的地址。
:::

## 算法导论

### 分治算法

5. 复杂问题拆解为子问题
6. 简单子问题求解
7. 子问题的解合并为复杂问题的解

#### 二分查找法



### 贪心算法

8. 将复杂问题拆解为多个子问题

9. 简单子问题的解是当前所有解中的最优解

10. 将所有子问题的解合并为原问题的解

#### 哈夫曼树的构造



### 动态规划算法

将一个规模大的问题转化为几个小问题，通过解决小问题得到整体的解。动态规划的核心问题是问题的状态的定义和状态转移方程的求解。动态规划的关键在于，将重复出现的子问题在第一次求解之后就将其保存起来，以后再遇到时不用重复求解。是按照自底向上的方式计算最优解。（类似于数学归纳法）

当题目求解的是最大值或最小值，可行与否或方案总数时，考虑使用动态规划问题。

1. 将问题分解为不同的子问题

2. 定义状态找出初始状态

3. 状态转移方程求解

4. 求出问题的最终答案

:::tip 问题
台阶总共有n级，青蛙每次可以跳1~n级，一共有几种跳法

<Tag>2016 东南大学</Tag> 给定一个数组，编写一个算法，找出这个数组中最大的逆序差，分析时间复杂度。（逆序差就是i
小于j的情况下，A[j] - A[i]的差，比如[4, 15, 5, 6, 9, 1, 16, 11]
的最大逆序差是16 - 1 = 15
:::

### 回溯算法

15. 针对所给问题，确定问题的解空间

16. 确定节点的扩展搜索规则

17. 以深度优先方式搜索解空间，并在搜索过程中用 ** 剪枝函数 ** 避免无效搜索

#### 深度优先算法
:::tip 问题
<Tag>2018 上海交通大学上机题</Tag> 跳马问题:
:::

[RSA加密算法](https://flowus.cn/4cf3ea35-7724-49af-952b-9ccb05d4bfd2)




## 时间复杂度


## 参考

<To name="Hello 算法" to="https://www.hello-algo.com"/>
<To name="ALGORITHM-TUTORIAL是一个数据结构与算法教程。" to="https://dunwu.github.io/algorithm-tutorial/"/>


# 基本数据类型


计算机中一切数据都是由基本数据类型构成。是CPU可以直接进行运算的类型，在算法中直接使用。

* 整型 int short long
* 浮点型 float double
* 字符 char
* 布尔运算

:::success char 类型的长度
char 类型的长度由编程语言采用的编码方法决定。例如，Java、JavaScript、TypeScript、C# 都采用 UTF-16 编码（保存 Unicode 码点），因此 char 类型的长度为 2 字节。
:::

在 Python 中，整数类型 int 可以是任意大小，只受限于可用内存；浮点数 float 是双精度 64 位；没有 char 类型，单个字符实际上是长度为 1 的字符串 str 。
C 和 C++ 未明确规定基本数据 类型的大小，而因实现和平台各异。
字符 char 的大小在 C 和 C++ 中为 1 字节，在大多数编程语言中取决于特定的字符编码方法，详见“字符编码”章节。
即使表示布尔量仅需 1 位（或），它在内存中通常也存储为 1 字节。这是因为现代计算机 CPU 通常将 1 字节作为最小寻址内存单元。