---
sidebar_position: 2
---

# 线性表

具有相同特性数据元素的一组有限序列，逻辑特性：表头表尾唯一，中间的前驱后继唯一
1. 有限性：元素个数有限

2. 顺序性：有先后次序

3. 同类型：数据元素类型相同，有先后次序

4. 抽象性：只讨论元素间的逻辑关系

链表：无需移动元素

顺序表：随机访问和连续空间

头结点和头指针的区别！默认为有头结点。

静态链表的指针不是内存地址的指针型变量，而是存储数组下标的整型变量。

5. 线性表：具有相同特性数据元素(同类型)的一组有限(有限性)序列(有先后次序，顺序性)，逻辑(只讨论元素间的逻辑关系,抽象性)特性：表头表尾唯一，中间的前驱后继唯一

6. 链表：无需移动元素

7. 顺序表：随机访问和连续空间

8. 静态链表：一个结构体数组，一个`data`，一个`next`。静态链表的指针不是内存地址的指针型变量，而是存储数组下标的整型变量。

9. 双向链表：不提高查找速度。

元素位序是从1开始的，数组中的元素下标是从0开始的。

10. 删除结点后队列为空时，必须特殊处理。

## 顺序表

```cpp
// 顺序表
typedef struct
{
    int data[maxSize];//最大长度
    int length;
}Sqlist;

//考试中一般
int A[maxSize];
int n;
```



```cpp
int search(Sqlist L,int e){
    int i;
    for(i=0;i<L.length;++i){
        if(e==L.data[i])
            return i; //返回数组下标
    }
    return -1;
}

int insert(SqList &L, int p, int e){
    //插入环境判断 位置有效，空间未满
    if(p < 0 || p > L.length || L.length == maxSize) return 0;
    // 后元素右移
    for(int i = L.length - 1; i>=p; --i)
        L.data[i+1]=L.data[i];
    // 插入操作 长度加1
    L.data[p] = e;
    ++(L.length);
    return 1;
}

int delete(Sqlist &L, int p, int &e){
    int i;
    if(p < 0 || p > L.length - 1)
        return 0;
    // 操作目标元素返回
    e = L.data[p];
    // 后元素左移
    for(i = p; i< L.length - 1; ++i)
        L.data[i]=L.data[i+1];
    --(L.length);
    return 1;
}

//将left到right之间的数据逆置
void reverse(int a[],int left,int right){
    int temp;
    for(int i = left,j = right;i < right + 1 && i<j;++i,--j){
        temp = a[i];
        a[i] = a[j];
        a[j] = temp;
    }
}
//循环左移通过逆置算法实现
void moveP(int a[],int n, int p){
    reverse(a,0,p-1);
    reverse(a,p,n-1);
    reverse(a,0,n-1);
}
```


## 链表操作

```Rust
// 单链表
typedef struct Node{
int data;
struct Node *next;
}Node;

// 双链表
typedef struct Node{
int data;
struct Node *next,*prior;
}Node;
```


```Rust
int isEmpty(Node L){
    if(NO_HEAD_LIST) return L == NULL;//不带头结点
    if(HEAD_LIST_Unidirectional) return L.next == NULL;//带头结点单双链表
    if(HEAD_LIST_bidirectional) return L == L.next;//带头结点循环链表
    return -1;
}

void createAtEnd(Node *&L,int a[],int n){
    Node *temp,*rear; //新节点和终端节点的指针
    L = (Node *)malloc(sizeof(Node));
    L.next = NULL;
    rear = L;
    for (int i = 0; i < n; ++i){
        temp=(Node *)malloc(sizeof(Node));
        temp->data = a[i];
        rear->next = temp;
        rear = rear->next;
    }
    rear->next = NULL;
}

void createAtStart(Node *&L,int a[],int n){
    Node *temp; //新节点指针
    L = (Node *)malloc(sizeof(Node));
    L->next = NULL;
    for (int i = 0; i < n; ++i){
        temp=(Node *)malloc(sizeof(Node));
        temp->data = a[i];
        temp->next = C->next;
        C->next = temp;
    }
}

int search(Node *L,int x,Node *&p){
	p = L;
	while(p->next!=NULL){
		if(p->next->data == x) return 1;
		p = p->next;
	}
	return 0;
}

int delete(Node *p){
  	Node *q=p->next;
    p->data = q->data;
    p->next = q->next;
    free(q);
    return 1;
}

void findMidNode(Node *L, Node *&mid){
	Node *p2;
	mid=p2=L;
	while(p2->next){
		p2=p2->next;
		mid=mid->next;
		if(p2->next) p2=p2->next;
    }
}

void reverse(Node *&L){
	Node *rear,*front;
	rear = NULL;
	front = L->next;
	while(front){
		L->next=rear;
		rear = L;
		L = front;
		front = front->next;
    };
	L->next = rear;
}

void merge(Node *A, Node *B, Node *&C){
    //set up tracer
    Node *a = A -> next;
    Node *b = B -> next;
    Node *rear;
    // initial status
    C = A; // 有头节点
    C -> next = NULL;
    free(B);
    rear = C;
    //归并循环
    while(a!=NULL && b !=NULL){
        if(a->data <= b->data){
            rear->next=a;
            a=a->next;
        }
        else{
            rear->next = b;
            b = b -> next;
        }
        rear = rear->next;
    }
    if(a!=NULL) rear->next = a;
    if(b!=NULL) rear->next = b;
}
```


# 栈和队列

:::success 栈和队列的存储方式
栈也有两种存储方法：一是顺序栈；二是链式栈。栈的顺序存储结构是利用一组地址连续的存储单元依次存储自栈底到栈顶的数据元素，同时附设指针 top 指示栈顶元素的位置。由于栈的操作是线性表操作的特例，相对而言，链式栈的操作更易于实现。

栈区：由编辑器自动分配释放，存放函数的参数值，局部变量的值等（基本类型值）。

堆区：由程序员分配释放，若程序员不释放，程序结束时可能有 OS 回收（引用类型值）。

栈（数据结构）：一种先进后出的数据结构。

堆（数据结构）：堆可以被看成是一棵树，如：堆排序。

队列也有两种存储方法：一是顺序队列；二是链式队列，拿链式结构来实现队列，只要将头节点当作队头，尾结点当作队尾，入队时尾节点后移(next)，出队时头节点后移(next)
:::

11. 共享栈 栈底在两端

12. 双端队列

## 栈

```Rust
typedef struct SqStack{
    int data[maxSize];
    int top;
} SqStack;

typedef struct Node {
    int data;
    struct Node *node;
} Node;
```


```Rust
//init
//sqstack
void init(SqStack &st){
    st.top = -1;
};

//Linked Stack
void init(Node *&st){
    st = (LNode *)malloc(sizeof(LNode));
    st -> next = NULL;
}
//check stat
int isEmpty(Stack st){
   	if(SQSTACK) return st.top == -1;
    if(LINKED_STACK) return st->next == NULL;
}
int isFull(SqStack st){
  return st.top == maxSize - 1;
}
//sqstack
int push(SqStack &st,int x){
    if	(isFull(st)) return 0;
    st.data[++st.top] = x;
    return 1;
}
//listack
int push(Node *&st,int x){
    Node *p;
    p = (Node *)malloc(sizeof(Node));
    p->next = NULL;
    p -> data = x;
    p -> next = st ->next;
    st ->next  = p;
}
// sqstack
int pop(SqStack &st,int &x){
    if(isEmpty(st)) return 0;
    x = st.data[st.top--];
    return 1;
}
//listack
int pop(Node &st,int &x){
    Node *p;
    if (st.next = NULL) return 0;
    p=st.next;
    x = p.data;
    st.next=p->next;
    free(p);
    return 1;
}

//simple expression
int stack[maxSize]; int top = -1;
stack[++top] = x;
x = stack[top--];
```


## 队列

```Rust
typedef struct {
    int data[maxSize];
    int front;
    int rear;
}SqQuene;

typedef struct Node {
    int data;
    struct Node *next;
}Node;

typedef struct Queue {
    Node *front;
    Node *rear;
}Queue;
```


```Rust
void initQueue(SqQueue &Q){
    Q.front = Q.rear = 0;
}


void isEmpty(SqQueue Q){
	return  Q.front == Q.rear;
}

void isFull(SqQueue Q){
	return(Q.rear + 1) % maxSize = Q.front;
}

int enqueue(SqQueue &Q, int x){
	if(isFull(Q)) return 0;
	Q.rear = (Q.rear + 1) % maxSize;
	Q.data[Q.rear] = x;
	return 1;
}

int dequeue(SqQueue &Q,int &x){
	if(isEmpty(Q)) return 0;
	Q.front = (Q.front + 1)% maxSize;
	x = Q.data[Q.front];
	return 1;
}
```

### 用两个栈实现队列的功能

算法思路：（时间复杂度为 O（1））

设 2 个栈为 A、B，一开始均为空

入队：将新元素 push 入栈 A

出队：

1. 判断栈 B 是否为空

2. 如果不为空，则将栈 A 中所有元素依次 pop 出并 push 给栈 B

3. 将栈 B 的栈顶元素 pop 出

:::success 堆和栈的区别
Heap 是堆，Stack 是栈

1. Stack 的空间由操作系统自动分配和释放，Heap 上的空间手动分配和释放

2. Stack 空间有限，Heap 是很大的自由存储区

3. C 中的 malloc 函数分配的内存空间即在堆上，C++ 中对应的是 new 操作符
:::


# 字符串

```Rust
//定长顺序分配表示
typedef struct {
    char str[maxSize+1]; //\0 位置
    int length;
}String;

//动态分配存储
typedef struct {
    char *ch;
    int length;
}String;
//需要malloc一个长度为length，类型为char型的连续存储空间
```



```Rust
//赋值法 不能直接等于
int strassign(Str &str,char * ch){
    if (str.ch) free(str.ch);

    int len = 0;
    char *c = ch;
    while(*c){
        ++len;
        ++c;
    }
    if(len = 0){
        str.ch = NULL;
        str.length = 0;
        return 1;
    }
    else{
        str.ch = (char*)malloc((len+1) * sizeof(char));
        if(str.ch == NULL) return 0;
        else{
            c = ch;
            for(int i = 0; i<=len; ++i,++c) str.ch[i] = *c;
            str.length = len;
            return 1;
        }
    }
}

while(*p != '\0'){
	...
    ++p;
}
```


## KMP

`Knuth-Morris-Pratt`算法

在一个字符串中查找是否包含目标的匹配字符串。

其主要思想是每趟比较过程让子串先后滑动一个合适的位置。

当发生不匹配的情况时，不是右移一位，而是移动（当前匹配的长度– 当前匹配子串的部分匹配值）位。

## BM

精确字符串匹配算法

# 数组和矩阵

13. 二维数组是一维数组的一维数组，一般采用顺序存储

14. 广义表：表元素可以是原子或者广义表的线型表拓展结构。

15. 二维数组行优先列优先的下标问题

16. 对称矩阵、三角矩阵、对角矩阵的物理表示和确定元素位置问题

稀疏矩阵：

```Rust
三元组表示法
int trimat[maxterms+1][3];
trimat[k][0]; 表示原矩阵中元素按照行优先的顺序的第k个非零元素值
float trimat[maxterms+1][3] 的行号 (int)trimat[k][1];

伪地址表示法
两元组表示，值和伪地址：元素在矩阵中按照行优先或列优先存储的相对位置
```


```Rust
邻接表表示法
每一行的非零元素连成一个链表，链表结点中有两个分量，一个是元素值，一个是列号。

十字链表表示法
行和列都用带头结点的邻接表表示，头结点数组不存储任何信息
链表结点有5个分量，行分量、列分量、数据域分量、同列下一个结点、同行下一个结点指针。
    十字链表结点有5个分量，行数、列数、非零元素个数、行头结点数组指针、列头结点数组指针。
typedef struct OLNode {
int row,col;
struct OLNode *right,*down;
float val;
} OLNode;

typedef struct CrossList {
OLNode *rhead,*chead;
int m,n,k;
}
```


```Rust
//T
void trsmat(int A[][maxSize],int B[][maxSize],int m,int n){
    for(int i = 0;i <m;++i)
        for(int j = 0;j < n ; ++ j)
            B[j][i] = A[i][j];
}
```


# 哈希表



## 数组

「数组 array」是一种线性数据结构，其将相同类型的元素存储在连续的内存空间中。我们将元素在数组中的位置称为该元素的「索引 index」。图 4-1 展示了数组的主要概念和存储方式。

数组存储在连续的内存空间内，且元素类型相同。这种做法包含丰富的先验信息，系统可以利用这些信息来优化数据结构的操作效率。

空间效率高：数组为数据分配了连续的内存块，无须额外的结构开销。
支持随机访问：数组允许在 
 时间内访问任何元素。
缓存局部性：当访问数组元素时，计算机不仅会加载它，还会缓存其周围的其他数据，从而借助高速缓存来提升后续操作的执行速度。
连续空间存储是一把双刃剑，其存在以下局限性。

插入与删除效率低：当数组中元素较多时，插入与删除操作需要移动大量的元素。
长度不可变：数组在初始化后长度就固定了，扩容数组需要将所有数据复制到新数组，开销很大。
空间浪费：如果数组分配的大小超过实际所需，那么多余的空间就被浪费了。


数组是一种基础且常见的数据结构，既频繁应用在各类算法之中，也可用于实现各种复杂数据结构。

随机访问：如果我们想随机抽取一些样本，那么可以用数组存储，并生成一个随机序列，根据索引实现随机抽样。
排序和搜索：数组是排序和搜索算法最常用的数据结构。快速排序、归并排序、二分查找等都主要在数组上进行。
查找表：当需要快速查找一个元素或其对应关系时，可以使用数组作为查找表。假如我们想实现字符到 ASCII 码的映射，则可以将字符的 ASCII 码值作为索引，对应的元素存放在数组中的对应位置。
机器学习：神经网络中大量使用了向量、矩阵、张量之间的线性代数运算，这些数据都是以数组的形式构建的。数组是神经网络编程中最常使用的数据结构。
数据结构实现：数组可以用于实现栈、队列、哈希表、堆、图等数据结构。例如，图的邻接矩阵表示实际上是一个二维数组。


:::success 数组存储在栈上和存储在堆上，对时间效率和空间效率是否有影响？
存储在栈上和堆上的数组都被存储在连续内存空间内，数据操作效率基本一致。然而，栈和堆具有各自的特点，从而导致以下不同点。

分配和释放效率：栈是一块较小的内存，分配由编译器自动完成；而堆内存相对更大，可以在代码中动态分配，更容易碎片化。因此，堆上的分配和释放操作通常比栈上的慢。
大小限制：栈内存相对较小，堆的大小一般受限于可用内存。因此堆更加适合存储大型数组。
灵活性：栈上的数组的大小需要在编译时确定，而堆上的数组的大小可以在运行时动态确定。
:::

## 链表

单向链表通常用于实现栈、队列、哈希表和图等数据结构。

栈与队列：当插入和删除操作都在链表的一端进行时，它表现出先进后出的特性，对应栈；当插入操作在链表的一端进行，删除操作在链表的另一端进行，它表现出先进先出的特性，对应队列。
哈希表：链式地址是解决哈希冲突的主流方案之一，在该方案中，所有冲突的元素都会被放到一个链表中。
图：邻接表是表示图的一种常用方式，其中图的每个顶点都与一个链表相关联，链表中的每个元素都代表与该顶点相连的其他顶点。
双向链表常用于需要快速查找前一个和后一个元素的场景。

高级数据结构：比如在红黑树、B 树中，我们需要访问节点的父节点，这可以通过在节点中保存一个指向父节点的引用来实现，类似于双向链表。
浏览器历史：在网页浏览器中，当用户点击前进或后退按钮时，浏览器需要知道用户访问过的前一个和后一个网页。双向链表的特性使得这种操作变得简单。
LRU 算法：在缓存淘汰（LRU）算法中，我们需要快速找到最近最少使用的数据，以及支持快速添加和删除节点。这时候使用双向链表就非常合适。
环形链表常用于需要周期性操作的场景，比如操作系统的资源调度。

时间片轮转调度算法：在操作系统中，时间片轮转调度算法是一种常见的 CPU 调度算法，它需要对一组进程进行循环。每个进程被赋予一个时间片，当时间片用完时，CPU 将切换到下一个进程。这种循环操作可以通过环形链表来实现。
数据缓冲区：在某些数据缓冲区的实现中，也可能会使用环形链表。比如在音频、视频播放器中，数据流可能会被分成多个缓冲块并放入一个环形链表，以便实现无缝播放。

:::success 删除节点 P 后，是否需要把 P.next 设为 None 呢？
不修改 P.next 也可以。从该链表的角度看，从头节点遍历到尾节点已经不会遇到 P 了。这意味着节点 P 已经从链表中删除了，此时节点 P 指向哪里都不会对该链表产生影响。

从数据结构与算法（做题）的角度看，不断开没有关系，只要保证程序的逻辑是正确的就行。从标准库的角度看，断开更加安全、逻辑更加清晰。如果不断开，假设被删除节点未被正常回收，那么它会影响后继节点的内存回收。
:::

## 列表

「列表 list」是一个抽象的数据结构概念，它表示元素的有序集合，支持元素访问、修改、添加、删除和遍历等操作，无须使用者考虑容量限制的问题。列表可以基于链表或数组实现。

链表天然可以看作一个列表，其支持元素增删查改操作，并且可以灵活动态扩容。
数组也支持元素增删查改，但由于其长度不可变，因此只能看作一个具有长度限制的列表。
当使用数组实现列表时，长度不可变的性质会导致列表的实用性降低。这是因为我们通常无法事先确定需要存储多少数据，从而难以选择合适的列表长度。若长度过小，则很可能无法满足使用需求；若长度过大，则会造成内存空间浪费。

为解决此问题，我们可以使用「动态数组 dynamic array」来实现列表。它继承了数组的各项优点，并且可以在程序运行过程中进行动态扩容。

实际上，许多编程语言中的标准库提供的列表是基于动态数组实现的，例如 Python 中的 list 、Java 中的 ArrayList 、C++ 中的 vector 和 C# 中的 List 等。在接下来的讨论中，我们将把“列表”和“动态数组”视为等同的概念。

许多编程语言内置了列表，例如 Java、C++、Python 等。它们的实现比较复杂，各个参数的设定也非常考究，例如初始容量、扩容倍数等。感兴趣的读者可以查阅源码进行学习。

为了加深对列表工作原理的理解，我们尝试实现一个简易版列表，包括以下三个重点设计。

初始容量：选取一个合理的数组初始容量。在本示例中，我们选择 10 作为初始容量。
数量记录：声明一个变量 size ，用于记录列表当前元素数量，并随着元素插入和删除实时更新。根据此变量，我们可以定位列表尾部，以及判断是否需要扩容。
扩容机制：若插入元素时列表容量已满，则需要进行扩容。先根据扩容倍数创建一个更大的数组，再将当前数组的所有元素依次移动至新数组。在本示例中，我们规定每次将数组扩容至之前的 2 倍。

:::success “列表的出现极大地提高了数组的实用性，但可能导致部分内存空间浪费”，这里的空间浪费是指额外增加的变量如容量、长度、扩容倍数所占的内存吗？
这里的空间浪费主要有两方面含义：一方面，列表都会设定一个初始长度，我们不一定需要用这么多；另一方面，为了防止频繁扩容，扩容一般会乘以一个系数，比如 
 。这样一来，也会出现很多空位，我们通常不能完全填满它们。
:::


:::warning C++ STL 里面的 std::list 已经实现了双向链表，但好像一些算法书上不怎么直接使用它，是不是因为有什么局限性呢？

一方面，我们往往更青睐使用数组实现算法，而只在必要时才使用链表，主要有两个原因。

空间开销：由于每个元素需要两个额外的指针（一个用于前一个元素，一个用于后一个元素），所以 std::list 通常比 std::vector 更占用空间。
缓存不友好：由于数据不是连续存放的，因此 std::list 对缓存的利用率较低。一般情况下，std::vector 的性能会更好。
另一方面，必要使用链表的情况主要是二叉树和图。栈和队列往往会使用编程语言提供的 stack 和 queue ，而非链表。
:::

## 缓存

在本章的前两节中，我们探讨了数组和链表这两种基础且重要的数据结构，它们分别代表了“连续存储”和“分散存储”两种物理结构。

实际上，物理结构在很大程度上决定了程序对内存和缓存的使用效率，进而影响算法程序的整体性能。

计算机中包括三种类型的存储设备：「硬盘 hard disk」、「内存 random-access memory, RAM」、「缓存 cache memory」。表 4-2 展示了它们在计算机系统中的不同角色和性能特点。

在内存空间利用方面，数组和链表各自具有优势和局限性。

一方面，内存是有限的，且同一块内存不能被多个程序共享，因此我们希望数据结构能够尽可能高效地利用空间。数组的元素紧密排列，不需要额外的空间来存储链表节点间的引用（指针），因此空间效率更高。然而，数组需要一次性分配足够的连续内存空间，这可能导致内存浪费，数组扩容也需要额外的时间和空间成本。相比之下，链表以“节点”为单位进行动态内存分配和回收，提供了更大的灵活性。

另一方面，在程序运行时，随着反复申请与释放内存，空闲内存的碎片化程度会越来越高，从而导致内存的利用效率降低。数组由于其连续的存储方式，相对不容易导致内存碎片化。相反，链表的元素是分散存储的，在频繁的插入与删除操作中，更容易导致内存碎片化。

## 栈

浏览器中的后退与前进、软件中的撤销与反撤销。每当我们打开新的网页，浏览器就会对上一个网页执行入栈，这样我们就可以通过后退操作回到上一个网页。后退操作实际上是在执行出栈。如果要同时支持后退和前进，那么需要两个栈来配合实现。
程序内存管理。每次调用函数时，系统都会在栈顶添加一个栈帧，用于记录函数的上下文信息。在递归函数中，向下递推阶段会不断执行入栈操作，而向上回溯阶段则会不断执行出栈操作。


## 队列

淘宝订单。购物者下单后，订单将加入队列中，系统随后会根据顺序处理队列中的订单。在双十一期间，短时间内会产生海量订单，高并发成为工程师们需要重点攻克的问题。
各类待办事项。任何需要实现“先来后到”功能的场景，例如打印机的任务队列、餐厅的出餐队列等，队列在这些场景中可以有效地维护处理顺序。