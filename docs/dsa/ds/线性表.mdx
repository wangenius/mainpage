---
sidebar_position: 2
---

# 线性表

具有相同特性数据元素的一组有限序列，逻辑特性：表头表尾唯一，中间的前驱后继唯一
1. 有限性：元素个数有限

2. 顺序性：有先后次序

3. 同类型：数据元素类型相同，有先后次序

4. 抽象性：只讨论元素间的逻辑关系

链表：无需移动元素

顺序表：随机访问和连续空间

头结点和头指针的区别！默认为有头结点。

静态链表的指针不是内存地址的指针型变量，而是存储数组下标的整型变量。

5. 线性表：具有相同特性数据元素(同类型)的一组有限(有限性)序列(有先后次序，顺序性)，逻辑(只讨论元素间的逻辑关系,抽象性)特性：表头表尾唯一，中间的前驱后继唯一

6. 链表：无需移动元素

7. 顺序表：随机访问和连续空间

8. 静态链表：一个结构体数组，一个`data`，一个`next`。静态链表的指针不是内存地址的指针型变量，而是存储数组下标的整型变量。

9. 双向链表：不提高查找速度。

元素位序是从1开始的，数组中的元素下标是从0开始的。

10. 删除结点后队列为空时，必须特殊处理。

## 顺序表

```cpp
// 顺序表
typedef struct
{
    int data[maxSize];//最大长度
    int length;
}Sqlist;

//考试中一般
int A[maxSize];
int n;
```



```cpp
int search(Sqlist L,int e){
    int i;
    for(i=0;i<L.length;++i){
        if(e==L.data[i])
            return i; //返回数组下标
    }
    return -1;
}

int insert(SqList &L, int p, int e){
    //插入环境判断 位置有效，空间未满
    if(p < 0 || p > L.length || L.length == maxSize) return 0;
    // 后元素右移
    for(int i = L.length - 1; i>=p; --i)
        L.data[i+1]=L.data[i];
    // 插入操作 长度加1
    L.data[p] = e;
    ++(L.length);
    return 1;
}

int delete(Sqlist &L, int p, int &e){
    int i;
    if(p < 0 || p > L.length - 1)
        return 0;
    // 操作目标元素返回
    e = L.data[p];
    // 后元素左移
    for(i = p; i< L.length - 1; ++i)
        L.data[i]=L.data[i+1];
    --(L.length);
    return 1;
}

//将left到right之间的数据逆置
void reverse(int a[],int left,int right){
    int temp;
    for(int i = left,j = right;i < right + 1 && i<j;++i,--j){
        temp = a[i];
        a[i] = a[j];
        a[j] = temp;
    }
}
//循环左移通过逆置算法实现
void moveP(int a[],int n, int p){
    reverse(a,0,p-1);
    reverse(a,p,n-1);
    reverse(a,0,n-1);
}
```


## 链表操作

```Rust
// 单链表
typedef struct Node{
int data;
struct Node *next;
}Node;

// 双链表
typedef struct Node{
int data;
struct Node *next,*prior;
}Node;
```


```Rust
int isEmpty(Node L){
    if(NO_HEAD_LIST) return L == NULL;//不带头结点
    if(HEAD_LIST_Unidirectional) return L.next == NULL;//带头结点单双链表
    if(HEAD_LIST_bidirectional) return L == L.next;//带头结点循环链表
    return -1;
}

void createAtEnd(Node *&L,int a[],int n){
    Node *temp,*rear; //新节点和终端节点的指针
    L = (Node *)malloc(sizeof(Node));
    L.next = NULL;
    rear = L;
    for (int i = 0; i < n; ++i){
        temp=(Node *)malloc(sizeof(Node));
        temp->data = a[i];
        rear->next = temp;
        rear = rear->next;
    }
    rear->next = NULL;
}

void createAtStart(Node *&L,int a[],int n){
    Node *temp; //新节点指针
    L = (Node *)malloc(sizeof(Node));
    L->next = NULL;
    for (int i = 0; i < n; ++i){
        temp=(Node *)malloc(sizeof(Node));
        temp->data = a[i];
        temp->next = C->next;
        C->next = temp;
    }
}

int search(Node *L,int x,Node *&p){
	p = L;
	while(p->next!=NULL){
		if(p->next->data == x) return 1;
		p = p->next;
	}
	return 0;
}

int delete(Node *p){
  	Node *q=p->next;
    p->data = q->data;
    p->next = q->next;
    free(q);
    return 1;
}

void findMidNode(Node *L, Node *&mid){
	Node *p2;
	mid=p2=L;
	while(p2->next){
		p2=p2->next;
		mid=mid->next;
		if(p2->next) p2=p2->next;
    }
}

void reverse(Node *&L){
	Node *rear,*front;
	rear = NULL;
	front = L->next;
	while(front){
		L->next=rear;
		rear = L;
		L = front;
		front = front->next;
    };
	L->next = rear;
}

void merge(Node *A, Node *B, Node *&C){
    //set up tracer
    Node *a = A -> next;
    Node *b = B -> next;
    Node *rear;
    // initial status
    C = A; // 有头节点
    C -> next = NULL;
    free(B);
    rear = C;
    //归并循环
    while(a!=NULL && b !=NULL){
        if(a->data <= b->data){
            rear->next=a;
            a=a->next;
        }
        else{
            rear->next = b;
            b = b -> next;
        }
        rear = rear->next;
    }
    if(a!=NULL) rear->next = a;
    if(b!=NULL) rear->next = b;
}
```


# 栈和队列

:::success 栈和队列的存储方式
栈也有两种存储方法：一是顺序栈；二是链式栈。栈的顺序存储结构是利用一组地址连续的存储单元依次存储自栈底到栈顶的数据元素，同时附设指针 top 指示栈顶元素的位置。由于栈的操作是线性表操作的特例，相对而言，链式栈的操作更易于实现。

栈区：由编辑器自动分配释放，存放函数的参数值，局部变量的值等（基本类型值）。

堆区：由程序员分配释放，若程序员不释放，程序结束时可能有 OS 回收（引用类型值）。

栈（数据结构）：一种先进后出的数据结构。

堆（数据结构）：堆可以被看成是一棵树，如：堆排序。

队列也有两种存储方法：一是顺序队列；二是链式队列，拿链式结构来实现队列，只要将头节点当作队头，尾结点当作队尾，入队时尾节点后移(next)，出队时头节点后移(next)
:::

11. 共享栈 栈底在两端

12. 双端队列

## 栈

```Rust
typedef struct SqStack{
    int data[maxSize];
    int top;
} SqStack;

typedef struct Node {
    int data;
    struct Node *node;
} Node;
```


```Rust
//init
//sqstack
void init(SqStack &st){
    st.top = -1;
};

//Linked Stack
void init(Node *&st){
    st = (LNode *)malloc(sizeof(LNode));
    st -> next = NULL;
}
//check stat
int isEmpty(Stack st){
   	if(SQSTACK) return st.top == -1;
    if(LINKED_STACK) return st->next == NULL;
}
int isFull(SqStack st){
  return st.top == maxSize - 1;
}
//sqstack
int push(SqStack &st,int x){
    if	(isFull(st)) return 0;
    st.data[++st.top] = x;
    return 1;
}
//listack
int push(Node *&st,int x){
    Node *p;
    p = (Node *)malloc(sizeof(Node));
    p->next = NULL;
    p -> data = x;
    p -> next = st ->next;
    st ->next  = p;
}
// sqstack
int pop(SqStack &st,int &x){
    if(isEmpty(st)) return 0;
    x = st.data[st.top--];
    return 1;
}
//listack
int pop(Node &st,int &x){
    Node *p;
    if (st.next = NULL) return 0;
    p=st.next;
    x = p.data;
    st.next=p->next;
    free(p);
    return 1;
}

//simple expression
int stack[maxSize]; int top = -1;
stack[++top] = x;
x = stack[top--];
```


## 队列

```Rust
typedef struct {
    int data[maxSize];
    int front;
    int rear;
}SqQuene;

typedef struct Node {
    int data;
    struct Node *next;
}Node;

typedef struct Queue {
    Node *front;
    Node *rear;
}Queue;
```


```Rust
void initQueue(SqQueue &Q){
    Q.front = Q.rear = 0;
}


void isEmpty(SqQueue Q){
	return  Q.front == Q.rear;
}

void isFull(SqQueue Q){
	return(Q.rear + 1) % maxSize = Q.front;
}

int enqueue(SqQueue &Q, int x){
	if(isFull(Q)) return 0;
	Q.rear = (Q.rear + 1) % maxSize;
	Q.data[Q.rear] = x;
	return 1;
}

int dequeue(SqQueue &Q,int &x){
	if(isEmpty(Q)) return 0;
	Q.front = (Q.front + 1)% maxSize;
	x = Q.data[Q.front];
	return 1;
}
```

### 用两个栈实现队列的功能

算法思路：（时间复杂度为 O（1））

设 2 个栈为 A、B，一开始均为空

入队：将新元素 push 入栈 A

出队：

1. 判断栈 B 是否为空

2. 如果不为空，则将栈 A 中所有元素依次 pop 出并 push 给栈 B

3. 将栈 B 的栈顶元素 pop 出

:::success 堆和栈的区别
Heap 是堆，Stack 是栈

1. Stack 的空间由操作系统自动分配和释放，Heap 上的空间手动分配和释放

2. Stack 空间有限，Heap 是很大的自由存储区

3. C 中的 malloc 函数分配的内存空间即在堆上，C++ 中对应的是 new 操作符
:::


# 字符串

```Rust
//定长顺序分配表示
typedef struct {
    char str[maxSize+1]; //\0 位置
    int length;
}String;

//动态分配存储
typedef struct {
    char *ch;
    int length;
}String;
//需要malloc一个长度为length，类型为char型的连续存储空间
```



```Rust
//赋值法 不能直接等于
int strassign(Str &str,char * ch){
    if (str.ch) free(str.ch);

    int len = 0;
    char *c = ch;
    while(*c){
        ++len;
        ++c;
    }
    if(len = 0){
        str.ch = NULL;
        str.length = 0;
        return 1;
    }
    else{
        str.ch = (char*)malloc((len+1) * sizeof(char));
        if(str.ch == NULL) return 0;
        else{
            c = ch;
            for(int i = 0; i<=len; ++i,++c) str.ch[i] = *c;
            str.length = len;
            return 1;
        }
    }
}

while(*p != '\0'){
	...
    ++p;
}
```


## KMP

`Knuth-Morris-Pratt`算法

在一个字符串中查找是否包含目标的匹配字符串。

其主要思想是每趟比较过程让子串先后滑动一个合适的位置。

当发生不匹配的情况时，不是右移一位，而是移动（当前匹配的长度– 当前匹配子串的部分匹配值）位。

## BM

精确字符串匹配算法

# 数组和矩阵

13. 二维数组是一维数组的一维数组，一般采用顺序存储

14. 广义表：表元素可以是原子或者广义表的线型表拓展结构。

15. 二维数组行优先列优先的下标问题

16. 对称矩阵、三角矩阵、对角矩阵的物理表示和确定元素位置问题

稀疏矩阵：

```Rust
三元组表示法
int trimat[maxterms+1][3];
trimat[k][0]; 表示原矩阵中元素按照行优先的顺序的第k个非零元素值
float trimat[maxterms+1][3] 的行号 (int)trimat[k][1];

伪地址表示法
两元组表示，值和伪地址：元素在矩阵中按照行优先或列优先存储的相对位置
```


```Rust
邻接表表示法
每一行的非零元素连成一个链表，链表结点中有两个分量，一个是元素值，一个是列号。

十字链表表示法
行和列都用带头结点的邻接表表示，头结点数组不存储任何信息
链表结点有5个分量，行分量、列分量、数据域分量、同列下一个结点、同行下一个结点指针。
    十字链表结点有5个分量，行数、列数、非零元素个数、行头结点数组指针、列头结点数组指针。
typedef struct OLNode {
int row,col;
struct OLNode *right,*down;
float val;
} OLNode;

typedef struct CrossList {
OLNode *rhead,*chead;
int m,n,k;
}
```


```Rust
//T
void trsmat(int A[][maxSize],int B[][maxSize],int m,int n){
    for(int i = 0;i <m;++i)
        for(int j = 0;j < n ; ++ j)
            B[j][i] = A[i][j];
}
```


# 哈希表

散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。给定表M，存在函数f(key)，对任意给定的关键字值key，代入函数后若能得到包含该关键字的记录在表中的地址，则称表M为哈希(Hash)表，函数f(key)为哈希(Hash) 函数

## 冲突解决

哈希表（Hash table，也叫散列表），是根据关键码值(Key value)而直接进行访问的数据结构。

1） 线性探测法

2） 平方探测法

3） 伪随机序列法

4） 拉链法

