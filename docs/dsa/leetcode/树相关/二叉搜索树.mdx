# 树相关

## 二叉搜索树

给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 平衡 二叉搜索树。

```cpp
class Solution{
private:
    TreeNode *buildTree(vector<int> &nums, int start, int end)
    {
        if (start > end) return nullptr;
        int mid = start + ((end - start) >> 1);
        TreeNode *root = new TreeNode(nums[mid]);
        root->left = buildTree(nums, start, mid - 1);
        root->right = buildTree(nums, mid + 1, end);
        return root;
    }
public:
    TreeNode *sortedArrayToBST(vector<int> &nums)
    {
        return buildTree(nums, 0, nums.size() - 1);
    }
};
```


## 平衡二叉树
给定一个二叉树，判断它是否是 平衡二叉树  


```cpp
class Solution {
private:
    //遍历查看分支深度
    int traverse(TreeNode* node){
        if(node == nullptr) return 0;
        //返回一个深度
        int l = 0,r = 0;
        l = traverse(node -> left);
        if(l == -1) return -1;
        r = traverse(node -> right);
        if(r == -1) return -1;
        if(l - r >= 2 || r - l >= 2) return -1;
        return max(l,r) + 1;
    }
public:
    bool isBalanced(TreeNode* root) {
        return ! (traverse(root) == -1);
    }
};
```


给定一个二叉树，找出其最小深度。

最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

```cpp
class Solution {
private:
    int traverse(TreeNode* node){
        if(node -> left == nullptr && node -> right == nullptr)
        return 1;
        if (node -> left == nullptr)
            return traverse(node -> right) + 1;
        else if(node -> right == nullptr)
            return traverse(node -> left) + 1;
        return min(traverse(node -> left), traverse(node -> right)) + 1;
    }
public:
    int minDepth(TreeNode* root) {
        if(root == nullptr) return 0;
        return traverse(root);
    }
};
```


```cpp
class Solution
{

private:
    bool traverse(TreeNode *node, int &sum, int &target)
    {
        if (node)
            sum += node->val;
        else
            return false;

        if (!node->left && !node->right)
        {
            if (sum == target)
                return true;
        }
        else
        {
            if (traverse(node->left, sum, target))
                return true;
            if (traverse(node->right, sum, target))
                return true;
        }
        sum -= node->val;
        return false;
    }

public:
    bool hasPathSum(TreeNode *root, int targetSum)
    {
        int sum = 0;
        return traverse(root, sum, targetSum);
    }
};
```