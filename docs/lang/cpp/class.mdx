---
title : Class
sidebar_position : 7
slug : Class
---

# Class

## concrete class

典型特征: 表示是定义的一部分. 如vector其表示只是一个或者几个指针,指向保存在别处的数据. 但这种表示出现在具体类的每一个对象当中. 这令实现可以在时空中达到最优. 特别是它允许我们:
1. 将具体类型的对象置于栈,静态分配的内存或者其他对象当中. 
2. 直接引用对象(而非仅仅通过指针或者引用)
3. 立即进行完整的对象初始化(比如构造函数)
4. 拷贝或移动对象

类的表示可以是私有的,从而只能通过成员函数访问, 但他确实存在. 因此如果表示方式发生了任何明显的改动, 使用者就必须重新编译. 这就是我们令具体类型的行为与内置类型完全一样需要付出代价. 对于某些场景,不常改动的类型和局部变量提供了迫切需要的清晰性和效率,此时这种特性是可以接受的, 而且通常很理想. 为了提高灵活性, 具体类型可以将其表示的主要部分防止在动态存储/堆当中,然后通过存储在类对象内部的成员访问他们. vector和string就是这样实现的,我们可以将他们看成带有精心打造的接口的资源管理器. 

一种经典的用户自定义算数类型:
```cpp title="Complex"
class complex{
    double re,im; // 表示i两个双精度浮点数
    public:
    complex(double r,double i):re{r},im{i}{} //用两个标量构造该复数
    complex(double r):re{r},im{0}{} //用一个标量构造该复数
    complex()re{0},im{0}{} //默认复数{0,0}
    double real() const {return re;}
    void real(double d){re = d;}
    double imag()const {return im;}
    void imag(double d){im = d;}

    complex& operator += (complex z){
        re+= z.re;
        im+= z.im;
        return *this;//返回结果
    }

    complex& operator -= (complex z){
        re-= z.re;
        im-= z.im;
        return *this;
    }

    // 在类外的某处定义
    complex& operator *= (complex);
    complex& operator /= (complex);

};
```


此时

```cpp title="调用"
complex z = {1,0};
const complex cz {1,3};
z = cz; //right! 向一个const变量赋值
cz = z; //wrong! complex::operator=() 是一个非const成员函数
double x = z.real(); //正确! complex::real()是一个const成员函数
```

很多操作不需要直接访问complex,因此它们的定义可以和类的定义分离开来:
```cpp title="other"
complex operator+(complex a, complex b){return a+=b;}
complex operator-(complex a, complex b){return a-=b;}
complex operator-(complex a){return {-a.real(),-a.imag()}}
complex operator*(complex a, complex b){return a*=b;}
complex operator/(complex a, complex b){return a/=b;}
```

在本例中,我们利用了一个事实: 以传值方式传递实参实际上是进行拷贝, 因此我可以修改实参而不会影响调用者的副本, 并可以将结果作为返回值. 

```cpp title="==,!="
bool operator==(complex a, complex b){
    return a.real() == b.real() && a.imag() == b.imag();
}

bool operator!=(complex a, complex b){
    return !(a!=b);
}
```

### 容器Container 

Vector类型的对象都是容器, 所以我们称类Vector是一种容器类型. 如之前提到的Vector使用很不错的double容器. 建立了一个有用的不变式, 提供了带边界检查的访问并且提供了size()令我们可以遍历其元素. 然而他还是存在一个致命缺陷:使用new分配元素,但没有释放元素. 尽管C++定义了一个垃圾回收器的接口,但并不能保证他总是可用的以将为用内存提供给新对象. 在某些情况下, 你不能使用回收器, 而且通常处于逻辑或性能考虑, 你更想使用精确的回收控制. 因此我们需要一种机制来确保构造函数分配的内存一定会被释放, 这种机制就叫做**析构函数**. 

```cpp title="destructor"
class Vector{
    public:
    Vector(int s):elem{new double[s]},sz{s}{
        //初始化元素
        for(int i = 0; i < s; ++i)
            elem[i] = 0; 
    }

    // 析构函数 释放资源
    ~Vector(){delete[]elem;}

    double& operator[](int i);
    int size() const;

    private:
    double* elem;//elem指向一个含有sz个的double数组
    int sz;
};
```

析构函数的命名规则是求补运算符~后接类的名字,是构造函数的补充. Vector的构造函数使用new运算符从动态存储分配内存. 析构函数则使用delete[] 运算符释放该内存实现清理. 普通的delete释放单个对象,delete[]释放数组. 

这一切无需Vector的使用者干预,使用者只需像内置类型的变量那样创建和使用Vector对象就可以了. 
```cpp title="fct.cpp"
void fct(int n){
    Vector v(n);
    //使用v
    {
        Vector v2(2*n);
        //使用v和v2
    }//v2 在此处销毁
    //使用v
}//v在此处销毁
```

构造函数分配元素并正确初始化Vector的成员, 析构函数释放元素. 这就是所谓的数据句柄模型(handle-to-data model), 常用来管理在对象生命周期中大小会发生变化的数据.在构造函数中请求资源,然后再析构函数中释放它们的技术叫做资源请求即初始化(Resource Acquisition Is Initialization,RAII), 它令我们得以规避裸new的请求,同时也应该避免裸delete的请求.


#### 初始化容器

1. 初始化值列表构造函数initializer-list constructor: 用一个元素列表进行初始化
2. push_back():在序列末尾添加一个新元素


```cpp title="initializer"
class Vector{
    public:
    Vector(std::initializer_list<double>);//用一个double列表进行初始化
    void push_back(double); //在末尾添加一个元素,容器的长度加1
}

Vector::Vector(statusbar_list<double> lst)
:elem{new double[lst.size()]},sz{static_cast<int>(lst.size())}
{
    copy(lst.begin(),lst.end(),elem);
};
```
标准库的带下和下表都用unsigned整数,所以我们需要使用丑陋的static_cast来将初始值列表的大小显式转换为一个int. 

:::success
1. reinterpret_cast 将对象视为简单的字节序列
2. const_cast 强制去掉const
:::



## abstract class

Vector和complex属于具体类型,因为它们的表示属于定义的一部分. 在这一点上,它们与内置类型很相似. 

相反,抽象类型将使用者与类的实现细节完全隔离开来, 为此我们将接口和表示分离开来,并且放弃了纯局部变量, 由于我们对抽象类型的表示一无所知(甚至对大小也不了解), 所以必须从自由存储的分配对象,然后通过引用或指针访问对象. 

```cpp title="container"
class Container{
    public:
    virtual double& operator[](int) = 0; //纯虚函数
    virtual int size() const = 0; //常量成员函数
    virtual ~Container( ){} //析构函数
};
```
这个类是一个纯接口,是为稍后定义的特定容器设计的接口. 关键子virtual的意思是可能随后在派生类中被重新定义. 不出所料,我们将这种声明为virtual的函数成为虚函数. Container类的派生类应为Container接口提供具体实现. 语法 `=0` 看起来有点奇怪,它说明函数是纯虚函数. 即Container的派生类必须重新定义这个函数. 因此我们不可能定义一个Container函数

```cpp
Container c; //错误, 不能定义抽象类对象
Container* p = new Vector_Container(10); //正确
```

Container只是作为接口出现, 为具体实现`operator[]()`和`size()`函数的类提供接口. 包含纯虚函数的类称为抽象类(abstract class);

Container 的用法:
```cpp title="use.cpp"
void use(Container& c){
    const int sz = c.size();
    for (int i = 0; i < sz; ++i) {
        cout << c[i] << endl;
    }
}
```

use()忽略了实现细节的情况下使用Container接口. 根本不知道那个类型实现了它们.

Container没有构造函数,这对抽象类很普遍,因为它没有数据需要初始化. Container有一个析构函数(virtual 的),因为抽象类需要通过引用或者指针来操纵,当我们通过一个指针销毁Container时,并不清楚它的实现部分到底拥有着那些资源. 

抽象类Container只定义了接口,未提供实现,为了令Container有用, 我们必须实现一个定义了接口所需函数的容器. 为此我们可以使用具体类:
```cpp title="vector_container.cpp"
class Vector_container : public Container{
    public:
    Vector_container(int s):v(s){}
    ~Vector_container(){}
    double& operator[](int i) override {return v[i];}
    int size() const override {return v.size();}
    private:
    Vector v;
};
```

:public可读作派生于或者子类型. 我们说类vector_container派生于(derived)类Container,而类Container是类Vector_container的基类(base). 基类和派生类的使用通常叫做继承(inheritance);

我们称成员`operator[]()`和`size()`覆盖(override)了基类Container中的对应成员. 我们使用了显示的override来清楚的说明意图. 这是可选的. 但使用显示说明编译器能捕获错误, 例如错误拼写了函数的名字或是virtual函数及意图覆盖他的版本类型有微小差异. 显式使用override在较大的类层次中尤其有用. 因为如果不使用的话很难知道那个函数应该覆盖哪个. 

析构函数覆盖了基类析构函数. 成员的析构函数~Vector()被其所属类的析构函数~Vector_container()隐式调用. 


### 虚函数

虚函数表vtbl


## class hierarchy


```cpp title="类的继承"
class Shape{
    public:
    virtual Point center() const = 0; //纯虚函数
    virtual void move(Point to) = 0;

    virtual void draw() const = 0;
    virtual void rotate(int angle) = 0;

    virtual ~Shape(){} //destructor
};
```

这个接口自然是一个抽象类. 对于每种shape来说,除了vtbl指针的位置外,表示的各不相同. 

```cpp title="rotate_all.cpp"
void rotate_all(vector< Shape* >& v, int angle){
    for(auto p:v) p -> rotate(angle);
}
```

为了定义一种具体的形状,首先必须指明它是一个Shape, 然后在规定其特有的属性:
```cpp title="circle.cpp"
class Circle: public Shape {
    public:
    Circle(Point p, int rad); //constructor
    Point center()const override {
        return x;
    }
    void move(Point to) const override {
        x = to;
    }

    void draw() const override;
    void rotate(int) const override{}
    private:
    Point x;
    int r;
};
```

继续构造:
```cpp title="smiley.cpp"
class Smiley: public Circle{
    public:
    Smiley(Point p, int rad):Circle{p,r},mouth{nullptr}{}
    ~Smiley(){
        delete mouth;
        delete[](eyes);
    }

    void move(Point to) override;
    void draw() const override;
    void rotate(int) override;
    void add_eye(Shape* s){
        eyes.push_back(s);
    };
    void set_mouth(Shape* s);
    virtual void wink(int i); //眨眼数i

    private:
    vector<Shape*> eyes; //通常有两只眼
    Shape* mouth;
}
```

现在可以调用Smiley的基类的draw()及其成员的draw()来定义Smiley::draw():

```cpp title="draw"
void Smiley::draw()  const {
    Circle::draw();
    for(auto p : eyes) p -> draw();
    mouth -> draw();
}
```

Shape的destructor是一个虚函数, Smiley的destructor覆盖了它. 

:::success 类层次结构的好处
1. 接口继承: 派生类对象可以用在任何要求基类对象的地方,即基类担当了派生类接口的角色
2. 实现继承:积累负责提供可以简化派生类实现的函数或者数据.

:::


```cpp title="从输入流读入描述形状的数据并构造对应的Shape"
enum class kind {circle,triangle,smiley};
Shape* read_shape(istream& is){
    //...从输入流is中读入形状描述信息,找到形状类别k 
    switch(k) {
        case kind.circle:
        return new Circle{p,r};
        case kind.triangle:
        return new Triangle{p1,p2,p3};
        case kind.smiley:
        Smiley* ps = new Smiley{p,r};
        ps -> add_eye(e1);
        ps -> add_eye(e2);
        ps -> set_mouth(m);
        return ps;
    }
};
```

程序使用函数的方式如下:

```cpp title="user.cpp"
void user(){
    std::vector<Shape*> v;
    while(cin) v.push_back(read_shape(cin));
    draw_all(v); //对每个元素调用draw
    rotate_all(v,45); //对每个元素旋转45度
    for(auto p:v) delete p; //删除元素
}
```

### 层次漫游

read_shape()返回shape*指针,从而我们可以按相似的方式处理所有的Shape. 但是如果我们想使用只有某个特定派生类才提供的成员函数,比如smiley_wink(),则可以使用dynamic_cast运算符询问"这个Shape是Smiley吗". 

```cpp title="dynamic_cast"
Shape * ps {read_shape(cin)};
if (Smiley *p = dynamic_cast<Smiley*>(ps)){
    // ps指向一个Smiley 则是Smiley使用它
}else{
    //不是Smiley
}
```

如果在运行时dynamic_cast的参数所指向对象的类型不是期望的类型或其派生类,则dynamic_cast返回nullptr. 

如果我们认为指向不同派生类对象的指针是合法参数,就可以对指针类型使用dynamic_cast,然后检查结果是否是nullptr. 

如果我们不能接收不同类型,可以简单的对引用类型使用dynamic_cast, 如果对象不是与其类型,dynamic_cast会抛出一个bad_cast异常. 

```cpp title="refs & dynamic_cast"
Shape* ps {read_shape(cin)};
Smiley& r {dynamic_cast<Smiley*>(*ps)}; //要在某处捕捉std::bad_cast
```

### 避免资源泄露

在自由存储上分配的对象的指针是危险的. 我们不应该用一个普通老式的指针来表示所有权. 

```cpp title="user"
void user(int x){
    shape* p = new Circle{Point{0,0},10};
    //...
    if(x < 0) throw Bad_x{}; //存在潜在危险
    if(x == 0) return;   //存在潜在危险
    //...
    delete p;
}
```

除非x是整数,否则这段代码就会发生泄漏. 将new的结果赋予一个裸指针就是自找麻烦. 这种问题的一个简单解决方案是:如果需要释放资源则不要使用裸指针,而是用标准库unique_str;

```cpp title="unique_ptr"
class Smiley : public Circle{
    //...
    private:
    vector<unique_ptr<Shape>> eyes;
    unique_ptr<Shape> mouth;
}
```

这是一个简单,通用,高效的资源管理技术的例子. 

这一改变有一个令人愉快的副作用. 我们不在需要为Smiley定义析构函数. 编译器会隐式生成一个析构函数. 它会对vector中的unique_ptr进行所需要的析构操作. 使用unique_ptr的代码与正确使用裸指针的代码具有完全相同的效率.

现在我们考虑read_shape()的使用者. 

```cpp title="read_shape.cpp"
unique_ptr<Shape> read_shape(istream& is){
    //... 从is中读取性状描述信息,找到形状的类别k
    switch(k){
        case Kind::circle:
        //读取circle数据point,int到p和r
        return unique_ptr<Shape>{new Circle{p,r}}
        //...
    }
}

void user(){
    vector<unique_ptr<Shape>> v;
    while(cin)
    v.push_back(read_shape(cin));
    draw_all(v);
    rotate_all(v,45);
}//所有形式被隐式销毁
```