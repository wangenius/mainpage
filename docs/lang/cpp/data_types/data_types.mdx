# datatypes

All variables use data type during declaration to restrict the type of data to be stored. Therefore, we can say that data types are used to tell the variables the type of data they can store. Whenever a variable is defined in C++, the compiler allocates some memory for that variable based on the data type with which it is declared. Every data type requires a different amount of memory. 

C++ supports a wide variety of data types and the programmer can select the data type appropriate to the needs of the application. Data types specify the size and types of values to be stored. However, storage representation and machine instructions to manipulate each data type differ from machine to machine, although C++ instructions are identical on all machines.


## primary

1. Integer
2. Character
3. Boolean
4. Floating Point
5. Double Floating Point
6. Void
7. Wide Character

## Derived

1. Function
2. Array
3. Pointer
4. Reference

## user defined

1. Class
2. Structure
3. Union
4. Enum
5. Typedef

##  Type Modifiers

Modifiers are used in C++ to change or give extra meaning to already existing data types. Itâ€™s added to primitive data types as a prefix to change their meaning. A modifier is used to change the meaning of a basic type so that it better matches the requirements of different circumstances.

Following are the C++ data type modifiers:

* signed
* unsigned
* short
* long

## Type Conversion

A type cast is basically a conversion from one type to another. There are two types of type conversion:

### Implicit Type Conversion 
automatic type conversion
1. Done by the compiler on its own, without any external trigger from the user.
2. Generally takes place when in an expression more than one data type is present. In such condition type conversion (type promotion) takes place to avoid lose of data.
3. All the data types of the variables are upgraded to the data type of the variable with largest data type.
4. It is possible for implicit conversions to lose information, signs can be lost (when signed is implicitly converted to unsigned), and overflow can occur (when long long is implicitly converted to float).

```
bool -> char -> short int -> int -> 
unsigned int -> long -> unsigned -> 
long long -> float -> double -> long double
```

```cpp
#include <iostream> 
using namespace std; 
  
int main() 
{ 
    int x = 10; // integer x 
    char y = 'a'; // character c 
  
    // y implicitly converted to int. ASCII 
    // value of 'a' is 97 
    x = x + y; 
  
    // x is implicitly converted to float 
    float z = x + 1.0; 
  
    cout << "x = " << x << endl 
         << "y = " << y << endl 
         << "z = " << z << endl; 
  
    return 0; 
} 
```

```text title="output"
x = 107
y = a
z = 108
```

### Explicit Type Conversion
This process is also called type casting and it is user-defined. Here the user can typecast the result to make it of a particular data type. In C++, it can be done by two ways:
#### Converting by assignment
This is done by explicitly defining the required type in front of the expression in parenthesis. This can be also considered as forceful casting. Syntax: 
```cpp
#include <iostream> 
using namespace std; 
  
int main() 
{ 
    double x = 1.2; 
  
    // Explicit conversion from double to int 
    int sum = (int)x + 1; 
  
    cout << "Sum = " << sum; 
  
    return 0; 
} 
```

```text title="output"
Sum = 2
```
#### Conversion using Cast operator
A Cast operator is an unary operator which forces one data type to be converted into another data type. C++ supports four types of casting:
1. Static Cast
2. Dynamic Cast
3. Const Cast
4. Reinterpret Cast

```cpp
#include <iostream> 
using namespace std; 
int main() 
{ 
    float f = 3.5; 
  
    // using cast operator 
    int b = static_cast<int>(f); 
  
    cout << b; 
} 
```


```text title="output"
3
```