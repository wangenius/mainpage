---
title: Grammar
sidebar_position: 2
slug: Grammar
---

# Grammar

## programming

```cpp title="minimum programming"
int main(){}
```

`{}`指出函数的边界。
`//`行注释

每个c++程序有且只有一个名为main的全局函数。它是程序的起点。如果main返回一个`int`类型的值，是程序返回给系统的值。main()不返回任何值,系统同样会收到一个表示程序成功完成的值.main()返回非零值表示程序执行失败.

```cpp
#include <iostream>

int main(){
    std::cout << "Hello world!\n";
}
```

`<<`输出符号,它的第二个参数写入第一个参数中. 在这个例子中,字符串字面值"Hello world!\n"被写入标准输出流std::cout.

std::指出名字cout可在标准库名字空间中找到.

```cpp
#include <iostream>

using namespace std;

double square(double x) { return x*x}

void print_square(double x) {
    cout << "square of " << x << "is" << square(x) << "\n";
}

int main() {
    print_square(1.234);
}
```

## function

### 声明

```cpp
Elem* next_elem();
void next_elem(int);
double next_elem(double);
```

> 函数声明也可以包含参数名。有助于读者理解程序的含义。但实际上，除非该声明同时也是函数的定义。否则编译器会简单忽略参数名。

```cpp
double get(const vector<double>& vec,int index);
//
```

### member functions in class

```cpp
char& String::operator[](int index);
```

### function overloading

函数重载:如果程序中存在名字相同但参数类型不同的函数,则编译器会为每次调用选择最恰当的版本.

```cpp
void print(int);
void print(double);
void print(string);

void user(){
    print(42);
    print(9.65);
    print("hello world");
}
```

## type and variables

一个声明declaration就是一条语句.为程序引入一个实体,并为该实体指明类型:

1. 类型type:定义了一组可能的值及一组(对象上的)操作
2. 对象object:存放某种类型值的内存空间
3. 值value:二进制位,具体的含义由其类型决定
4. 变量variable:命名的对象

### init

初始化:在使用对象之前,必须给它赋一个值.

```cpp
double d1 = 1.0;
double d2 {1.0};
double d3 = {1.0};
complex<double> z = 1;//标量为双精度浮点数的复数
vector<int> v {1,2,3,4,5,6}; //整数向量
```

:::success
`{}`可以避免在类型转换中丢失原有信息,即避免收缩转换.
:::

没有特殊理由需要显式指定数据类型,可以使用auto关键字.

```cpp
auto x = 2;
```

## life cycle

声明语句将一个名字引入到了一个作用域中:

1. 局部作用域local scope: 声明在函数或者lambda内的名字叫做局部名字.局部名字的作用域从声明它的地方开始,到声明语句所在的块的末尾位置,界限是`{}`. 函数的参数也属于局部名字.
2. 类作用域class scope: 如果一个名字定义在一个类中,且位于恩赫的函数,lambda,enum class之外,称为成员名字. 作用域从包含它的声明的起始`{`开始,到该声明结束为止.
3. 名字空间作用域namespace scope: 如果一个名字定义在一个名字空间内,同时位于任何函数,lambda,类,enum class之外,称为名字空间成员名字. 他的作用域从其声明位置开始,到名字空间结束为止.
4. 声明在所有结构之外的名字称为全局名字,称为它位于在全局名字空间中.

此外对象也可以没有名字.

```cpp
vector<int> vec;
struct Record {
    string name;
}

void function(int arg){
    string motto {"Who dares wins"};
    auto p = new Record{"wangenius"};
};
```

## constant variables

1. const用于说明接口,使得在用指针和引用将数据传递给函数时就不必担心数据会被改变了. 编译器强制执行const做出承诺.
2. constexpr编译时求值. 用于说明常量,允许将数据置入只读内存中来提升性能. 必须编译器计算.

```cpp
constexpr int dmv = 17; //dmv is a constant
int var = 17; //var is not a constant
const double sqv = sqrt(var); //sqv is a constant

double sum(const vector<double>&); // sum won't change its arg's value

vector<double> v {1.2,3.4,4.5}; //v is not a constant
const double s1 = sum(v); //✔sum在运行时求值
constexpr double  s2 = sum(v); //❌ sum v不是常量表达式
```

如果某个函数被用在常量表达式中,即该常量表达式在编译时求值,则这个函数必须定义为constexpr:

```cpp
constexpr double square(double x){
    return x*x;
}
constexpr double max1 = 1.4 * square(17); //✔
constexpr double max2 = 1.4 * square(var); //❌
const double max3 = 1.4 * square(var); //✔
```

constexpr函数可以接受非常量参数,但此时其结果不再是一个常量表达式. 当程序的上下文不要求常量表达式时, 我们可以使用非常量表达式参数来调用constexpr函数,这样就不用将本来相同的函数定义两次了:一次用于常量表达式,一次用于变量.

想要定义constexpr函数必须非常简单. 无副作用且仅使用通过参数传递的信息.特别是函数不能更改非局部变量,但可以包含循环以及使用自己的局部变量.

```cpp
constexpr double nth(double x,int n){
    double res = 1;
    int i = 0;
    while(i < n){
        res *= n;
        ++i;
    }
    return res;
}
```

## pointer reference

数组声明:

```cpp
char var[6]; //含有6个字符的数组
```

指针声明:

```cpp
char* p; //指向字符的指针

char * p = &v[3]; // p指向v的第4个元素
char x = *p; //*p是p指向的对象
```

## 数组

```cpp
void print(){
    int v[] = { 0, 1, 2, 3, 4, 5, 6, 7};
    for(auto x : v)  // 对于v中的每一个x执行
        cout << x << '\n';
}

void increment(){
    int v[] = { 0, 1, 2, 3, 4, 5};
    for(auto& x : v)
    ++x;
}
```

在声明语句中,一元后置运算符&表示"...的引用". 引用类似于指针,唯一的区别是我们语序使用前置运算符*访问所引用的值. 而且一个引用在初始化就不能再引用其他对象了. 
当指定函数的参数时,引用特别有用:

```cpp
void sort(vector<double>& v); //排序v(v是一个double类型的向量)
```
通过使用引用,我们保证在调用sort(my_vec)时不会拷贝my_vec,从而真正对my_vec进行排序而不是对其副本进行排序. 

还有一种情况,我们不想改变实参,有希望避免参数拷贝的代价,此时应该使用const 引用.

```cpp
double sort(const vector<double>&);
```

函数接收const引用类型的参数是非常普遍的. 

用于声明语句的运算符(&,*,[])称为声明运算符declarator operator. 

### nullptr

当确实没有对象可以指向或者需要表示没有对象可用的概念时,我们赋予指针值nullptr(空指针),所有指针类型都共享同一个nullptr. 

```cpp 
double* pd = nullptr;
Link<Record>* lst = nullptr;
int x = nullptr; //wrong!! nullptr is a pointer not a integer 
```

接收一个指针实参时,检查一下它是否指向某个东西时通常是一种明智的做法. 

```cpp title="统计x在p中出现的次数,假定p指向一个以0结尾的字符数组"
int count(const char* p, char x){
    if(p == nullptr) return 0;
    int count = 0;
    for (;*p!= 0;++p)
        if(*p == x) ++count;
    return count;
}
//或者
int count_2(const char* p,char x){
    if(p == nullptr) return 0;
    while(*p){
        if(*p==x) ++count;
        ++p;
    }
    return count;
}
```

## check

C++提供了一套用于表达选择和循环结构的常规语句. 如if,switch,while,for等. 
```cpp
bool _if(){
    cout << "do you want to preceed (y/n): \n";
    char answer = 0;
    cin >> answer;
    if(answer == 'y') return true;
    return false;
}

bool _switch(){
    cout << "do you want to preceed (y/n): \n";
    char answer = 0;
    cin >> answer;
    switch(answer) {
        case 'y':
        return true;
        case 'n':
        return false;
        default:
        cout << "I'll take that for a no.\n";
        return false;
    }
}
```
switch语句检验一个值是否存在于一组常量中,这些常量被称为case标签,彼此之间不能重复,如果待检验的值不等于任何case分支,则执行default分支. 如果没有提供default分支,则什么也不做. 

在switch语句中如果想退出某个case分支,不必从当前函数返回,通常我们只是希望继续执行switch语句后面的语句,为此只需使用一条break语句.
```cpp 


```


## mapping to hardware


不同对象引用相同的共享值:
```cpp
int x = 2;
int y = 3;
int* p = &x;
int* q = &y; //现在p!=q且*p!=*q;
p = q; // p变成了&y,现在p==q,因此 *p == *q;
```

这段代码的下效果:

![](/res/d__wangenius.github.io_static_template.png)

引用和指针都是引用/指向一个对象,在内存中都表示为一个机器地址. 但是使用他们的语言规则是不同的.给一个引用复制不会改变它引用了什么,二是给他引用的对象赋值.

```cpp
int x = 2;
int y = 3;
int &r = x;
int &r2 = y;
r = r2;//从r2读取值,写入r中:x变为3
```
这段代码的效果:

![](/res/d2__wangenius.github.io_static_template.png)

### 初始化

初始化和赋值不同,一般而言,正确执行赋值之后,被赋值对象必须有一个值,而另一方面,初始化的任务是讲一段未初始化的内存变成一个合法的对象. 对几乎所有的类型来说,读写一个未初始化的变量的结果都是未定义的. 对内置类型来说, 这个问题对引用来说更为明显. 
```cpp
int x = 7;
int& r {x}; //将r绑定到x(r引用x)
r = 7; // 给r引用的对象赋值
int& r2; // 错误:未初始化的引用
r2 = 99; // 给r2引用的对象赋值
```
幸运的是,我们不能使用一个未初始化的引用. 如果可以的话,r2=99就会将99赋予某个未指定的内存位置. 这最终可能导致糟糕的结果或者程序奔溃. 

你可以使用一个=初始化一个引用,但不要被这种形式迷惑. 

```cpp 
int& r = x;
```
这仍然是一个初始化操作,将r绑定到x,而不是任何形式的值拷贝.
