# template


模板是一个类或者一个函数，我们用一组类型或值对其进行参数化。 我们用模板表示那些最好理解为通用事务的概念. 然后通过指定参数(例如vector指定元素类型是double)生成特定的类型.

## 参数化类型

对于之前使用的双精度浮点数向量, 只要将其改成template并且用一个类型参数替换特定类型的double,就能将其泛化.


```cpp
template <typename T>
class Cluster {
private:
    T* it;
    int its_num;
public:
    explicit Cluster(int s);
    ~Cluster(){ delete[] it; };

    //cope and move
    T& operator[](int i);
    const T& operator[](int i) const;
    int size() const { return its_num;}
}

template <typename T>
Cluster<T>::Cluster(int s){
    if(s < 0) throw Negative_size{};
    it = new T[s];
    its_num = s;
}

template <typename T>
const T& Vector<T>::operator[](int i) const {
    if(i < 0 size() <= i) throw out_of_range{"Vector::operator[]"};
    return elem[i];
}
```


前缀`template<typename T>`指出T是该声明的参数. 它是数学上对所有类型T成立的更精确的C++表达.

```cpp
Cluster<char> vc(200);
Cluster<string> vc(17);
Cluster<int> vc(45);
```

类似的也能将列表,向量,映射(关联数组),无序映射(哈希表)等定义成模板.

模板是一种编译时机制, 因此与人工打造的代码相比,不会产生任何额外的运行时开销.

一个模板加上一组模板实参被称为一个实例化(instantiation/specialization). 在编译过程中靠后的实例化时间, 编译器为程序中用到的每一个实例生成相应的代码. 对生成的代码会进行类型检查.使得生成的代码和手写的代码是一样安全.

### 约束模板参数(C++20)

```cpp
template <Element T>
class Cluster{
    private:
    T* items;
    int size;
}
```

Element是一个谓词, 检查T是否具有Vector要求的所有性质. 这种谓词叫做概念. 概念所说明的模板参数叫做约束参数. 参数约束的的模板叫做约束模板

```cpp
Cluster<int> c;
Cluster<thread> v; //错误我们不能拷贝一个标准线程
```

### 值模板参数

```cpp
template <typename T, int N>
struct Buffer{
    using value_type = T;
    constexpr int size() {return N};
    T[N]
};
```

其中别名value_type和constexpr函数的目的是令用户可以只读地访问模板参数.
值参数在很多场景下非常有用. 我们可以用buffer创建任意大小地缓冲区,而不必使用动态内存.

```cpp
Buffer<char,1024> glob; //全局字符缓冲区(静态分配)

void fct(){
    Buffer<int,10> buf; //局部地整数缓冲区, 在栈上
}
```



### 模板参数推断

## 参数化操作

模板地用途远不止用元素类型参数化容器. 特别是模板广泛用于参数化标准库中的类型和算法

### 函数模板

### 函数对象
一个可以携带数据并像函数一样调用的对象

### lambda表达式

函数对象的简写形式

## 模板机制

### 可变参数模板

### 别名

### 编译时if