---
title : 联合和枚举
sidebar_position : 4
slug : 联合和枚举
---
# 联合和枚举

## union

联合是一种特殊的struct,它的所有成员被分配在同一块内存区域中,因此联合实际占用的空间就是它最大的成员所占的空间. 自然在某个时刻,一个union中只能保存一个成员的值.

```cpp title="union保存"
enum Type {ptr,num}; // 一个Type可以保存值的ptr和num
struct Entry{
    string name; // string是一个标准库类型
    Type t; 
    Node* p;//如果t==ptr, 则使用ps
    int i;//如果t==num,则使用i
};

void f(Entry* pe){
    if(pe -> t == num){
        cout << pe -> i;
    } 
};
```

因为p和i永远不会同时使用,所以浪费了内存空间.通过将两者定义为一个union成员,可以很容易的解决问题


```cpp title="union"
union Value{
    Node* p;
    int i;
};
```
C++不会记录一个union保存了那种值,因此程序员必须自己做这个工作:
```cpp title="union和结构"
struct Entry {
    string name;
    Type t;
    Value v;
};

void f(Entry* entry){
    if(pe->t == num)
        cout << pe -> v.i;
}
```

维护类型域(type field,在本例中是t)与union中所存类型的对应关系很容易出错. 为了避免错误,我们可以强制这种对应关系:将联合和类型域分装在一个类中,只允许通过能正确使用联合的成员函数来访问他们. 在应用层面上,以来这种标记联合(tagged union)的抽象很常见也很有用. 我们应该尽量少的使用裸的union. 

在大多数情况下我们可以使用标准库类型variant来避免直接使用union. 一个variant保存一组可选类型中一个类型的值. 例如一个`variant<Node*,int>`可以保存一个Node*或者一个int.

使用variant,Entry的例子可改写为:
```cpp title="variant"
struct Entry {
    string name;
    variant<Node*,int> v;
};

void f(Entry* entry){
    if(holds_alternative<int>(pe->v)) //*pe保存一个int吗
    cout << get<int>(pe->v); //获取一个int
}

```


## enum

:::warning 备注
本文包含 ISO 标准 C++ 语言 enum 类型和 C++11 中引入的范围（或强类型）enum class 类型。 有关 C++/CLI 和 C++/CX 中 public enum class 或 private enum class 类型的详细信息，请参阅 enum class (C++/CLI and C++/CX)。
:::

c++还提供了一种形式简单的自定义类型:enum
```cpp title="enum"
enum class Color {red,blue,green,yellow};
enum class Traffic_light {green,yellow,red};

Color col = Color::red;
Traffic_light traffic = Traffic_light::red;
```

枚举值位于enum class的作用域之内, 因此我们可以在不同的enum class中重复使用这些枚举值而不至于引起混淆. 例如Color::red和Traffic_light::red显然不是一个东西

```cpp title="初始化和赋值"
Color x = red; //wrong! which red?
Color y = Traffic_light::red; // wrong! this red is not that red;
Color z = Color::red; // correct!

int i = Color::red; // wrong!

Color c = 2; // wrong! 2 is not a Color
Color x = Color{5}; // correct! but a little verbose
Color y {6}; // correct!
```

