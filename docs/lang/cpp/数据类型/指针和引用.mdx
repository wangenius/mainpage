---
title : 指针和引用
sidebar_position : 3
slug : 指针和引用
---
# 指针和引用


## 指针
指针声明:

```cpp
char* p; //指向字符的指针

char * p = &v[3]; // p指向v的第4个元素
char x = *p; //*p是p指向的对象
```
### nullptr

当确实没有对象可以指向或者需要表示没有对象可用的概念时,我们赋予指针值nullptr(空指针),所有指针类型都共享同一个nullptr. 

```cpp 
double* pd = nullptr;
Link<Record>* lst = nullptr;
int x = nullptr; //wrong!! nullptr is a pointer not a integer 
```

接收一个指针实参时,检查一下它是否指向某个东西时通常是一种明智的做法. 

```cpp title="统计x在p中出现的次数,假定p指向一个以0结尾的字符数组"
int count(const char* p, char x){
    if(p == nullptr) return 0;
    int count = 0;
    for (;*p!= 0;++p)
        if(*p == x) ++count;
    return count;
}
//或者
int count_2(const char* p,char x){
    if(p == nullptr) return 0;
    while(*p){
        if(*p==x) ++count;
        ++p;
    }
    return count;
}
```
## 引用


引用（Reference）是 C++语言相对于 C语言的又一个扩充，类似于指针，只是在声明的时候用&取代了\*。

引用可以看做是被引用对象的一个别名，在声明引用时，必须同时对其进行初始化。引用的声明方法如下：
```cpp
类型标识符 &引用名 = 被引用对象;
```

```cpp
int a = 10;
int &b = a;
cout << a << " " << b << endl;
cout << &a << " " << &b << endl;
```

```text title="output"
10 10
0018FDB4 0018FDB4
```

从这段程序中我们可以看出，变量 a 和变量 b 都是指向同一地址的，也即变量 b 是变量 a 的另一个名字，也可以理解为 0018FDB4 空间拥有两个名字：a 和 b。

由于引用和原始变量都是指向同一地址的，因此通过引用也可以修改原始变量中所存储的变量值，如例 2 所示。

### 常引用(不可变引用)

如果我们不希望通过引用来改变原始变量的值时，我们可以按照如下的方式声明引用：
```cpp 
const 类型标识符 & 引用名 = 被引用的变量名;

int a = 10;
const int &b = a;
b = 20;   //compile error
a = 20;
```

### 函数引用参数

如果我们在声明或定义函数的时候将函数的形参指定为引用，则在调用该函数时会将实参直接传递给形参，而不是将实参的拷贝传递给形参。如此一来，如果在函数体中修改了该参数，则实参的值也会被修改。这跟函数的普通传值调用还是有区别的。

### 函数引用返回值

在 C++ 中，非 void 型函数需要返回一个返回值，类似函数形参，我们同样可以将函数的返回值声明为引用。普通的函数返回值是通过传值返回，即将关键字 return 后面紧接的表达式运算结果或变量拷贝到一个临时存储空间中，然后函数调用者从临时存储空间中取到函数返回值。

当我们将函数返回值声明为引用的形式时，中间没有经过拷贝给临时空间，再从临时存储空间中拷贝出来的这么一个过程。这就是普通的传值返回和引用返回的区别。

```cpp title="函数返回值的作用域"
int & valplus(int &a)
{
    a = a + 5;
    return a;
}; //在返回时可以存在

int & valplus(int a)
{
    int b = a+5;
    return b; //获取不到返回值
};
```


## mapping to hardware

不同对象引用相同的共享值:
```cpp
int x = 2;
int y = 3;
int* p = &x;
int* q = &y; //现在p!=q且*p!=*q;
p = q; // p变成了&y,现在p==q,因此 *p == *q;
```

这段代码的下效果:

![](/res/d__wangenius.github.io_static_template.png)

引用和指针都是引用/指向一个对象,在内存中都表示为一个机器地址. 但是使用他们的语言规则是不同的.给一个引用复制不会改变它引用了什么,二是给他引用的对象赋值.

```cpp
int x = 2;
int y = 3;
int &r = x;
int &r2 = y;
r = r2;//从r2读取值,写入r中:x变为3
```
这段代码的效果:

![](/res/d2__wangenius.github.io_static_template.png)

### 初始化

初始化和赋值不同,一般而言,正确执行赋值之后,被赋值对象必须有一个值,而另一方面,初始化的任务是讲一段未初始化的内存变成一个合法的对象. 对几乎所有的类型来说,读写一个未初始化的变量的结果都是未定义的. 对内置类型来说, 这个问题对引用来说更为明显. 
```cpp
int x = 7;
int& r {x}; //将r绑定到x(r引用x)
r = 7; // 给r引用的对象赋值
int& r2; // 错误:未初始化的引用
r2 = 99; // 给r2引用的对象赋值
```
幸运的是,我们不能使用一个未初始化的引用. 如果可以的话,r2=99就会将99赋予某个未指定的内存位置. 这最终可能导致糟糕的结果或者程序奔溃. 

你可以使用一个=初始化一个引用,但不要被这种形式迷惑. 

```cpp 
int& r = x;
```
这仍然是一个初始化操作,将r绑定到x,而不是任何形式的值拷贝.