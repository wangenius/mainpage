# datatypes

All variables use data type during declaration to restrict the type of data to be stored. Therefore, we can say that data types are used to tell the variables the type of data they can store. Whenever a variable is defined in C++, the compiler allocates some memory for that variable based on the data type with which it is declared. Every data type requires a different amount of memory. 

C++ supports a wide variety of data types and the programmer can select the data type appropriate to the needs of the application. Data types specify the size and types of values to be stored. However, storage representation and machine instructions to manipulate each data type differ from machine to machine, although C++ instructions are identical on all machines.


## primary

1. Integer
2. Character
3. Boolean
4. Floating Point
5. Double Floating Point
6. Void
7. Wide Character

### ops
对于整数运算对象`<<`左移,`>>`右移. 但对于iostream, 它们分别是输入运算符和输出运算符.

## Derived

1. Function
2. Array
3. Pointer
4. Reference

### array
An Array is a collection of items stored at continuous memory locations. The idea of array is to represent many instances in one variable.
```cpp
DataType ArrayName[size_of_array];
```
```cpp
void print(){
    int v[] = { 0, 1, 2, 3, 4, 5, 6, 7};
    for(auto x : v)  // 对于v中的每一个x执行
        cout << x << '\n';
}

void increment(){
    int v[] = { 0, 1, 2, 3, 4, 5};
    for(auto& x : v)
    ++x;
}
```

在声明语句中,一元后置运算符&表示"...的引用". 引用类似于指针,唯一的区别是我们语序使用前置运算符*访问所引用的值. 而且一个引用在初始化就不能再引用其他对象了. 
当指定函数的参数时,引用特别有用:

```cpp
void sort(vector<double>& v); //排序v(v是一个double类型的向量)
```
通过使用引用,我们保证在调用sort(my_vec)时不会拷贝my_vec,从而真正对my_vec进行排序而不是对其副本进行排序. 

还有一种情况,我们不想改变实参,有希望避免参数拷贝的代价,此时应该使用const 引用.

```cpp
double sort(const vector<double>&);
```

函数接收const引用类型的参数是非常普遍的. 

用于声明语句的运算符(&,*,[])称为声明运算符declarator operator. 
## user defined


> 用基本类型,const修饰符,声明修饰符构造出来的类型称为内置类型`built-in type`. c++的内置类型及其操作非常丰富. 但是没有为程序员提供便于编写高级应用程序的高层设施. 取而代之在内置类型和操作的基础上增加了一套精致的抽象机制,程序员可用它来构造所需的高层设施.
> 即类和枚举.


1. [Class](类和对象)
2. Structure
3. Union
4. Enum
5. Typedef

### struct


```cpp title="结构类型"
struct Vector{
    int size;
    double* elem;
};

Vector v;
```

但是,就v本身而言,用处不大. 因为v的elem指针并没有指向任何东西. 为了让它变得有用, 我们必须给出一些元素,另v指向它们.

```cpp title="构造函数"
void vector_init(Vector& v,int s){
    v.elem = new double[s];
    v.size =s;
}
```

也就是说，v的elem成员被赋予了一个由new运算符生成的指针。而v的size成员则得到了元素的数目。Vector&中的&指出,我们是通过非const引用方式传递v的。这样vector_init()就能修改传给他的向量了。new运算符从一块名为自由存储(又称为动态内存或堆)的区域中分配内存。在自由存储中分配的对象独立于它创建时所处的作用域，会一直存活到使用delete运算符销毁它为止。

```cpp title="从cin读入s个整数,然后返回这些整数的和,假定s是正的"
double read_and_sum(int s){
    Vector v;
    vector_init(v,s);

    for(int i=0;i!= s;++i)
        cin >> v.elem[i];

    double sum = 0;
    for(int i=0;i!= s;++i)
        sum += v.elem[i];
    return sum;
}
```

> 我们自写的和标准库vector有很大差距.所以不要试图重写vector和string等标准库组件. 直接使用它们更加明智.

我们可以通过名字或引用访问struct成员,此时使用`.`,也可以通过指针访问struct成员,此时使用`->`.

##  Type Modifiers

Modifiers are used in C++ to change or give extra meaning to already existing data types. It’s added to primitive data types as a prefix to change their meaning. A modifier is used to change the meaning of a basic type so that it better matches the requirements of different circumstances.

Following are the C++ data type modifiers:

* signed
* unsigned
* short
* long

## Type Conversion

A type cast is basically a conversion from one type to another. There are two types of type conversion:

### Implicit Type Conversion 
automatic type conversion
1. Done by the compiler on its own, without any external trigger from the user.
2. Generally takes place when in an expression more than one data type is present. In such condition type conversion (type promotion) takes place to avoid lose of data.
3. All the data types of the variables are upgraded to the data type of the variable with largest data type.
4. It is possible for implicit conversions to lose information, signs can be lost (when signed is implicitly converted to unsigned), and overflow can occur (when long long is implicitly converted to float).

```
bool -> char -> short int -> int -> 
unsigned int -> long -> unsigned -> 
long long -> float -> double -> long double
```

```cpp
#include <iostream> 
using namespace std; 
  
int main() 
{ 
    int x = 10; // integer x 
    char y = 'a'; // character c 
  
    // y implicitly converted to int. ASCII 
    // value of 'a' is 97 
    x = x + y; 
  
    // x is implicitly converted to float 
    float z = x + 1.0; 
  
    cout << "x = " << x << endl 
         << "y = " << y << endl 
         << "z = " << z << endl; 
  
    return 0; 
} 
```

```text title="output"
x = 107
y = a
z = 108
```

### Explicit Type Conversion
This process is also called type casting and it is user-defined. Here the user can typecast the result to make it of a particular data type. In C++, it can be done by two ways:
#### Converting by assignment
This is done by explicitly defining the required type in front of the expression in parenthesis. This can be also considered as forceful casting. Syntax: 
```cpp
#include <iostream> 
using namespace std; 
  
int main() 
{ 
    double x = 1.2; 
  
    // Explicit conversion from double to int 
    int sum = (int)x + 1; 
  
    cout << "Sum = " << sum; 
  
    return 0; 
} 
```

```text title="output"
Sum = 2
```
#### Conversion using Cast operator
A Cast operator is an unary operator which forces one data type to be converted into another data type. C++ supports four types of casting:
1. Static Cast
2. Dynamic Cast
3. Const Cast
4. Reinterpret Cast

```cpp
#include <iostream> 
using namespace std; 
int main() 
{ 
    float f = 3.5; 
  
    // using cast operator 
    int b = static_cast<int>(f); 
  
    cout << b; 
} 
```


```text title="output"
3
```