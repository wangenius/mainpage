---
title : 算法
sidebar_position : 3
slug : 算法
---
# 算法

在STL中，除了用容器类模板自身提供的成员函数来操作容器元素外，还提供了一系列通用的对容器中元素进行操作的函数模板，称为算法。 
STL 提供了大约 100 个实现算法的模版函数，基本都包含在 `<algorithm>` 之中，还有一部分包含在 `<numeric>` 和 `<functional>`。完备的函数列表请 [参见参考手册](https://zh.cppreference.com/w/cpp/algorithm)，排序相关的可以参考 排序内容的对应页面。
STL算法实现了对序列元素的一些常规操作，用函数模板实现的，主要包括： 

* 调序算法
* 编辑算法
* 查找算法
* 算术算法
* 集合算法
* 堆算法
* 元素遍历算法

除了算术算法在头文件`numeric`中定义外，其它算法都在头文件`algorithm`中定义。

大部分`STL`算法都是遍历指定容器中某范围内的元素，对满足条件的元素执行某项操作。 

算法的内部实现往往隐含着循环操作，但这对使用者是隐藏的。 

1. 使用者只需要提供：容器（迭代器）、操作条件以及可能的自定义操作。
2. 算法的控制逻辑则由算法内部实现，这体现了一种抽象的编程模式。

## 算法和容器的关系

在STL中，不是把容器传给算法，而是把容器的某些迭代器传给它们，在算法中通过迭代器来访问和遍历相应容器中的元素。

这样做的好处是：使得算法不依赖于具体的容器，提高了算法的通用性。 

虽然容器各不相同，但它们的迭代器往往具有相容关系，一个算法往往可以接受相容的多种迭代器。

## 算法接受的迭代器类型

一个算法能接收的迭代器的类型是通过算法模板参数的名字来体现的。例如：

```cpp
template <class InIt, class OutIt>
OutIt copy(InIt src_first, InIt src_last, OutIt dst_first) {...}
```

1. src_first和src_last是输入迭代器，算法中只能读取它们指向的元素。
2. dst_first是输出迭代器，算法中可以修改它指向的元素。
3. 以上参数可以接受其它相容的迭代器。

## 算法的操作范围

用算法对容器中的元素进行操作时，大都需要用两个迭代器来指出要操作的元素的范围。

例如：
```cpp
void sort(RanIt first, RanIt last);
```
first是第一个元素的位置.
last是最后一个元素的下一个位置.

有些算法可以有多个操作范围，这时，除第一个范围外，其它范围可以不指定最后一个元素位置，它由第一个范围中元素的个数决定。例如：
```cpp
OutIt copy(InIt src_first, InIt src_last, OutIt dst_first);
```
一个操作范围的两个迭代器必须属于同一个容器，而不同操作范围的迭代器可以属于不同的容器。

## 算法的自定义操作条件

有些算法可以让使用者提供一个函数或函数对象来作为自定义操作条件（或称为谓词），其参数类型为相应容器的元素类型，返回值类型为bool。

自定义操作条件可分为：

1. Pred：一元“谓词”，需要一个元素作为参数
2. BinPred：二元“谓词”，需要两个元素作为参数

### Pred

```cpp title="一种'统计'算法的使用"
size_t count_if(InIt first, InIt last, Pred cond);

#include <vector>
#include <algorithm>
#include <iostream>
using namespace std;

bool f(int x) { return x > 0; }

int main() 
{
    vector<int> v;
    ...... // 往容器中放了元素
    cout << count_if(v.begin(), v.end(), f); // 统计v中正数的个数
    return 0;
}
```
### BinPred

```cpp
void sort(RanIt first, RanIt last); // 按“<”排序
void sort(RanIt first, RanIt last, BinPred comp); // 按comp返回true规定的次序

#include <vector>
#include <algorithm>
using namespace std;

bool greater2(int x1, int x2) { return x1 > x2; }

int main()
{
    vector<int> v;
    ...... // 往容器中放了元素
    sort(v.begin(), v.end()); // 从小到大排序
    sort(v.begin(), v.end(), greater2); // 从大到小排序
    return 0;
}
```

## 算法的自定义操作

有些算法可以让使用者提供一个函数或函数对象作为自定义操作，其参数和返回值类型由相应的算法决定。

自定义操作可分为：

1. Op或Fun：一元操作，需要一个参数
2. BinOp或BinFun：二元操作，需要两个参数

```cpp title="元素遍历的Op算法"
Fun for_each(InIt first, InIt last, Fun f);

#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

void f(int x) { cout << ' ' << x; }

int main()
{
     vector<int> v;
     ...... // 往容器中放了元素
     for_each(v.begin(), v.end(), f); // 对v中的每个元素去调用函数f进行操作
     return 0;
}
```


```cpp title="二元操作"
T accumulate(InIt first, InIt last, T val); // 按“+”操作
T accumulate(InIt first, InIt last, T val, BinOp op); // 由op决定累积的含义

#include <vector>
#include <numeric>
using namespace std;

int f1(int partial, int x) { return partial 
* x; }
int f2(int partial, int x) { return partial + x 
* x; }
double f3(double partial, int x) { return partial + 1.0 / x; }

int main
{
    vector<int> v;
    ...... // 往容器中放了元素
    
    int sum = accumulate(v.begin(), v.end(), 0); // 所有元素和
    int product = accumulate(v.begin(), v.end(), 1, f1); // 所有元素的乘积
    int sq_sum = accumulate(v.begin(), v.end(), 0, f2); // 所有元素平方和
    int rec_sum = accumulate(v.begin(), v.end(), 0.0, f3); // 元素倒数和
    
    return 0;
}
```

## swap()

很多算法使用swap()函数交换两个对象的值, 特别是sort(); 这类算法通常假定swap()非常快且不会抛出异常. 标准库提供了一个std::swap(a,b)来实现. 他进行了3步操作:`temp = a; a = b; b = temp`. 如果你设计一个类的拷贝代价很高而且有可能被交换, 则应为其提供移动操作和swap(). 

标准库容器和string都具有快速移动操作.

## `hash<>`

标准库`unordered_map<K,V>`是一种哈希表,K是关键字类型,V是值类型. 将类型X用作关键字, 我们必须定义`hash<X>`

## 算法

算法主要由头文件`<algorithm><functional><numeric>`组成

- `<algorithm>` 是所有 STL 头文件中最大的一个，其中常用的功能涉及到比较、交换、查找、遍历、复制、修改、反转、排序、合并等

- `<numeric>` 体积很小，只包括在几个序列容器上进行简单运算的模版函数

- `<functional>` 定义了一些模版类，用以声明函数对象

自定义的类如果想要直接使用算法库，则需补全默认构造函数、拷贝构造函数、析构函数、赋值操作符、小于操作符、等于操作符。

## 常用遍历算法

### for_each

```cpp
/**  
* 遍历算法 遍历容器元素 
* @param beg 开始迭代器 
* @param end 结束迭代器 
* @param _callback 函数回调或者函数对象 
* @return 函数对象
*/ 

for_each(iterator beg, iterator end, _callback);
```


### transform

```cpp
/**  
* transform算法 将指定容器内的元素搬运到另一个容器中 
* 注意：transform不会给目标容器分配内存，所以需要我们提前分配好内存 
* @param beg1 源容器开始迭代器 
* @param end1 源容器结束迭代器 
* @param beg2 目标容器开始迭代器 
* @param _callback 回调函数或者函数对象 
* @return 返回目标容器迭代器 
*/ 
iterator  transform(iterator beg1,  iterator end1,  iterator beg2,  _callback);
```


> 注意：目标容器一定要提前分配好内存。

## 常用查找算法


### find

```cpp
/**  
* find 算法 查找元素 
* @param beg 容器开始迭代器 
* @param end 容器结束迭代器 
* @param value 查找的元素 
* @return 返回查找元素的位置 
*/ 
iterator  find(iterator beg,  iterator end,  value);
```


### find_if

```cpp
/**  
* find_if 算法 条件查找 
* @param beg 容器开始迭代器 
* @param end 容器结束迭代器 
* @param _callback 回调函数或者谓词(返回 bool 类型的函数对象) 
* @return 返回查找元素的位置 
*/ 
iterator  find_if(iterator beg,  iterator end,  _callback);
```


> 利用 find_if 实现自定义类的 find 操作的时候，之前的函数适配器可能会派上用场。

### adjacent_find

```cpp
/**  
* adjacent_find 算法 查找相邻重复元素 
* @param beg 容器开始迭代器 
* @param end 容器结束迭代器 
* @param _callback 回调函数或者谓词(返回 bool 类型的函数对象) 
* @return 返回相邻元素的第一个位置的迭代器 
*/ 
iterator  adjacent_find(iterator beg,  iterator end,  _callback);
```


### binary_search

```cpp
/**  
* binary_search 算法 二分法查找 
* 注意：在无序序列中不可用 
* @param beg 容器开始迭代器 
* @param end 容器结束迭代器 
* @param value 查找的元素 
* @return bool 查找返回true，否则false 
*/ 
bool  binary_search(iterator beg,  iterator end,  value);
```


### count

```cpp
/**  
* count 算法 统计元素出现次数 
* @param beg 容器开始迭代器 
* @param end 容器结束迭代器 
* @param value 待计数的元素 
* @return int 返回元素个数 
*/ 
int  count(iterator beg,  iterator end,  value); 
```


### count_if

```cpp
/**  
* count_if 算法 统计元素出现次数 
* @param beg 容器开始迭代器 
* @param end 容器结束迭代器 
* @param _callback 回调函数或者谓词 
* @return int 返回元素个数 
*/ 
int  count_if(iterator beg,  iterator end,  _callback);
```


## 常用排序算法

### merge

```cpp
/**  
* merge 算法 容器元素合并，并储存到另一个容器中 
* 注意：两个容器必须是有序的 
* @param beg1 容器1开始迭代器 
* @param end1 容器1结束迭代器 
* @param beg2 容器2开始迭代器 
* @param end2 容器2结束迭代器 
* @param dest 目标容器开始迭代器 
*/ 
merge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);
```


### sort

```cpp
/**  
* sort 算法 容器元素排序 
* @param beg 容器开始迭代器 
* @param end 容器结束迭代器 
* @param _callback 回调函数或者谓词 
*/ 
sort(iterator beg, iterator end, _callback);
```


### random_shuffle

```cpp
/**  
* random_shuffle 算法 对指定范围内的元素随机调整次序 
* @param beg 容器开始迭代器 
* @param end 容器结束迭代器 
*/ 
random_shuffle(iterator beg, iterator end);
```


如果想要每次打乱不同，需要自己设置随机数种子：

```cpp
#include  <ctime> 
using  namespace std;   
int  main() {  
    srand((unsigned  int)time(NULL)); ......//random_shuffle 
}
```


### reverse

```cpp
/**  
* reverse 算法 反转指定范围的元素 
* @param beg 容器开始迭代器 
* @param end 容器结束迭代器 
*/ 
reverse(iterator beg, iterator end);
```


## 常用拷贝和替换算法

### copy

```cpp
/**  
* copy算法 将容器内指定范围的元素拷贝到另一容器当中 
* @param beg 容器开始迭代器 
* @param end 容器结束迭代器 
* @param dest 目标容器开始迭代器 
*/ 
copy(iterator beg, iterator end, iterator dest);
```

使用 copy 算法快速打印容器：

```cpp
vector<int> v = {1,  2,  3,  4,  5}; 
for_each(v.begin(),  v.end(), [](int val){cout << val <<  " ";}); // 等价于 
//copy(v.begin(),  v.end(),  ostream_iterator<int>(cout,  " ")); // 需要#include <iterator>
```


> 其实第一种方法已经够用了，不过为了提升一下逼格，不妨也了解一下第二种。

### replace

```cpp
/**  
* replace算法 将容器内指定范围的旧元素修改为新元素 
* @param beg 容器开始迭代器 
* @param end 容器结束迭代器 
* @param oldvalue 旧元素 
* @param newvalue 新元素 
*/ 
replace(inerator beg, iterator end, oldvalue, newvalue);
```


### replace_if

```cpp
/**  
* replace_if 算法 将容器内指定范围满足条件的元素替换为新元素 
* @param beg 容器开始迭代器 
* @param end 容器结束迭代器 
* @param _callback 回调函数或者谓词（返回bool类型的函数对象） 
* @param newvalue 新元素 
*/ 
replace_if(inerator beg, inerator end, _callback, newvalue);
```


### swap

```cpp
/**  
* swap 算法 互换两个容器元素 
* @param c1 容器1 
* @param c2 容器2 
*/ 
swap(container c1, container c2);
```


## 常用算数生成算法

### accumulate

```cpp
#include  <numeric>  // 注意头文件不是algorithm了 
/**  
* accumulate 算法 计算容器元素累计总和 
* @param beg 容器开始迭代器 
* @param end 容器结束迭代器 
* @param value 起始累加值 
*/ 
accumulate(iterator beg, iterator end, value);
```


### fill

```cpp
/**  
* fill 算法 
* @param beg 容器开始迭代器 
* @param end 容器结束迭代器 
* @param value 填充元素 
*/ 
fill(iterator beg, iterator end, value);
```


## 常用集合算法

### set_intersection

```cpp
/**  
* set_intersection 算法 求两个set集合的交集 
* 注意：两个集合必须是有序序列 
* @param beg1 容器1开始迭代器 
* @param end1 容器1结束迭代器 
* @param beg2 容器2开始迭代器 
* @param end2 容器2结束迭代器 
* @param dest 目标容器开始迭代器 
* @return 目标容器最后一个元素的迭代器地址 
*/ 
set_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);
```


### set_union

```cpp
/**  
* set_union 算法 求两个set集合的并集 
* 注意：两个集合必须是有序序列 
* @param beg1 容器1开始迭代器 
* @param end1 容器1结束迭代器 
* @param beg2 容器2开始迭代器 
* @param end2 容器2结束迭代器 
* @param dest 目标容器开始迭代器 
* @return 目标容器最后一个元素的迭代器地址 
*/ 
set_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);
```


### set_difference

```cpp
/**  
* set_difference 算法 求两个set集合的差集 
* 注意：两个集合必须是有序序列 
* @param beg1 容器1开始迭代器 
* @param end1 容器1结束迭代器 
* @param beg2 容器2开始迭代器 
* @param end2 容器2结束迭代器 
* @param dest 目标容器开始迭代器 
* @return 目标容器最后一个元素的迭代器地址 
*/ 
set_difference(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);
```


find：顺序查找。find(v.begin(), v.end(), value)，其中 value 为需要查找的值。

reverse：翻转数组、字符串。reverse(v.begin(), v.end()) 或 reverse(a + begin, a + end)。

unique：去除容器中相邻的重复元素。unique(ForwardIterator first, ForwardIterator last)，返回值为指向 去重后 容器结尾的迭代器，原容器大小不变。与 sort 结合使用可以实现完整容器去重。

:::success shuffle
random_shuffle 自 C++14 起被弃用，C++17 起被移除。

在 C++11 以及更新的标准中，您可以使用 shuffle 函数代替原来的 random_shuffle。使用方法为 shuffle(v.begin(), v.end(), rng)（最后一个参数传入的是使用的随机数生成器，一般情况使用以真随机数生成器 random_device 播种的梅森旋转伪随机数生成器 mt19937）。
```cpp
#include <random>
std::mt19937 rng(std::random_device{}());
std::shuffle(v.begin(), v.end(), rng);
```
:::


sort：排序。sort(v.begin(), v.end(), cmp) 或 sort(a + begin, a + end, cmp)，其中 end 是排序的数组最后一个元素的后一位，cmp 为自定义的比较函数。

stable_sort：稳定排序，用法同 sort()。

nth_element：按指定范围进行分类，即找出序列中第 n 大的元素，使其左边均为小于它的数，右边均为大于它的数。nth_element(v.begin(), v.begin() + mid, v.end(), cmp) 或 nth_element(a + begin, a + begin + mid, a + end, cmp)。

binary_search：二分查找。binary_search(v.begin(), v.end(), value)，其中 value 为需要查找的值。

merge：将两个（已排序的）序列 有序合并 到第三个序列的 插入迭代器 上。merge(v1.begin(), v1.end(), v2.begin(), v2.end() ,back_inserter(v3))。

inplace_merge：将两个（已按小于运算符排序的）：`[first,middle)`, `[middle,last)` 范围 原地合并为一个有序序列。inplace_merge(v.begin(), v.begin() + middle, v.end())。

lower_bound：在一个有序序列中进行二分查找，返回指向第一个 大于等于 x 的元素的位置的迭代器。如果不存在这样的元素，则返回尾迭代器。lower_bound(v.begin(),v.end(),x)。

upper_bound：在一个有序序列中进行二分查找，返回指向第一个 大于 x 的元素的位置的迭代器。如果不存在这样的元素，则返回尾迭代器。upper_bound(v.begin(),v.end(),x)。

next_permutation：将当前排列更改为 全排列中的下一个排列。如果当前排列已经是 全排列中的最后一个排列（元素完全从大到小排列），函数返回 false 并将排列更改为 全排列中的第一个排列（元素完全从小到大排列）；否则，函数返回 true。next_permutation(v.begin(), v.end()) 或 next_permutation(v + begin, v + end)。

prev_permutation：将当前排列更改为 全排列中的上一个排列。用法同 next_permutation。

partial_sum：求前缀和。设源容器为 x，目标容器为 y，则令 y[i]=x[0]+x[1]+\dots+x[i]。partial_sum(src.begin(), src.end(), back_inserter(dst))。