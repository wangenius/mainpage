---
title: 简介
sidebar_position: 1
slug: 简介
---

# 简介

import { To,Tag } from "@components";

## 历史版本

1. C++98: C++出现
2. C++11: C++正式定稿
3. C++14/17: 重要补充和优化
4. C++20: C++现代化

:::success 现代C++
现代 C++ (指 C++11/14/17/20) 为传统 C++ 注入的大量特性使得整个 C++ 变得更加像一门现代化的语言。现代 C++ 不仅仅增强了 C++ 语言自身的可用性，auto 关键字语义的修改使得我们更加有信心来操控极度复杂的模板类型。同时还对语言运行期进行了大量的强化，Lambda 表达式的出现让 C++ 具有了『匿名函数』的『闭包』特性，而这一特性几乎在现代的编程语言（诸如 Python/Swift/... ）中已经司空见惯，右值引用的出现解决了 C++ 长期以来被人诟病的临时对象效率问题等等。
:::

## 标准C++组成

ISO的C++标准定义了两类实体：

1. 核心语言特性(core language feature),例如变量和常量, 内置类型(如char和int)和循环(如for语句和while语句);
2. 标准库组件(standard-library component),包括C++标准库和标准模版库STL. 比如容器(如vector和map)和I/O操作(如\<\<和getline())。
   1. C++ 标准库，提供了大量的函数，用于操作文件、字符串等。
   2. 标准模板库（STL），提供了大量的方法，用于操作数据结构等。

每个C++实现都提供标准库组件，它们其实也是非常普通的C++代码。换句话说，C++标准库可以用C++语言本身实现(仅在实现线程上下文切换这样的功能时才使用少量机器代码)。这意味着C++在面对大多数高要求的系统编程任务时既有丰富的表达力，同时也足够高效。

:::success ANSI 标准
ANSI 标准是为了确保 C++ 的便携性 —— 您所编写的代码在 Mac、UNIX、Windows、Alpha 计算机上都能通过编译。
由于 ANSI 标准已稳定使用了很长的时间，所有主要的 C++ 编译器的制造商都支持 ANSI 标准。
:::
C++是一种静态类型语言，这意味着任何实体(如对象、值、名称和表达式)在使用时都必须已被编译器了解。对象的类型决定了能在该对象上执行的操作。

## 参考

<To name="cppreference.com" to="https://en.cppreference.com" />
<To name="Awesome C++" to="https://cpp.libhunt.com" />
<To name="learncpp" to="https://www.learncpp.com" />
<To
  name="代码巴士 - 分享有价值的 C/C++ 知识和源代码"
  to="https://codebus.cn/"
/>
<To
  name="C语言与C++学习"
  to="https://github.com/tangtangcoding/C-CppLearning"
/>
<To name="C++ Tutorial" to="https://www.javatpoint.com/cpp-tutorial" />
<To
  name="C++ STL Tutorial"
  to="https://cui-jiacai.gitbook.io/c++-stl-tutorial"
/>


## 竞赛风格指南

利用 C++17。使用 `-Wall -Wextra -Wshadow` 标志进行编译，并尝试消除所有警告消息，这将防止您遇到一些愚蠢的错误。还有更多调试标志，例如 `-fsanitize=undefined` 可帮助您消除运行时数组超出范围访问和整数溢出等错误。有关更多信息，请查看“阅读更多”部分。

C++库对函数和类使用snake_case，为了将用户定义的代码与标准库区分开来，我们将使用 CamelCase。

1. 类型使用 UpperCamelCase： `Point` ， `SegTree`
2. 函数和变量使用 lowerCamelCase： `someMethod` ， `someVariable`
3. 宏和常量使用由以下部分 _ 隔开的所有大写字母： `SOME_MACRO` 、 `MAX_N` 、 `MOD`
4. 使用有意义的名字，或者至少对你来说足够有意义。

使用 `#include <bits/stdc++.h>` 代替许多包含。
使用 `using namespace std;` 而不是 `std::` 每次都键入。
例如，使用 `using` 代替 `typedef` `using ll = long long;` 。基本原理：它更符合现代C++的风格。
使用 `struct` 代替 `class` .基本原理：它默认为公开，您不需要在竞争性编程中封装！
不要使用太多宏，但不要害怕使用宏！基本原理：调试和读取充满丑陋宏的代码并不容易。但我们毕竟是黑客！
用于 `const` 定义常量，而不是 `#define` 。基本原理：常量有一个类型，它们在编译时被计算。
为了避免错误，您可以对每个 `switch` 语句大小写使用大括号。
用于 `auto` 增加可读性并减小代码大小。
使用支撑的初始值设定项列表。
在处理对和元组时使用 `emplace` 和 `emplace_back for` 容器。理由： `(elem1, elem2, ...)` 而不是 `({elem1, elem2, ...})` .
使用 lambda 函数！当将函数作为参数传递时，它们特别有用 sort ，例如 in 。不要重复自己，在代码中使用 lambda 函数而不是复制/粘贴。
用 代替 `nullptr NULL` 或 `0` 。
布尔值是 true 和 false ！
使用 `ios::sync_with_stdio(false);` 和 `cin.tie(nullptr);` 以获得更快的 I/O 使用 cin/cout 。
使用以 `__builtin` 开头的内置函数。
GCD 和 LCM 在 C++17 中可用，位于 gcd 和 lcm 下。
对循环使用 `C++11 for each` 样式。 `for (auto& elem : vec)`
使用 C++17 绑定样式，如 `for (auto& [key, val] : dic)` 和 `auto [x, y] = myPoint;`
使用 C++ 模板参数推导 `pair p{1, 2.5};` 而不是 `pair<int, double> p{1, 2.5}`; .
如果您有很多嵌套循环和条件，请重构！您可能应该使用函数。
切勿使用 goto ！但是，当你想从几个嵌套循环中解脱出来时，要勇敢地使用 goto （以防你无法重构它）！
一些网站（如代码部队）使用标志 -DONLINE_JUDGE 来编译您的代码，这意味着您可以自动删除您的 cerr s 或调试函数，或者将输入/输出重定向到文件而不是 stdin/stdout 等。

### 比如

```cpp
#define all(x) (x).begin(), (x).end()

sort(all(vec));
sort(vec.begin(), vec.end());
sort(1 + all(vec)); // 1 + (x).begin(), (x).end()
```

```cpp
int nxt() {
    int x;
    cin >> x;
    return x;
}

// 未使用nxt
int n, m;
cin >> n >> m;
for (int i = 0; i < m; ++i) {
    int u, v;
    cin >> u >> v;
    --u, --v;
    g[u].push_back(v);
    g[v].push_back(u);
};

//使用nxt
int n = nxt(), m = nxt();
for (int i = 0; i < m; ++i) {
    int u = nxt() - 1, v = nxt() - 1;
    g[u].push_back(v);
    g[v].push_back(u);
}
```

但是，要小心！如果 pts 是点的向量，那么最好按以下方式读取它：

```cpp
for (int i = 0; i < (int)pts.size(); ++i) {
    cin >> pts[i].x >> pts[i].y;
}
```
或至少采用以下 C++ 17 方式：

```cpp
for (auto& [x, y] : pts) {
    cin >> x >> y;
}
```
但不要执行以下操作：

```cpp
for (int i = 0; i < (int)pts.size(); ++i) {
    pts[i] = {nxt(), nxt()};
}
```
因为在最后一个实现中，没有定义调用的 nxt() 顺序。

您也可以更改函数模板的类型 long long ，甚至制作函数模板，但我真的不觉得我需要最后一个。

非常感谢我的前队友 savinov 和 sokian 在 2015 年我加入他们的团队模板中向我介绍了这一点。 nxt() 稍后将在本博客中返回。

### memset & fill

你们中的许多人都知道，如果想用特定字节填充一段内存，他们可以使用 memset .它的速度非常快，可用于用零和负一填充一些（通常是一维）C 阵列。

```cpp
#include <bitset>
#include <climits>
#include <cstring>
#include <iostream>
 
int main()
{
    int a[4];
    using bits = std::bitset<sizeof(int) * CHAR_BIT>;
    std::memset(a, 0b1111'0000'0011, sizeof a);
    for (int ai : a)
        std::cout << bits(ai) << '\n';
}
```

```text title="output"
00000011000000110000001100000011
00000011000000110000001100000011
00000011000000110000001100000011
00000011000000110000001100000011
```

如果你想用一个装满一个容器怎么办？答案就像馅饼一样简单：


```cpp
fill(all(vec), 1);
```

如果你需要用连续的数字来填充它，你可以使用 std::iota .现在，具有两个优化的 Dsu 类的构造函数可能如下所示：

```cpp
int n;
vector<int> parent, rank;

Dsu(int _n): n(_n), parent(_n), rank(_n) {
    iota(all(parent), 0);
}
```
这里 0 表示 *parent.begin() 的值，每个下一个值都是通过预增量从前一个值获得的。


### std::generate
<Tag>C++20</Tag>

如果你有一个 0 元函数（即没有参数）并且想通过它的调用来填充一个范围，而不是编写一个 for 循环，你可以调用 `std::generate` : `vec` 用随机值填充向量（假设它是 rand() 调用）可能看起来像
```cpp
generate(all(vec), rand);
```
我最喜欢的：先读n，然后写n数字

```cpp
int n = nxt();
vector<int> a(n);
generate(all(a), nxt);
```
或者，如果你不需要 later 的 n 值，甚至

```cpp
vector<int> a(nxt());
generate(all(a), nxt);
```
最后三个功能有一个 _n 类似物。而不是结束迭代器/指针， fill_n iota_n 并将 generate_n size 作为第二个参数。因此，如果你想将第一个 n 数字读入一个大于 n 的向量 vec 中，你可以使用
```cpp
generate_n(vec.begin(), n, nxt);
```
而不是更长
```cpp
generate(vec.begin(), vec.begin() + n, nxt);
```

### 从向量构造集合

我们中没有多少人知道，但是如果你想 std::set 从一个向量创建一个，并发现该集合没有向量的构造函数，你可以去写一个带有 ok face 的循环，比如：

```cpp
set<int> S;
for (int x : a) {
    S.insert(x);
}
```
但是， std::set 具有两个迭代器的构造函数，因此可以编写
```cpp
set<int> S(all(a));
```
这实际上是很自然的，人们可以推断出该集合应该有这样的构造函数,我才知道。

### 检查set或map是否有key

```cpp
if (S.find(key) != S.end()) {
    // ...
}
```
但是，set 和 map 有一个 `.count()` 方法，如果键在容器中，则返回 1，否则返回 0：
```cpp
if (S.count(key)) {
    // ...
}
```
之所以这样称呼它并具有 int 类型， `std::multiset` 是因为并且 `std::multimap` 也有这个方法，对于它们，该方法返回元素计数，显然可能超过 1。

当然，如果你需要对元素做一些事情，如果它存在于集合中（例如，擦除它），那么实际调用 .find() 方法以便通过迭代器而不是按元素擦除（因此有点缓存一棵树下降）可能会很有用。

### 多个值的最小值

```cpp
int x = min({a, b, c, d});
```

### 在if语句中引入变量

想象一下：你有一个函数 f() ，它需要时间来计算，如果它的值满足某个条件，你想以某种方式使用它。你不想写

```cpp
if (is_good(f())) {
    use_somehow(f());
}
```
因为它需要两次调用. f 你可以这样写：

```cpp
int x = f();
if (is_good(x)) {
    use_somehow(x);
}
```
但这并不是很干净，并且留下了一个当时未使用的变量，也许在一个可能有用的名称下。为了避免这种情况，可以将所有这些包装成一个块，如下所示：
```cpp
{
    int x = f();
    if (is_good(x)) {
        use_somehow(x);
    }
}
```
但较短的版本将执行以下操作：
```cpp
if (int x = f(); is_good(x)) {
    use_somehow(x);
}
```
这是可能的，因为 C++17。

尽量少使用 using 指示

```cpp
using namespace std;
```
应该多使用 using 声明
```cpp
int x;
std::cin >> x ;
std::cout << x << std::endl;
```
或者

```cpp
using std::cin;
using std::cout;
using std::endl;
int x;
cin >> x;
cout << x << endl;
```