---
title: 声明和初始化
sidebar_position: 1
slug: 声明和初始化
---

# 声明和初始化

声明就是告诉计算机(内存), 我需要存放什么类型的数据, 给我一个"地儿"[^1].

:::success 一个例子
假设你是厨师. 你做不同的菜会用到不同的容器. 比如米饭要用饭碗, 菜品要用菜碟, 红烧鱼要用鱼盘, 铁锅炖要用大铁锅. 你要做饭, 首先得有一个容器来装饭. 而声明的过程, 就是你向你的助手要一个相应的盘子的过程.

而初始化, 就是容器内放实际值的过程. 当你拿到盘子之后, 你就可以选择做什么菜, 然后放进去. 就算同一大小, 不同的碟子盛的菜大概不会相同. 这就是初始化和赋值的过程.
:::

```cpp
int x; // 声明,x是碟子的名称(至少在使用它的块空间中, x可以作为标识这一个碟子的id)
x = 42; // 赋值的过程, 就是往里面装填的过程, 你把鱼香肉丝放了进去. 这个过程你在使用x这个盘子.

auto x = 2; //没有特殊理由需要显式指定数据类型,可以使用auto关键字. 好像你把菜炒好了, 让你的助手根据菜自己决定找个盘子装
```

## 声明 declaration

一个声明就是一条语句.为程序引入一个实体,并为该实体指明类型:

1. 类型type:定义了一组可能的值及一组(对象上的)操作
2. 对象object:存放某种类型值的内存空间
3. 值value:二进制位,具体的含义由其类型决定
4. 变量variable:命名的对象

### 声明范围

:::success 还是那个例子
假如你是厨师, 你的顾客要求打包, 不在你的餐厅就餐. 怎么办?

此时你需要去声明一个可以外带的餐盒.
:::

编译程序时，每个 .cpp 文件都会独立编译为一个编译单元。 编译器不知道在其他编译单元中声明了哪些名称。 这意味着，如果你定义类、函数或全局变量，则必须在使用它的每个附加 .cpp 文件中提供对它的声明。 在所有文件中，对它的每个声明必须完全相同。 当链接器尝试将所有编译单元合并成单个程序时，出现轻微的不一致会导致错误或意外行为。

为了最大程度地减少出错的可能性，C++ 采用了使用头文件来包含声明的约定。 在一个头文件中进行声明，然后在每个 .cpp 文件或其他需要该声明的头文件中使用 #include 指令。 #include 指令在编译之前将头文件的副本直接插入 .cpp 文件中。

## 生命周期

声明语句将一个名字引入到了一个作用域中:

1. 局部声明: 界限是`{}`. 函数的参数也属于局部声明.
2. 类作用域: 变量在一个类中声明(不在类的成员函数中声明). 其作用域和类的实例的作用域相同.
3. 命名空间作用域: 变量声明在一个[命名空间](https://learn.microsoft.com/zh-cn/cpp/cpp/namespaces-cpp?view=msvc-170)内(位于任何函数,lambda,类,enum class之外). 作用域从其声明位置开始,到名字空间结束为止.
4. 声明在所有结构之外的名字称为全局名字,称为它位于在全局名字空间中.

此外对象也可以没有名字.(lambda)

## 分配

:::success 备注
在 C语言中，动态分配和释放内存的函数是 `malloc`、`calloc` 和 `free`，而在 C++语言中，`new`、`new[]`、`delete` 和 `delete[]` 操作符通常会被用来动态地分配内存和释放内存。需要注意的是，`new`、`new[]`、`delete` 和 `delete[]` 是操作符，而非函数。 `new` 和 `delete` 是 C++ 的关键字。
:::

1. `new` 用于动态分配单个空间
2. `new[]` 则是用于动态分配一个数组
3. `delete` 用于释放由 `new` 分配的空间
4. `delete[]` 则用于释放 `new[]` 分配的一个数组。

```cpp
Hero *p = new Hero;  //为 p 指针分配了一个 Hero 型的空间。new 操作符根据请求分配的数据类型来推断所需的空间大小。
Hero *A = new Hero[10]; // 分配了10个连续的Hero地址, A指向首地址;
```

为了避免内存泄露, `new`、`new[]`、`delete` 和 `delete[]` 都是成对出现.

# 初始化

初始化:在使用对象之前,必须给它赋一个值. 很简单的理解, 要吃饭, 首先得有饭. 从这个角度理解对象: 初始化后的变量.

```cpp
double d1 = 1.0;
double d2 {1.0};
double d3 = {1.0};
complex<double> z = 1;
vector<int> v {1,2,3,4,5,6};
```

:::success 为什么使用`double d2 {1.0};` 这种方式去初始化?
`{}`可以避免在类型转换中丢失原有信息,即避免收缩转换.
:::

### 用户定义字面量

对于内置类型,我们可以声明字面值:

```cpp
int x = 123;
unsigned int y = 0xFF00u;
double z = 123.456;
const char[10] = "Surprise!";

#<string>
#<chrono>
#<complex>

std::string x = "Surprise!"s;
second y = 1.2s;
complex t = 12.5i + 1.2;
```

[^1]: 如何理解"地儿", 丁垚老师在中国建筑史上讲过, 有兴趣可以去上网搜一下, 也许会有.
