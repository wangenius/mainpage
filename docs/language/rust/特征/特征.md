类似于OOP的 interface {}, 定义了一组可以被共享的行为，只要实现了特征，你就能使用这组行为

如果不同的类型具有相同的行为，那么我们就可以定义一个特征，然后为这些类型实现该特征。

定义 Trait

```Rust
pub trait Person{
  fn say(&self) -> String;
}
```

## Trait 的关联类型

trait 除了可以定义方法，还可以定义类型，实现 Trait 特征时，也需要实现关联类型，像泛型的 T, 需要指明类型

```Rust
pub struct Puppy;
trait Animal {
    type Baby; // 关联类型
    fn have_baby(&self) ->Self::Baby;
}
impl Animal for Dog {
    type Baby = Puppy; // 确认关联类型
    fn have_baby(&self) -> Self::Baby {
        println!("A puppy is born.");
        Puppy
    }
}
```

## 实现trait

```Rust
struct User {
    id:i32,
    name:String,
}
// 实现trait
impl Person for User {
    fn say(&self)->String{
        format!("id is {}, name is {}",self.id, self.name)
    }
}
```

###### trait 的孤儿规则

**如果你想要为类型** `A` **实现特征** `T`**，那么** `A` **或者** `T` **至少有一个是在当前作用域 中定义的！**

###### trait 的默认实现

定义具有**默认实现**的方法，这样其它类型无需再实现该方法，或者也可以选择重载该方法

```Rust
pub trait Person {
    fn author(&self)->String;
    fn say(&self) { // 有具体的实现，其他类型可以不实现或者重载这个方法
        print!("{} is saying", self.author());
    }
}
```

trait 作为参数使用

```Rust
fn notify(item: &impl Person) { // 参数是trait, 写法就是 impl trait
    item.say();
}
fn notify2(item: &(impl Person+Display) { // 多重约束，参数必须实现Person和Display特征
    item.say();
}
fn main() {
    let u1 = User{name:String::from("aa")};
    notify(&u1)
}
```

###### 特征约束 (trait bound(绑定))

trait 作为参数使用，我们使用 impl trait 其实是一个语法糖，本质是这样：

```Rust
fn notify3<T: Person>(user:&T){ // 对T类型，必须实现Person特征进行限制，T: Person就是特征约束
    user.say();
}
```

多重约束

```Rust
fn notify3<T: Person+Display>(user:&T){ // 对T类型，必须实现Person特征进行限制，T: Person就是特征约束
    user.say();
}
```

函数返回中的 impl Trait
可以通过 impl Trait 来说明一个函数返回了一个类型，该类型实现了某个特征。

但是这种写法有个缺点，只可以返回一种具体的类型，这种类型实现了 Person trait

```Rust
fn createp(n:&str)->impl Person{
    User{
        name:String::from(n)
    }
}
fn main() {
    let u1 = createp("aa");
    let u2 = createp("bb");
}
```



##### Trait 对象

上面 User 实现了 Person, 如果又有一个 Child 实现了 Person.

Trait 对象指向实现了 Person 特征的类型的实例，也就是指向了 User 或者 Child 的实例，这种映射关系是存储在一张表中，可以在运行时通过特征对象找到具体调用的类型方法。

特征对象：Box，当成一个引用即可，只不过它包裹的值会被强制分配在堆上。

```Rust
fn createp(n:&str, b:bool) -> Box<dyn Person>{ // 返回一个特征对象（类似智能指针，当做一个引用即可）
    if b {
        Box::new(User{
            name:String::from(n)
        })
    }else{
        Box::new(Child{ // 通过Box::new()创建特征对象
            name:String::from(n),
            age:1
        })
    }
}
fn notify(item: Box<dyn Person>) { // 参数是特征对象
    item.say();
}
fn main() {
    let u1 = createp("aa",true); 
    let u2 = createp("bb",false);
    notify(u1);
    notify(u2);
}
```

特征对象原理

泛型是在编译期完成处理的：编译器会为每一个泛型参数对应的具体类型生成一份代码，这种方式是静态分发 (static dispatch)，因为是在编译期完成的，对于运行期性能完全没有任何影响。

与静态分发相对应的是动态分发 (dynamic dispatch)，在这种情况下，直到运行时，才能确定需要调用什么方法。之前代码中的关键字 dyn 正是在强调这一 “动态” 的特点。

Box, 包含了两个指针

ptr: 指向实现了特征 Person 的具体类型的实例，比如类型 User 的实例、类型 Child 的实例

vptr 指向一个虚表 vtable, 保存了实例对于可以调用的实现于特征 Person 的方法

trait 对象的限制
不是所有的 trait 都有 trait 对象，必须满足一定条件的 trait

方法的返回类型不能是 Self
方法没有任何泛型参数



