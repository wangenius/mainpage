实现了 Iterator trait 的类型，就可以在 Rust 中被视为迭代器

```Rust
pub trait Iterator {
    type Item;
    fn next(&mut self) -> Option<Self::Item>;
    // 方法with default implementations elided
}
```

常见的集合类型，例如 Vector、Array、HashSet、HashMap, 字符串 String 类型虽然不是迭代器，但是可以通过.iter() 和 .into_iter() 方法，生成迭代器。

1. into_iter 会夺走所有权

2. iter 是借用

3. iter_mut 是可变借用

```Rust
fn main() {
    let arr = vec![1,3,6,8,9,10,11,12,13,14,15];
    let arr_iter = arr.iter(); // 借用
    for v in arr_iter{
        println!("{}", v) // v就是借用每一个元素
    }
}
fn main() {
    let arr = vec![1,3,6,8,9,10,11,12,13,14,15];
    let arr_into_inter = arr.into_iter(); // 元素所有权转移
    for v in arr_into_inter{
        println!("{}", v) //
    }
}
fn main() {
    let arr = vec![1,3,6,8,9,10,11,12,13,14,15];
    let arr_mut_iter = arr.iter_mut(); // 可变借用
         for v in arr_mut_iter{
        *v += 1; // 修改借用元素的值
    }
}
```

###### 消费者适配器

只要迭代器上的某个方法 `A` 在其内部调用了 `next` 方法，那么 `A` 就被称为**消费性适配器**：因为 `next` 方法会消耗掉迭代器上的元素，所以方法 `A` 的调用也会消耗掉迭代器上的元素。

```Rust
let arr = vec![1,3,6,8,9,10,11,12,13,14,15];
let arr_ter = arr.iter();
let s:i32 = arr_ter.sum(); // 会把迭代器中的所有元素相加，执行sum后，会转移所有的元素所有权
```

###### 迭代器适配器

迭代器有些方法会返回一个新的迭代器，方便链式调用，结尾一定要有消费者适配器返回数据

```Rust
let v1: Vec<i32> = vec![1, 2, 3];
let v2: Vec<_> = v1.iter().map(|x| x + 1).collect();
```



