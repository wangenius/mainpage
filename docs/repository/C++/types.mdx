---
title : types
sidebar_position : 2
slug : types
---
# types

> 用基本类型,const修饰符,声明修饰符构造出来的类型称为内置类型`built-in type`. c++的内置类型及其操作非常丰富. 但是没有为程序员提供便于编写高级应用程序的高层设施. 取而代之在内置类型和操作的基础上增加了一套精致的抽象机制,程序员可用它来构造所需的高层设施. 
> 即类和枚举. 


## struct

```cpp title="结构类型"
struct Vector{
    int size;
    double* elem;
};

Vector v;
```

但是,就v本身而言,用处不大. 因为v的elem指针并没有指向任何东西. 为了让它变得有用, 我们必须给出一些元素,另v指向它们. 

```cpp title="构造函数"
void vector_init(Vector& v,int s){
    v.elem = new double[s];
    v.size =s;
}
```

也就是说，v的elem成员被赋予了一个由new运算符生成的指针。而v的size成员则得到了元素的数目。Vector&中的&指出,我们是通过非const引用方式传递v的。这样vector_init()就能修改传给他的向量了。new运算符从一块名为自由存储(又称为动态内存或堆)的区域中分配内存。在自由存储中分配的对象独立于它创建时所处的作用域，会一直存活到使用delete运算符销毁它为止。 

```cpp title="从cin读入s个整数,然后返回这些整数的和,假定s是正的"
double read_and_sum(int s){
    Vector v;
    vector_init(v,s);

    for(int i=0;i!= s;++i) 
        cin >> v.elem[i];

    double sum = 0;
    for(int i=0;i!= s;++i)
        sum += v.elem[i];
    return sum;
}
```

> 我们自写的和标准库vector有很大差距.所以不要试图重写vector和string等标准库组件. 直接使用它们更加明智. 

我们可以通过名字或引用访问struct成员,此时使用`.`,也可以通过指针访问struct成员,此时使用`->`. 

## class


## union


## enum