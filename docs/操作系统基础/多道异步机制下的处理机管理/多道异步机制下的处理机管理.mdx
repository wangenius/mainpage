
# 程序装入

1. 编译：生成可执行代码，产生若干代码块`Object Module`

2. 链接：目标代码块链接形成完整的装入模块`Load Module`

    3. 静态链接：运行前连接成一个完整的`exe`文件

    4. 装入时动态链接：边装入边链接

    5. 运行时动态链接：对某些目标模块链接，需要才链接，便于修改、更新、共享。与虚拟内存相关。

6. 装入：将装入模块装入内存 ，地址重定位的过程。

    7. 绝对装入：`compile`时绝对定位，不适用于批处理操作系统

    8. 静态重定位：`load`时进行定位，在装入时一次性完成地址变换，必须分配要求的全部内存空间，不能移动，适用于分区分配。不需要`MMU`。

    9. 动态重定位：`execute`时重定位，内存中的所有地址都是相对地址，可以将程序分配到不连续的存储区中，适用于分页,分段分配内存。需要附加硬件重定位寄存器的支持。

    

    

# 进程

进程是进程实体的**动态**（最基本的特征）运行过程，进程是能**独立**运行、独立获得资源（进程是资源分配，拥有资源的基本单位）、独立接受调度（通常使用线程完成）的基本单位

一个进程可以创建若干新进程，为了描述进程之间的创建关系，引入进程前趋图（进程树或进程家族树）。

**PCB**：进程存在的唯一标志，标识符(PID，UID...)，分配资源信息(内存，IO，文件)，控制和管理信息(当前状态、优先级、代码运行入口地址、外存地址、信号量使用、CPU使用时间，磁盘使用情况，网络流量使用情况等)，处理机相关信息（CPU上下文、中断现场，通用寄存器值、地址寄存器值、控制寄存器值、标志寄存器值等）的数据结构，称作进程控制块。系统通过PCB对进程进行控制

`idle`：优先级最低，不需要CPU之外的资源，不会被阻塞

### 上下文

切换CPU到另一个进程，需要保存当前进程状态，并恢复另一个进程的状态。上下文是指某一时刻，CPU寄存器和程序计数器的内容。他需要相当可观的CPU时间。有的处理器提供多个寄存器组，这样上下文切换就只需要改变当前寄存器组的指针。模式切换是指用户态和内核态的切换。

进程切换一定会进行上下文切换，产生中断，进行处理器模式切换，从用户态进入内核态再返回用户态；但是处理器模式的切换不一定产生进程的切换，系统调用同样会产生处理器模式的切换，但在逻辑上仍然是同一进程。

程序执行时的一个实例，资源分配的独立单位，拥有独立的地址空间。

多道程序环境下多个程序并发执行。他们失去了封闭性，并具有间接性和不可再现性的特征。为了保证程序在并发执行的过程中实现可再现性和封闭性的要求，引入进程的概念，实现操作系统的并发性和共享性。

为了保证程序在并发执行的过程中实现可再现性和封闭性的要求，引入进程的概念，实现操作系统的并发性和共享性。进程是进程映像的运行过程，进程是能独立运行、独立获得资源（进程是资源分配，拥有资源的基本单位）、独立接受调度（通常使用线程完成）的基本单位。

一个进程实体（进程映像）由PCB、程序段、数据段组成的静态映像。

# 线程

减小程序在并发执行时所付出的时空开销，提高操作系统的并发性能。基本的CPU执行单元，是程序执行流的最小单元。

1. 线程是基本的CPU执行单元，是程序执行流的最小单元，由线程ID，程序计数器PC，寄存器集合以及堆栈组成。

2. 提升了并发度。对于单线程进程，只能运行在一个处理机上，对于多线程进程可以将进程中的多个线程分配到多个处理机上执行；

3. 调度不需要进行CPU上下文切换，时空开销小，引入线程的操作系统中，线程是独立调度的基本单位。

4. 进程并发需要切换进程的运行环境，系统开销很大，线程间并发，如果是同一进程内的线程切换，则不需要切换进程环境，系统开销小。

5. 线程无法拥有资源，进程是拥有资源的基本单位，同一个进程的所有线程共享该进程的所有资源。

TCB：标识符、寄存器组`(PC,PSW,Xs)`、运行状态、优先级、线程专有存储区、堆栈指针（用于过程调用时保存局部变量和返回地址）

**KLT：**操作系统内核空间管理线程。**可以发挥多处理机内核的优势**，同时调度同一进程中的多个线程并行运行。一个内核级线程由于IO操作阻塞时，**不会影响其他线程的运行**。处理器**分配时间片的对象是线程**，所以有多个线程的进程将会获得更多的处理器时间。线程切换开销小，但是系统开销大，一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到内核态，线程管理成本高，开销大

**ULT：**效率高，用户级代码级线程，由用户实现，与OS无关，线程阻塞则进程阻塞，不能发挥多处理机的优势。内核也并不知道它的存在，所以所有对用户级线程的管理和调度都是在用户空间来进行的。不仅无需通过中断进入操作系统的内核，而且切换的规程也远比进程调度和切换的规则来得简单，用户级线程的切换速度特别快。但是一个用户级线程若执行了阻塞系统调用就会导致该线程所属的进程阻塞。此时如果采用的是内核级线程，则调度室以线程为单位。当一个线程调用一个系统调用时，内核把系统调用只看做是该线程的行为，因而封锁该线程，于是可以再调度该进程中的其他线程执行。

组合模型

1. 多对一模型：线程管理在用户空间进行，因而效率比较高

2. 一对一模型：并发能力强，每创建一个线程，相应地就需要创建一个内核线程，管理开销大

3. 多对多模型：以上两个模型的优点，用户线程大于内核线程

[https://zhuanlan.zhihu.com/p/670803961](https://zhuanlan.zhihu.com/p/670803961)

