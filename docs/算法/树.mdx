---
sidebar_position : 3
---


# 树和森林

树和森林与二叉树的转换：

左指针指向第一个孩子，右指针指向下一个兄弟。

1. 顺序存储结构：双亲表示法

2. 链式存储结构

3. 存储结构

  1. 孩子表示法 (图的邻接表存储结构)

  2. 孩子兄弟表示法（树和森林与二叉树的相互转换关系密切）

# 二叉树
$$
b = n - 1 = n_1 + 2n_2
$$

$$
2^{i-1}
$$
$$
2^k - 1
$$
$$
h(n) = \dfrac{C_{2n}^n}{n+1}
$$
$$
h = floor(\log_2n)+1 = ceil(\log_2n+1)
$$

```Rust title="树的结构"
typedef struct Node{
    struct info {};
    struct Node *lchild;
    struct Node *rchild;
}Node,*Tree;
```


## 遍历

```Rust
先序遍历
void preorder(BTNode *p){
	if(p!==NULL){
     visit(p);
     preorder(p->lchild);
     preorder(p->rchild);
    }
}
中序遍历


后序遍历


层次遍历
辅助队列,出队时访问,分别将左右子树入队.
```


```Rust
非递归算法
//前序遍历
建栈入根,loop(s.top != -1){出栈访问并入栈先右后左孩子}
//中序遍历
建栈建指针指根,loop(s.top != -1 || p != NULL){有左孩子继续入根,没左孩子出栈访问并指向右孩子}
//后续遍历
建两栈建一针,loop(s1.top != -1){出栈入栈2,先左后右孩子入栈1},loop(s2.top != -1){出栈访问}
```


## 线索二叉树

tag = 1,指向前驱后继，tag = 0,指向左右子树

# 二叉排序树BST

算法：相似继承算法：被删除节点的直接前驱或直接后继代替被删除节点，然后删除被删除节点的直接前驱或直接后继。

## 平衡二叉树AVL

平衡因子：左高度-右高度

插入：中间派贿赂算法，插入后破坏平衡,势力大的一方的中间派上台

删除：相似继承算法+中间派贿赂算法+回溯

## 红黑树RBT

民主革命算法：

4. 中下无权者(红色)连结时(相连)

5.

  1. 中层内部分化：无权者贿赂算法获取领导权（）

  2. 中层内部团结：中层获得控制权，领导者失去控制权（中层变黑，领导变红）

## B树

m阶：最多n=m-1个key，最少key= [n/2]

插入：插后溢阶,中值飞切

删除：不能借就合并

## B+树

最多n=m个key

叶子包含全部信息

结点最少key = `<n/2>`

## 赫夫曼树

6. 结点带权，权值越大离根越近

7. 正则二叉树

8. 带权路径`WPL`最短

9. 构造：最小权结点做兄弟，父结点权值=权值之和。

```Rust
loop{选择最小的两个结点构造棵树,根节点的权值和等于两结点的权值和}
```


10. 结点总数2n-1

11. 哈夫曼树中没有度=1的结点

## 赫夫曼编码

不可做前缀

# 决策树

Decision Tree



