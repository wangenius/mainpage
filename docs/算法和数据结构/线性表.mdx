---
sidebar_position: 2
---

# 线性表

具有相同特性数据元素的一组有限序列，逻辑特性：表头表尾唯一，中间的前驱后继唯一
1. 有限性：元素个数有限

2. 顺序性：有先后次序

3. 同类型：数据元素类型相同，有先后次序

4. 抽象性：只讨论元素间的逻辑关系

链表：无需移动元素

顺序表：随机访问和连续空间

头结点和头指针的区别！默认为有头结点。

静态链表的指针不是内存地址的指针型变量，而是存储数组下标的整型变量。

5. 线性表：具有相同特性数据元素(同类型)的一组有限(有限性)序列(有先后次序，顺序性)，逻辑(只讨论元素间的逻辑关系,抽象性)特性：表头表尾唯一，中间的前驱后继唯一

6. 链表：无需移动元素

7. 顺序表：随机访问和连续空间

8. 静态链表：一个结构体数组，一个`data`，一个`next`。静态链表的指针不是内存地址的指针型变量，而是存储数组下标的整型变量。

9. 双向链表：不提高查找速度。

元素位序是从1开始的，数组中的元素下标是从0开始的。

10. 删除结点后队列为空时，必须特殊处理。

## 顺序表

```cpp
// 顺序表
typedef struct
{
    int data[maxSize];//最大长度
    int length;
}Sqlist;

//考试中一般
int A[maxSize];
int n;
```



```cpp
int search(Sqlist L,int e){
    int i;
    for(i=0;i<L.length;++i){
        if(e==L.data[i])
            return i; //返回数组下标
    }
    return -1;
}

int insert(SqList &L, int p, int e){
    //插入环境判断 位置有效，空间未满
    if(p < 0 || p > L.length || L.length == maxSize) return 0;
    // 后元素右移
    for(int i = L.length - 1; i>=p; --i)
        L.data[i+1]=L.data[i];
    // 插入操作 长度加1
    L.data[p] = e;
    ++(L.length);
    return 1;
}

int delete(Sqlist &L, int p, int &e){
    int i;
    if(p < 0 || p > L.length - 1)
        return 0;
    // 操作目标元素返回
    e = L.data[p];
    // 后元素左移
    for(i = p; i< L.length - 1; ++i)
        L.data[i]=L.data[i+1];
    --(L.length);
    return 1;
}

//将left到right之间的数据逆置
void reverse(int a[],int left,int right){
    int temp;
    for(int i = left,j = right;i < right + 1 && i<j;++i,--j){
        temp = a[i];
        a[i] = a[j];
        a[j] = temp;
    }
}
//循环左移通过逆置算法实现
void moveP(int a[],int n, int p){
    reverse(a,0,p-1);
    reverse(a,p,n-1);
    reverse(a,0,n-1);
}
```


## 链表操作

```Rust
// 单链表
typedef struct Node{
int data;
struct Node *next;
}Node;

// 双链表
typedef struct Node{
int data;
struct Node *next,*prior;
}Node;
```


```Rust
int isEmpty(Node L){
    if(NO_HEAD_LIST) return L == NULL;//不带头结点
    if(HEAD_LIST_Unidirectional) return L.next == NULL;//带头结点单双链表
    if(HEAD_LIST_bidirectional) return L == L.next;//带头结点循环链表
    return -1;
}

void createAtEnd(Node *&L,int a[],int n){
    Node *temp,*rear; //新节点和终端节点的指针
    L = (Node *)malloc(sizeof(Node));
    L.next = NULL;
    rear = L;
    for (int i = 0; i < n; ++i){
        temp=(Node *)malloc(sizeof(Node));
        temp->data = a[i];
        rear->next = temp;
        rear = rear->next;
    }
    rear->next = NULL;
}

void createAtStart(Node *&L,int a[],int n){
    Node *temp; //新节点指针
    L = (Node *)malloc(sizeof(Node));
    L->next = NULL;
    for (int i = 0; i < n; ++i){
        temp=(Node *)malloc(sizeof(Node));
        temp->data = a[i];
        temp->next = C->next;
        C->next = temp;
    }
}

int search(Node *L,int x,Node *&p){
	p = L;
	while(p->next!=NULL){
		if(p->next->data == x) return 1;
		p = p->next;
	}
	return 0;
}

int delete(Node *p){
  	Node *q=p->next;
    p->data = q->data;
    p->next = q->next;
    free(q);
    return 1;
}

void findMidNode(Node *L, Node *&mid){
	Node *p2;
	mid=p2=L;
	while(p2->next){
		p2=p2->next;
		mid=mid->next;
		if(p2->next) p2=p2->next;
    }
}

void reverse(Node *&L){
	Node *rear,*front;
	rear = NULL;
	front = L->next;
	while(front){
		L->next=rear;
		rear = L;
		L = front;
		front = front->next;
    };
	L->next = rear;
}

void merge(Node *A, Node *B, Node *&C){
    //set up tracer
    Node *a = A -> next;
    Node *b = B -> next;
    Node *rear;
    // initial status
    C = A; // 有头节点
    C -> next = NULL;
    free(B);
    rear = C;
    //归并循环
    while(a!=NULL && b !=NULL){
        if(a->data <= b->data){
            rear->next=a;
            a=a->next;
        }
        else{
            rear->next = b;
            b = b -> next;
        }
        rear = rear->next;
    }
    if(a!=NULL) rear->next = a;
    if(b!=NULL) rear->next = b;
}
```


# 栈和队列


11. 共享栈 栈底在两端

12. 双端队列

## 栈

```Rust
typedef struct SqStack{
    int data[maxSize];
    int top;
} SqStack;

typedef struct Node {
    int data;
    struct Node *node;
} Node;
```


```Rust
//init
//sqstack
void init(SqStack &st){
    st.top = -1;
};

//Linked Stack
void init(Node *&st){
    st = (LNode *)malloc(sizeof(LNode));
    st -> next = NULL;
}
//check stat
int isEmpty(Stack st){
   	if(SQSTACK) return st.top == -1;
    if(LINKED_STACK) return st->next == NULL;
}
int isFull(SqStack st){
  return st.top == maxSize - 1;
}
//sqstack
int push(SqStack &st,int x){
    if	(isFull(st)) return 0;
    st.data[++st.top] = x;
    return 1;
}
//listack
int push(Node *&st,int x){
    Node *p;
    p = (Node *)malloc(sizeof(Node));
    p->next = NULL;
    p -> data = x;
    p -> next = st ->next;
    st ->next  = p;
}
// sqstack
int pop(SqStack &st,int &x){
    if(isEmpty(st)) return 0;
    x = st.data[st.top--];
    return 1;
}
//listack
int pop(Node &st,int &x){
    Node *p;
    if (st.next = NULL) return 0;
    p=st.next;
    x = p.data;
    st.next=p->next;
    free(p);
    return 1;
}

//simple expression
int stack[maxSize]; int top = -1;
stack[++top] = x;
x = stack[top--];
```


## 队列

```Rust
typedef struct {
    int data[maxSize];
    int front;
    int rear;
}SqQuene;

typedef struct Node {
    int data;
    struct Node *next;
}Node;

typedef struct Queue {
    Node *front;
    Node *rear;
}Queue;
```


```Rust
void initQueue(SqQueue &Q){
    Q.front = Q.rear = 0;
}


void isEmpty(SqQueue Q){
	return  Q.front == Q.rear;
}

void isFull(SqQueue Q){
	return(Q.rear + 1) % maxSize = Q.front;
}

int enqueue(SqQueue &Q, int x){
	if(isFull(Q)) return 0;
	Q.rear = (Q.rear + 1) % maxSize;
	Q.data[Q.rear] = x;
	return 1;
}

int dequeue(SqQueue &Q,int &x){
	if(isEmpty(Q)) return 0;
	Q.front = (Q.front + 1)% maxSize;
	x = Q.data[Q.front];
	return 1;
}
```


# 字符串

```Rust
//定长顺序分配表示
typedef struct {
    char str[maxSize+1]; //\0 位置
    int length;
}String;

//动态分配存储
typedef struct {
    char *ch;
    int length;
}String;
//需要malloc一个长度为length，类型为char型的连续存储空间
```


```Rust
//赋值法 不能直接等于
int strassign(Str &str,char * ch){
    if (str.ch) free(str.ch);

    int len = 0;
    char *c = ch;
    while(*c){
        ++len;
        ++c;
    }
    if(len = 0){
        str.ch = NULL;
        str.length = 0;
        return 1;
    }
    else{
        str.ch = (char*)malloc((len+1) * sizeof(char));
        if(str.ch == NULL) return 0;
        else{
            c = ch;
            for(int i = 0; i<=len; ++i,++c) str.ch[i] = *c;
            str.length = len;
            return 1;
        }
    }
}

while(*p != '\0'){
	...
    ++p;
}
```


## KMP

`Knuth-Morris-Pratt`算法



## BM

精确字符串匹配算法

# 数组和矩阵

13. 二维数组是一维数组的一维数组，一般采用顺序存储

14. 广义表：表元素可以是原子或者广义表的线型表拓展结构。

15. 二维数组行优先列优先的下标问题

16. 对称矩阵、三角矩阵、对角矩阵的物理表示和确定元素位置问题

稀疏矩阵：

```Rust
三元组表示法
int trimat[maxterms+1][3];
trimat[k][0]; 表示原矩阵中元素按照行优先的顺序的第k个非零元素值
float trimat[maxterms+1][3] 的行号 (int)trimat[k][1];

伪地址表示法
两元组表示，值和伪地址：元素在矩阵中按照行优先或列优先存储的相对位置
```


```Rust
邻接表表示法
每一行的非零元素连成一个链表，链表结点中有两个分量，一个是元素值，一个是列号。

十字链表表示法
行和列都用带头结点的邻接表表示，头结点数组不存储任何信息
链表结点有5个分量，行分量、列分量、数据域分量、同列下一个结点、同行下一个结点指针。
    十字链表结点有5个分量，行数、列数、非零元素个数、行头结点数组指针、列头结点数组指针。
typedef struct OLNode {
int row,col;
struct OLNode *right,*down;
float val;
} OLNode;

typedef struct CrossList {
OLNode *rhead,*chead;
int m,n,k;
}
```


```Rust
//T
void trsmat(int A[][maxSize],int B[][maxSize],int m,int n){
    for(int i = 0;i <m;++i)
        for(int j = 0;j < n ; ++ j)
            B[j][i] = A[i][j];
}
```


# 哈希表



