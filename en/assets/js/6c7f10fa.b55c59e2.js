"use strict";(self.webpackChunkpanovista=self.webpackChunkpanovista||[]).push([[4617],{3446:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>o,contentTitle:()=>l,default:()=>d,frontMatter:()=>s,metadata:()=>a,toc:()=>c});var r=t(4848),i=t(8453);const s={title:"\u51fd\u6570",sidebar_position:2,slug:"\u51fd\u6570"},l="\u51fd\u6570",a={id:"lang/rust/\u8868\u8fbe\u5f0f\u548c\u51fd\u6570/\u51fd\u6570",title:"\u51fd\u6570",description:"\u51fd\u6570\u4f7f\u7528 fn \u5173\u952e\u5b57\u58f0\u660e\u3002\u5b83\u7684\u53c2\u6570\u5e26\u6709\u7c7b\u578b\u6ce8\u91ca\uff0c\u5c31\u50cf\u53d8\u91cf\u4e00\u6837\uff0c\u5e76\u4e14\uff0c\u5982\u679c\u51fd\u6570\u8fd4\u56de\u503c\uff0c\u5219\u5fc5\u987b\u5728\u7bad\u5934 -> \u4e4b\u540e\u6307\u5b9a\u8fd4\u56de\u7c7b\u578b\u3002",source:"@site/docs/lang/rust/\u8868\u8fbe\u5f0f\u548c\u51fd\u6570/\u51fd\u6570.mdx",sourceDirName:"lang/rust/\u8868\u8fbe\u5f0f\u548c\u51fd\u6570",slug:"/lang/rust/\u8868\u8fbe\u5f0f\u548c\u51fd\u6570/\u51fd\u6570",permalink:"/en/docs/lang/rust/\u8868\u8fbe\u5f0f\u548c\u51fd\u6570/\u51fd\u6570",draft:!1,unlisted:!1,editUrl:"https://github.com/wangenius/wangenius.github.io/tree/master/docs/lang/rust/\u8868\u8fbe\u5f0f\u548c\u51fd\u6570/\u51fd\u6570.mdx",tags:[],version:"current",sidebarPosition:2,frontMatter:{title:"\u51fd\u6570",sidebar_position:2,slug:"\u51fd\u6570"},sidebar:"rust",previous:{title:"\u667a\u80fd\u6307\u9488",permalink:"/en/docs/lang/rust/\u6570\u636e\u7c7b\u578b/\u667a\u80fd\u6307\u9488"},next:{title:"\u63a7\u5236\u6d41\u8bed\u53e5",permalink:"/en/docs/lang/rust/\u8868\u8fbe\u5f0f\u548c\u51fd\u6570/\u63a7\u5236\u6d41\u8bed\u53e5"}},o={},c=[{value:"\u5173\u8054\u51fd\u6570",id:"\u5173\u8054\u51fd\u6570",level:2},{value:"\u95ed\u5305",id:"\u95ed\u5305",level:2},{value:"\u533f\u540d\u51fd\u6570",id:"\u533f\u540d\u51fd\u6570",level:3},{value:"\u6355\u6349",id:"\u6355\u6349",level:3},{value:"\u4f5c\u4e3a\u8f93\u5165\u53c2\u6570",id:"\u4f5c\u4e3a\u8f93\u5165\u53c2\u6570",level:3},{value:"\u7c7b\u578b\u533f\u540d",id:"\u7c7b\u578b\u533f\u540d",level:3},{value:"\u8f93\u5165\u529f\u80fd",id:"\u8f93\u5165\u529f\u80fd",level:3},{value:"\u4f5c\u4e3a\u8f93\u51fa\u53c2\u6570",id:"\u4f5c\u4e3a\u8f93\u51fa\u53c2\u6570",level:3},{value:"\u4f8b\u5b50",id:"\u4f8b\u5b50",level:3},{value:"\u9ad8\u9636\u51fd\u6570",id:"\u9ad8\u9636\u51fd\u6570",level:2},{value:"\u53d1\u6563\u51fd\u6570",id:"\u53d1\u6563\u51fd\u6570",level:2}];function u(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.h1,{id:"\u51fd\u6570",children:"\u51fd\u6570"}),"\n",(0,r.jsx)(e.p,{children:"\u51fd\u6570\u4f7f\u7528 fn \u5173\u952e\u5b57\u58f0\u660e\u3002\u5b83\u7684\u53c2\u6570\u5e26\u6709\u7c7b\u578b\u6ce8\u91ca\uff0c\u5c31\u50cf\u53d8\u91cf\u4e00\u6837\uff0c\u5e76\u4e14\uff0c\u5982\u679c\u51fd\u6570\u8fd4\u56de\u503c\uff0c\u5219\u5fc5\u987b\u5728\u7bad\u5934 -> \u4e4b\u540e\u6307\u5b9a\u8fd4\u56de\u7c7b\u578b\u3002"}),"\n",(0,r.jsx)(e.p,{children:"\u51fd\u6570\u4e2d\u7684\u6700\u7ec8\u8868\u8fbe\u5f0f\u5c06\u7528\u4f5c\u8fd4\u56de\u503c\u3002\u6216\u8005\uff0c return \u8bed\u53e5\u53ef\u7528\u4e8e\u4ece\u51fd\u6570\u5185\u90e8\uff08\u751a\u81f3\u4ece\u5185\u90e8\u5faa\u73af\u6216 if \u8bed\u53e5\uff09\u8fd4\u56de\u8f83\u65e9\u7684\u503c\u3002"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-rust",children:'// Unlike C/C++, there\'s no restriction on the order of function definitions\nfn main() {\n    // We can use this function here, and define it somewhere later\n    fizzbuzz_to(100);\n}\n\n// Function that returns a boolean value\nfn is_divisible_by(lhs: u32, rhs: u32) -> bool {\n    // Corner case, early return\n    if rhs == 0 {\n        return false;\n    }\n\n    // This is an expression, the `return` keyword is not necessary here\n    lhs % rhs == 0\n}\n\n// Functions that "don\'t" return a value, actually return the unit type `()`\nfn fizzbuzz(n: u32) -> () {\n    if is_divisible_by(n, 15) {\n        println!("fizzbuzz");\n    } else if is_divisible_by(n, 3) {\n        println!("fizz");\n    } else if is_divisible_by(n, 5) {\n        println!("buzz");\n    } else {\n        println!("{}", n);\n    }\n}\n\n// When a function returns `()`, the return type can be omitted from the\n// signature\nfn fizzbuzz_to(n: u32) {\n    for n in 1..=n {\n        fizzbuzz(n);\n    }\n}\n'})}),"\n",(0,r.jsx)(e.h2,{id:"\u5173\u8054\u51fd\u6570",children:"\u5173\u8054\u51fd\u6570"}),"\n",(0,r.jsx)(e.p,{children:"\u67d0\u4e9b\u51fd\u6570\u4e0e\u7279\u5b9a\u7c7b\u578b\u76f8\u5173\u3002\u5b83\u4eec\u6709\u4e24\u79cd\u5f62\u5f0f\uff1a\u5173\u8054\u51fd\u6570\u548c\u65b9\u6cd5\u3002\u5173\u8054\u51fd\u6570\u662f\u901a\u5e38\u5728\u7c7b\u578b\u4e0a\u5b9a\u4e49\u7684\u51fd\u6570\uff0c\u800c\u65b9\u6cd5\u662f\u5728\u7c7b\u578b\u7684\u7279\u5b9a\u5b9e\u4f8b\u4e0a\u8c03\u7528\u7684\u5173\u8054\u51fd\u6570\u3002"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-rust",children:'struct Point {\n    x: f64,\n    y: f64,\n}\n\n// Implementation block, all `Point` associated functions & methods go in here\nimpl Point {\n    // This is an "associated function" because this function is associated with\n    // a particular type, that is, Point.\n    //\n    // Associated functions don\'t need to be called with an instance.\n    // These functions are generally used like constructors.\n    fn origin() -> Point {\n        Point { x: 0.0, y: 0.0 }\n    }\n\n    // Another associated function, taking two arguments:\n    fn new(x: f64, y: f64) -> Point {\n        Point { x: x, y: y }\n    }\n}\n\nstruct Rectangle {\n    p1: Point,\n    p2: Point,\n}\n\nimpl Rectangle {\n    // This is a method\n    // `&self` is sugar for `self: &Self`, where `Self` is the type of the\n    // caller object. In this case `Self` = `Rectangle`\n    fn area(&self) -> f64 {\n        // `self` gives access to the struct fields via the dot operator\n        let Point { x: x1, y: y1 } = self.p1;\n        let Point { x: x2, y: y2 } = self.p2;\n\n        // `abs` is a `f64` method that returns the absolute value of the\n        // caller\n        ((x1 - x2) * (y1 - y2)).abs()\n    }\n\n    fn perimeter(&self) -> f64 {\n        let Point { x: x1, y: y1 } = self.p1;\n        let Point { x: x2, y: y2 } = self.p2;\n\n        2.0 * ((x1 - x2).abs() + (y1 - y2).abs())\n    }\n\n    // This method requires the caller object to be mutable\n    // `&mut self` desugars to `self: &mut Self`\n    fn translate(&mut self, x: f64, y: f64) {\n        self.p1.x += x;\n        self.p2.x += x;\n\n        self.p1.y += y;\n        self.p2.y += y;\n    }\n}\n\n// `Pair` owns resources: two heap allocated integers\nstruct Pair(Box<i32>, Box<i32>);\n\nimpl Pair {\n    // This method "consumes" the resources of the caller object\n    // `self` desugars to `self: Self`\n    fn destroy(self) {\n        // Destructure `self`\n        let Pair(first, second) = self;\n\n        println!("Destroying Pair({}, {})", first, second);\n\n        // `first` and `second` go out of scope and get freed\n    }\n}\n\nfn main() {\n    let rectangle = Rectangle {\n        // Associated functions are called using double colons\n        p1: Point::origin(),\n        p2: Point::new(3.0, 4.0),\n    };\n\n    // Methods are called using the dot operator\n    // Note that the first argument `&self` is implicitly passed, i.e.\n    // `rectangle.perimeter()` === `Rectangle::perimeter(&rectangle)`\n    println!("Rectangle perimeter: {}", rectangle.perimeter());\n    println!("Rectangle area: {}", rectangle.area());\n\n    let mut square = Rectangle {\n        p1: Point::origin(),\n        p2: Point::new(1.0, 1.0),\n    };\n\n    // Error! `rectangle` is immutable, but this method requires a mutable\n    // object\n    //rectangle.translate(1.0, 0.0);\n    // TODO ^ Try uncommenting this line\n\n    // Okay! Mutable objects can call mutable methods\n    square.translate(1.0, 1.0);\n\n    let pair = Pair(Box::new(1), Box::new(2));\n\n    pair.destroy();\n\n    // Error! Previous `destroy` call "consumed" `pair`\n    //pair.destroy();\n    // TODO ^ Try uncommenting this line\n}\n'})}),"\n",(0,r.jsx)(e.h2,{id:"\u95ed\u5305",children:"\u95ed\u5305"}),"\n",(0,r.jsx)(e.p,{children:"\u95ed\u5305\u662f\u53ef\u4ee5\u6355\u83b7\u5c01\u95ed\u73af\u5883\u7684\u51fd\u6570\u3002\u4f8b\u5982\uff0c\u6355\u83b7 x \u53d8\u91cf\u7684\u95ed\u5305\uff1a"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-rust",children:"|val| val + x\n"})}),"\n",(0,r.jsx)(e.p,{children:"\u95ed\u5305\u7684\u8bed\u6cd5\u548c\u529f\u80fd\u4f7f\u5b83\u4eec\u975e\u5e38\u65b9\u4fbf\u5373\u65f6\u4f7f\u7528\u3002\u8c03\u7528\u95ed\u5305\u4e0e\u8c03\u7528\u51fd\u6570\u5b8c\u5168\u76f8\u540c\u3002\u4f46\u662f\uff0c\u8f93\u5165\u548c\u8fd4\u56de\u7c7b\u578b\u90fd\u53ef\u4ee5\u63a8\u65ad\uff0c\u5e76\u4e14\u5fc5\u987b\u6307\u5b9a\u8f93\u5165\u53d8\u91cf\u540d\u79f0\u3002"}),"\n",(0,r.jsx)(e.p,{children:"\u95ed\u5305\u7684\u5176\u4ed6\u7279\u5f81\u5305\u62ec\uff1a"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["\u5728\u8f93\u5165\u53d8\u91cf\u5468\u56f4\u4f7f\u7528 ",(0,r.jsx)(e.code,{children:"||"})," \u800c\u4e0d\u662f ",(0,r.jsx)(e.code,{children:"()"})," \u3002"]}),"\n",(0,r.jsxs)(e.li,{children:["\u5355\u884c\u8868\u8fbe\u5f0f\u7684\u53ef\u9009\u4e3b\u4f53\u5b9a\u754c ",(0,r.jsx)(e.code,{children:"( {} )"}),"\uff08\u5426\u5219\u4e3a\u5f3a\u5236\uff09\u3002"]}),"\n",(0,r.jsx)(e.li,{children:"\u6355\u83b7\u5916\u90e8\u73af\u5883\u53d8\u91cf\u7684\u80fd\u529b\u3002"}),"\n"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-rust",children:'fn main() {\n    let outer_var = 42;\n\n    // A regular function can\'t refer to variables in the enclosing environment\n    //fn function(i: i32) -> i32 { i + outer_var }\n    // TODO: uncomment the line above and see the compiler error. The compiler\n    // suggests that we define a closure instead.\n\n    // Closures are anonymous, here we are binding them to references.\n    // Annotation is identical to function annotation but is optional\n    // as are the `{}` wrapping the body. These nameless functions\n    // are assigned to appropriately named variables.\n    let closure_annotated = |i: i32| -> i32 { i + outer_var };\n    let closure_inferred  = |i     |          i + outer_var  ;\n\n    // Call the closures.\n    println!("closure_annotated: {}", closure_annotated(1));\n    println!("closure_inferred: {}", closure_inferred(1));\n    // Once closure\'s type has been inferred, it cannot be inferred again with another type.\n    //println!("cannot reuse closure_inferred with another type: {}", closure_inferred(42i64));\n    // TODO: uncomment the line above and see the compiler error.\n\n    // A closure taking no arguments which returns an `i32`.\n    // The return type is inferred.\n    let one = || 1;\n    println!("closure returning one: {}", one());\n\n}\n'})}),"\n",(0,r.jsx)(e.h3,{id:"\u533f\u540d\u51fd\u6570",children:"\u533f\u540d\u51fd\u6570"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-Rust",children:'|\u53c2\u6570\u5217\u8868| -> \u8fd4\u56de\u503c\u7c7b\u578b {\n    // \u51fd\u6570\u4f53\n}\nlet add = |x, y| -> i32 { // \u6709\u8fd4\u56de\u503c\n    x + y\n};\nlet run = |x| { // \u6ca1\u6709\u8fd4\u56de\u503c\n\n}\nlet result = add(1, 2);\nprintln!("{}", result); // \u6253\u5370: 3\n'})}),"\n",(0,r.jsx)(e.p,{children:"\u95ed\u5305\u4e2d\u6355\u83b7\u4f5c\u7528\u57df\u4e2d\u7684\u503c"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-Rust",children:'fn main() {\n    let s = String::from("Hello, world!");\n    let run = ||{\n        print!("{}", s); //\u95ed\u5305\u51fd\u6570\u53ef\u4ee5\u4f7f\u7528\u4f5c\u7528\u57df\u5185\u7684\u503c\uff0c\u800c\u4e0d\u7528\u5f53\u505a\u53c2\u6570\u4f20\u8fdb\u53bb\n    };\n    run();\n}\n'})}),"\n",(0,r.jsx)(e.h3,{id:"\u6355\u6349",children:"\u6355\u6349"}),"\n",(0,r.jsx)(e.p,{children:"\u95ed\u5305\u672c\u8d28\u4e0a\u662f\u7075\u6d3b\u7684\uff0c\u5e76\u4e14\u5c06\u6267\u884c\u529f\u80fd\u6240\u9700\u7684\u64cd\u4f5c\uff0c\u4f7f\u95ed\u5305\u65e0\u9700\u6ce8\u91ca\u5373\u53ef\u5de5\u4f5c\u3002\u8fd9\u4f7f\u5f97\u6355\u83b7\u80fd\u591f\u7075\u6d3b\u5730\u9002\u5e94\u7528\u4f8b\uff0c\u6709\u65f6\u79fb\u52a8\uff0c\u6709\u65f6\u501f\u7528\u3002\u95ed\u5305\u53ef\u4ee5\u6355\u83b7\u53d8\u91cf\uff1a"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"\u53c2\u8003\uff1a &T"}),"\n",(0,r.jsx)(e.li,{children:"\u901a\u8fc7\u53ef\u53d8\u5f15\u7528\uff1a &mut T"}),"\n",(0,r.jsx)(e.li,{children:"\u6309\u503c\uff1a T"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"\u5b83\u4eec\u4f18\u5148\u901a\u8fc7\u5f15\u7528\u6355\u83b7\u53d8\u91cf\uff0c\u5e76\u4e14\u4ec5\u5728\u9700\u8981\u65f6\u624d\u964d\u4f4e\u3002"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-rust",children:'fn main() {\n    use std::mem;\n    \n    let color = String::from("green");\n\n    // A closure to print `color` which immediately borrows (`&`) `color` and\n    // stores the borrow and closure in the `print` variable. It will remain\n    // borrowed until `print` is used the last time. \n    //\n    // `println!` only requires arguments by immutable reference so it doesn\'t\n    // impose anything more restrictive.\n    let print = || println!("`color`: {}", color);\n\n    // Call the closure using the borrow.\n    print();\n\n    // `color` can be borrowed immutably again, because the closure only holds\n    // an immutable reference to `color`. \n    let _reborrow = &color;\n    print();\n\n    // A move or reborrow is allowed after the final use of `print`\n    let _color_moved = color;\n\n\n    let mut count = 0;\n    // A closure to increment `count` could take either `&mut count` or `count`\n    // but `&mut count` is less restrictive so it takes that. Immediately\n    // borrows `count`.\n    //\n    // A `mut` is required on `inc` because a `&mut` is stored inside. Thus,\n    // calling the closure mutates `count` which requires a `mut`.\n    let mut inc = || {\n        count += 1;\n        println!("`count`: {}", count);\n    };\n\n    // Call the closure using a mutable borrow.\n    inc();\n\n    // The closure still mutably borrows `count` because it is called later.\n    // An attempt to reborrow will lead to an error.\n    // let _reborrow = &count; \n    // ^ TODO: try uncommenting this line.\n    inc();\n\n    // The closure no longer needs to borrow `&mut count`. Therefore, it is\n    // possible to reborrow without an error\n    let _count_reborrowed = &mut count; \n\n    \n    // A non-copy type.\n    let movable = Box::new(3);\n\n    // `mem::drop` requires `T` so this must take by value. A copy type\n    // would copy into the closure leaving the original untouched.\n    // A non-copy must move and so `movable` immediately moves into\n    // the closure.\n    let consume = || {\n        println!("`movable`: {:?}", movable);\n        mem::drop(movable);\n    };\n\n    // `consume` consumes the variable so this can only be called once.\n    consume();\n    // consume();\n    // ^ TODO: Try uncommenting this line.\n}\n'})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-rust",children:'fn main() {\n    // `Vec` has non-copy semantics.\n    let haystack = vec![1, 2, 3];\n\n    let contains = move |needle| haystack.contains(needle);\n\n    println!("{}", contains(&1));\n    println!("{}", contains(&4));\n\n    // println!("There\'re {} elements in vec", haystack.len());\n    // ^ Uncommenting above line will result in compile-time error\n    // because borrow checker doesn\'t allow re-using variable after it\n    // has been moved.\n    \n    // Removing `move` from closure\'s signature will cause closure\n    // to borrow _haystack_ variable immutably, hence _haystack_ is still\n    // available and uncommenting above line will not cause an error.\n}\n'})}),"\n",(0,r.jsx)(e.h3,{id:"\u4f5c\u4e3a\u8f93\u5165\u53c2\u6570",children:"\u4f5c\u4e3a\u8f93\u5165\u53c2\u6570"}),"\n",(0,r.jsx)(e.p,{children:"\u867d\u7136 Rust \u9009\u62e9\u5982\u4f55\u5728\u6ca1\u6709\u7c7b\u578b\u6ce8\u91ca\u7684\u60c5\u51b5\u4e0b\u52a8\u6001\u6355\u83b7\u53d8\u91cf\uff0c\u4f46\u5728\u7f16\u5199\u51fd\u6570\u65f6\u4e0d\u5141\u8bb8\u8fd9\u79cd\u6b67\u4e49\u3002\u5f53\u5c06\u95ed\u5305\u4f5c\u4e3a\u8f93\u5165\u53c2\u6570\u65f6\uff0c\u5fc5\u987b\u4f7f\u7528\u51e0\u4e2a traits \u4e4b\u4e00\u6765\u6ce8\u91ca\u95ed\u5305\u7684\u5b8c\u6574\u7c7b\u578b\uff0c\u5e76\u4e14\u5b83\u4eec\u7531\u95ed\u5305\u5bf9\u6355\u83b7\u7684\u503c\u6267\u884c\u7684\u64cd\u4f5c\u786e\u5b9a\u3002\u6309\u7167\u9650\u5236\u9012\u51cf\u7684\u987a\u5e8f\uff0c\u5b83\u4eec\u662f\uff1a"}),"\n",(0,r.jsx)(e.p,{children:"Fn \uff1a\u95ed\u5305\u901a\u8fc7\u5f15\u7528\u4f7f\u7528\u6355\u83b7\u7684\u503c\uff08 &T \uff09\nFnMut \uff1a\u95ed\u5305\u901a\u8fc7\u53ef\u53d8\u5f15\u7528\u4f7f\u7528\u6355\u83b7\u7684\u503c\uff08 &mut T \uff09\nFnOnce \uff1a\u95ed\u5305\u6309\u503c\u4f7f\u7528\u6355\u83b7\u7684\u503c ( T )\n\u5728\u9010\u4e2a\u53d8\u91cf\u7684\u57fa\u7840\u4e0a\uff0c\u7f16\u8bd1\u5668\u5c06\u4ee5\u5c3d\u53ef\u80fd\u9650\u5236\u6700\u5c11\u7684\u65b9\u5f0f\u6355\u83b7\u53d8\u91cf\u3002"}),"\n",(0,r.jsx)(e.p,{children:"\u4f8b\u5982\uff0c\u8003\u8651\u4e00\u4e2a\u6ce8\u91ca\u4e3a FnOnce \u7684\u53c2\u6570\u3002\u8fd9\u6307\u5b9a\u95ed\u5305\u53ef\u4ee5\u901a\u8fc7 &T \u3001 &mut T \u6216 T \u6355\u83b7\uff0c\u4f46\u7f16\u8bd1\u5668\u6700\u7ec8\u5c06\u6839\u636e\u6355\u83b7\u7684\u53d8\u91cf\u5728\u95ed\u5305\u4e2d\u7684\u4f7f\u7528\u65b9\u5f0f\u8fdb\u884c\u9009\u62e9\u3002"}),"\n",(0,r.jsx)(e.p,{children:"\u8fd9\u662f\u56e0\u4e3a\u5982\u679c\u53ef\u4ee5\u8fdb\u884c\u8f6c\u79fb\uff0c\u90a3\u4e48\u4efb\u4f55\u7c7b\u578b\u7684\u501f\u7528\u4e5f\u5e94\u8be5\u662f\u53ef\u80fd\u7684\u3002\u8bf7\u6ce8\u610f\uff0c\u53cd\u4e4b\u5219\u4e0d\u7136\u3002\u5982\u679c\u53c2\u6570\u6ce8\u91ca\u4e3a Fn \uff0c\u5219\u4e0d\u5141\u8bb8\u901a\u8fc7 &mut T \u6216 T \u6355\u83b7\u53d8\u91cf\u3002\u4f46\u662f\uff0c &T \u662f\u5141\u8bb8\u7684\u3002"}),"\n",(0,r.jsx)(e.p,{children:"\u5728\u4ee5\u4e0b\u793a\u4f8b\u4e2d\uff0c\u5c1d\u8bd5\u4ea4\u6362 Fn \u3001 FnMut \u548c FnOnce \u7684\u7528\u6cd5\uff0c\u770b\u770b\u4f1a\u53d1\u751f\u4ec0\u4e48\uff1a"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-rust",children:'// A function which takes a closure as an argument and calls it.\n// <F> denotes that F is a "Generic type parameter"\nfn apply<F>(f: F) where\n    // The closure takes no input and returns nothing.\n    F: FnOnce() {\n    // ^ TODO: Try changing this to `Fn` or `FnMut`.\n\n    f();\n}\n\n// A function which takes a closure and returns an `i32`.\nfn apply_to_3<F>(f: F) -> i32 where\n    // The closure takes an `i32` and returns an `i32`.\n    F: Fn(i32) -> i32 {\n\n    f(3)\n}\n\nfn main() {\n    use std::mem;\n\n    let greeting = "hello";\n    // A non-copy type.\n    // `to_owned` creates owned data from borrowed one\n    let mut farewell = "goodbye".to_owned();\n\n    // Capture 2 variables: `greeting` by reference and\n    // `farewell` by value.\n    let diary = || {\n        // `greeting` is by reference: requires `Fn`.\n        println!("I said {}.", greeting);\n\n        // Mutation forces `farewell` to be captured by\n        // mutable reference. Now requires `FnMut`.\n        farewell.push_str("!!!");\n        println!("Then I screamed {}.", farewell);\n        println!("Now I can sleep. zzzzz");\n\n        // Manually calling drop forces `farewell` to\n        // be captured by value. Now requires `FnOnce`.\n        mem::drop(farewell);\n    };\n\n    // Call the function which applies the closure.\n    apply(diary);\n\n    // `double` satisfies `apply_to_3`\'s trait bound\n    let double = |x| 2 * x;\n\n    println!("3 doubled: {}", apply_to_3(double));\n}\n'})}),"\n",(0,r.jsx)(e.h3,{id:"\u7c7b\u578b\u533f\u540d",children:"\u7c7b\u578b\u533f\u540d"}),"\n",(0,r.jsx)(e.p,{children:"\u95ed\u5305\u7b80\u6d01\u5730\u6355\u83b7\u5c01\u95ed\u8303\u56f4\u4e2d\u7684\u53d8\u91cf\u3002\u8fd9\u6709\u4ec0\u4e48\u540e\u679c\u5417\uff1f\u786e\u5b9e\u5982\u6b64\u3002\u89c2\u5bdf\u4f7f\u7528\u95ed\u5305\u4f5c\u4e3a\u51fd\u6570\u53c2\u6570\u5982\u4f55\u9700\u8981\u6cdb\u578b\uff0c\u8fd9\u662f\u5fc5\u8981\u7684\uff0c\u56e0\u4e3a\u5b83\u4eec\u662f\u5982\u4f55\u5b9a\u4e49\u7684\uff1a"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-rust",children:"// `F` must be generic.\nfn apply<F>(f: F) where\n    F: FnOnce() {\n    f();\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"\u5b9a\u4e49\u95ed\u5305\u65f6\uff0c\u7f16\u8bd1\u5668\u4f1a\u9690\u5f0f\u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u533f\u540d\u7ed3\u6784\u6765\u5b58\u50a8\u6355\u83b7\u7684\u53d8\u91cf\uff0c\u540c\u65f6\u901a\u8fc7 traits \u4e4b\u4e00\u5b9e\u73b0\u529f\u80fd\uff1a Fn \u3001 FnMut \u5bf9\u4e8e\u8fd9\u79cd\u672a\u77e5\u7c7b\u578b\u3002\u8be5\u7c7b\u578b\u88ab\u5206\u914d\u7ed9\u5728\u8c03\u7528\u4e4b\u524d\u5b58\u50a8\u7684\u53d8\u91cf\u3002"}),"\n",(0,r.jsxs)(e.p,{children:["\u7531\u4e8e\u8fd9\u79cd\u65b0\u7c7b\u578b\u662f\u672a\u77e5\u7c7b\u578b\uff0c\u56e0\u6b64\u51fd\u6570\u4e2d\u7684\u4efb\u4f55\u4f7f\u7528\u90fd\u9700\u8981\u6cdb\u578b\u3002\u4f46\u662f\uff0c\u65e0\u754c\u7c7b\u578b\u53c2\u6570 ",(0,r.jsx)(e.code,{children:"<T>"})," \u4ecd\u7136\u662f\u4e0d\u660e\u786e\u7684\u5e76\u4e14\u662f\u4e0d\u5141\u8bb8\u7684\u3002\u56e0\u6b64\uff0c\u4ee5 traits \uff1a Fn \u3001 FnMut \u6216 FnOnce \uff08\u5b83\u5b9e\u73b0\u7684\uff09\u4e4b\u4e00\u4e3a\u754c\u8db3\u4ee5\u6307\u5b9a\u5176\u7c7b\u578b\u3002"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-rust",children:'// `F` must implement `Fn` for a closure which takes no\n// inputs and returns nothing - exactly what is required\n// for `print`.\nfn apply<F>(f: F) where\n    F: Fn() {\n    f();\n}\n\nfn main() {\n    let x = 7;\n\n    // Capture `x` into an anonymous type and implement\n    // `Fn` for it. Store it in `print`.\n    let print = || println!("{}", x);\n\n    apply(print);\n}\n'})}),"\n",(0,r.jsx)(e.h3,{id:"\u8f93\u5165\u529f\u80fd",children:"\u8f93\u5165\u529f\u80fd"}),"\n",(0,r.jsx)(e.p,{children:"\u7531\u4e8e\u95ed\u5305\u53ef\u4ee5\u7528\u4f5c\u53c2\u6570\uff0c\u56e0\u6b64\u60a8\u53ef\u80fd\u60f3\u77e5\u9053\u51fd\u6570\u662f\u5426\u4e5f\u53ef\u4ee5\u8fd9\u6837\u8bf4\u3002\u4ed6\u4eec\u786e\u5b9e\u53ef\u4ee5\uff01\u5982\u679c\u60a8\u58f0\u660e\u4e00\u4e2a\u91c7\u7528\u95ed\u5305\u4f5c\u4e3a\u53c2\u6570\u7684\u51fd\u6570\uff0c\u5219\u4efb\u4f55\u6ee1\u8db3\u8be5\u95ed\u5305\u7279\u5f81\u8fb9\u754c\u7684\u51fd\u6570\u90fd\u53ef\u4ee5\u4f5c\u4e3a\u53c2\u6570\u4f20\u9012\u3002"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-rust",children:'// Define a function which takes a generic `F` argument\n// bounded by `Fn`, and calls it\nfn call_me<F: Fn()>(f: F) {\n    f();\n}\n\n// Define a wrapper function satisfying the `Fn` bound\nfn function() {\n    println!("I\'m a function!");\n}\n\nfn main() {\n    // Define a closure satisfying the `Fn` bound\n    let closure = || println!("I\'m a closure!");\n\n    call_me(closure);\n    call_me(function);\n}\n'})}),"\n",(0,r.jsx)(e.h3,{id:"\u4f5c\u4e3a\u8f93\u51fa\u53c2\u6570",children:"\u4f5c\u4e3a\u8f93\u51fa\u53c2\u6570"}),"\n",(0,r.jsx)(e.p,{children:"\u95ed\u5305\u4f5c\u4e3a\u8f93\u5165\u53c2\u6570\u662f\u53ef\u80fd\u7684\uff0c\u56e0\u6b64\u8fd4\u56de\u95ed\u5305\u4f5c\u4e3a\u8f93\u51fa\u53c2\u6570\u4e5f\u5e94\u8be5\u662f\u53ef\u80fd\u7684\u3002\u7136\u800c\uff0c\u6839\u636e\u5b9a\u4e49\uff0c\u533f\u540d\u95ed\u5305\u7c7b\u578b\u662f\u672a\u77e5\u7684\uff0c\u56e0\u6b64\u6211\u4eec\u5fc5\u987b\u4f7f\u7528 impl Trait \u6765\u8fd4\u56de\u5b83\u4eec\u3002"}),"\n",(0,r.jsx)(e.p,{children:"\u8fd4\u56de\u95ed\u5305\u7684\u6709\u6548\u7279\u5f81\u662f\uff1a"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Fn"}),"\n",(0,r.jsx)(e.li,{children:"FnMut"}),"\n",(0,r.jsx)(e.li,{children:"FnOnce"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"\u9664\u6b64\u4e4b\u5916\uff0c\u5fc5\u987b\u4f7f\u7528 move \u5173\u952e\u5b57\uff0c\u5b83\u8868\u793a\u6240\u6709\u6355\u83b7\u5747\u6309\u503c\u8fdb\u884c\u3002\u8fd9\u662f\u5fc5\u9700\u7684\uff0c\u56e0\u4e3a\u4e00\u65e6\u51fd\u6570\u9000\u51fa\uff0c\u4efb\u4f55\u901a\u8fc7\u5f15\u7528\u7684\u6355\u83b7\u90fd\u4f1a\u88ab\u5220\u9664\uff0c\u4ece\u800c\u5728\u95ed\u5305\u4e2d\u7559\u4e0b\u65e0\u6548\u7684\u5f15\u7528\u3002"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-rust",children:'fn create_fn() -> impl Fn() {\n    let text = "Fn".to_owned();\n\n    move || println!("This is a: {}", text)\n}\n\nfn create_fnmut() -> impl FnMut() {\n    let text = "FnMut".to_owned();\n\n    move || println!("This is a: {}", text)\n}\n\nfn create_fnonce() -> impl FnOnce() {\n    let text = "FnOnce".to_owned();\n\n    move || println!("This is a: {}", text)\n}\n\nfn main() {\n    let fn_plain = create_fn();\n    let mut fn_mut = create_fnmut();\n    let fn_once = create_fnonce();\n\n    fn_plain();\n    fn_mut();\n    fn_once();\n}\n'})}),"\n",(0,r.jsx)(e.h3,{id:"\u4f8b\u5b50",children:"\u4f8b\u5b50"}),"\n",(0,r.jsx)(e.p,{children:"Iterator::any \u662f\u4e00\u4e2a\u51fd\u6570\uff0c\u5f53\u4f20\u9012\u8fed\u4ee3\u5668\u65f6\uff0c\u5982\u679c\u4efb\u4f55\u5143\u7d20\u6ee1\u8db3\u8c13\u8bcd\uff0c\u5c06\u8fd4\u56de true \u3002\u5426\u5219 false \u3002\u5b83\u7684\u7b7e\u540d\uff1a"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-rust",children:"pub trait Iterator {\n    // The type being iterated over.\n    type Item;\n\n    // `any` takes `&mut self` meaning the caller may be borrowed\n    // and modified, but not consumed.\n    fn any<F>(&mut self, f: F) -> bool where\n        // `FnMut` meaning any captured variable may at most be\n        // modified, not consumed. `Self::Item` states it takes\n        // arguments to the closure by value.\n        F: FnMut(Self::Item) -> bool;\n}\n"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-rust",children:'fn main() {\n    let vec1 = vec![1, 2, 3];\n    let vec2 = vec![4, 5, 6];\n\n    // `iter()` for vecs yields `&i32`. Destructure to `i32`.\n    println!("2 in vec1: {}", vec1.iter()     .any(|&x| x == 2));\n    // `into_iter()` for vecs yields `i32`. No destructuring required.\n    println!("2 in vec2: {}", vec2.into_iter().any(|x| x == 2));\n\n    // `iter()` only borrows `vec1` and its elements, so they can be used again\n    println!("vec1 len: {}", vec1.len());\n    println!("First element of vec1 is: {}", vec1[0]);\n    // `into_iter()` does move `vec2` and its elements, so they cannot be used again\n    // println!("First element of vec2 is: {}", vec2[0]);\n    // println!("vec2 len: {}", vec2.len());\n    // TODO: uncomment two lines above and see compiler errors.\n\n    let array1 = [1, 2, 3];\n    let array2 = [4, 5, 6];\n\n    // `iter()` for arrays yields `&i32`.\n    println!("2 in array1: {}", array1.iter()     .any(|&x| x == 2));\n    // `into_iter()` for arrays yields `i32`.\n    println!("2 in array2: {}", array2.into_iter().any(|x| x == 2));\n}\n'})}),"\n",(0,r.jsx)(e.p,{children:"Iterator::find \u662f\u4e00\u4e2a\u8fed\u4ee3\u8fed\u4ee3\u5668\u5e76\u641c\u7d22\u6ee1\u8db3\u67d0\u4e9b\u6761\u4ef6\u7684\u7b2c\u4e00\u4e2a\u503c\u7684\u51fd\u6570\u3002\u5982\u679c\u6ca1\u6709\u4e00\u4e2a\u503c\u6ee1\u8db3\u6761\u4ef6\uff0c\u5219\u8fd4\u56de None \u3002\u5b83\u7684\u7b7e\u540d\uff1a"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-rust",children:"pub trait Iterator {\n    // The type being iterated over.\n    type Item;\n\n    // `find` takes `&mut self` meaning the caller may be borrowed\n    // and modified, but not consumed.\n    fn find<P>(&mut self, predicate: P) -> Option<Self::Item> where\n        // `FnMut` meaning any captured variable may at most be\n        // modified, not consumed. `&Self::Item` states it takes\n        // arguments to the closure by reference.\n        P: FnMut(&Self::Item) -> bool;\n}\n"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-rust",children:'fn main() {\n    let vec1 = vec![1, 2, 3];\n    let vec2 = vec![4, 5, 6];\n\n    // `iter()` for vecs yields `&i32`.\n    let mut iter = vec1.iter();\n    // `into_iter()` for vecs yields `i32`.\n    let mut into_iter = vec2.into_iter();\n\n    // `iter()` for vecs yields `&i32`, and we want to reference one of its\n    // items, so we have to destructure `&&i32` to `i32`\n    println!("Find 2 in vec1: {:?}", iter     .find(|&&x| x == 2));\n    // `into_iter()` for vecs yields `i32`, and we want to reference one of\n    // its items, so we have to destructure `&i32` to `i32`\n    println!("Find 2 in vec2: {:?}", into_iter.find(| &x| x == 2));\n\n    let array1 = [1, 2, 3];\n    let array2 = [4, 5, 6];\n\n    // `iter()` for arrays yields `&&i32`\n    println!("Find 2 in array1: {:?}", array1.iter()     .find(|&&x| x == 2));\n    // `into_iter()` for arrays yields `&i32`\n    println!("Find 2 in array2: {:?}", array2.into_iter().find(|&x| x == 2));\n}\n'})}),"\n",(0,r.jsx)(e.p,{children:"Iterator::find \u4e3a\u60a8\u63d0\u4f9b\u5bf9\u8be5\u9879\u76ee\u7684\u5f15\u7528\u3002\u4f46\u5982\u679c\u60a8\u60f3\u8981\u8be5\u9879\u76ee\u7684\u7d22\u5f15\uff0c\u8bf7\u4f7f\u7528 Iterator::position \u3002"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-rust",children:"fn main() {\n    let vec = vec![1, 9, 3, 3, 13, 2];\n\n    // `iter()` for vecs yields `&i32` and `position()` does not take a reference, so\n    // we have to destructure `&i32` to `i32`\n    let index_of_first_even_number = vec.iter().position(|&x| x % 2 == 0);\n    assert_eq!(index_of_first_even_number, Some(5));\n    \n    // `into_iter()` for vecs yields `i32` and `position()` does not take a reference, so\n    // we do not have to destructure    \n    let index_of_first_negative_number = vec.into_iter().position(|x| x < 0);\n    assert_eq!(index_of_first_negative_number, None);\n}\n"})}),"\n",(0,r.jsx)(e.h2,{id:"\u9ad8\u9636\u51fd\u6570",children:"\u9ad8\u9636\u51fd\u6570"}),"\n",(0,r.jsx)(e.p,{children:"Rust \u63d0\u4f9b\u9ad8\u9636\u51fd\u6570 (HOF)\u3002\u8fd9\u4e9b\u51fd\u6570\u91c7\u7528\u4e00\u4e2a\u6216\u591a\u4e2a\u51fd\u6570\u548c/\u6216\u4ea7\u751f\u66f4\u6709\u7528\u7684\u51fd\u6570\u3002 HOF \u548c\u60f0\u6027\u8fed\u4ee3\u5668\u8d4b\u4e88 Rust \u51fd\u6570\u5f0f\u98ce\u683c\u3002"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-rust",children:'fn is_odd(n: u32) -> bool {\n    n % 2 == 1\n}\n\nfn main() {\n    println!("Find the sum of all the numbers with odd squares under 1000");\n    let upper = 1000;\n\n    // Imperative approach\n    // Declare accumulator variable\n    let mut acc = 0;\n    // Iterate: 0, 1, 2, ... to infinity\n    for n in 0.. {\n        // Square the number\n        let n_squared = n * n;\n\n        if n_squared >= upper {\n            // Break loop if exceeded the upper limit\n            break;\n        } else if is_odd(n_squared) {\n            // Accumulate value, if it\'s odd\n            acc += n_squared;\n        }\n    }\n    println!("imperative style: {}", acc);\n\n    // Functional approach\n    let sum_of_squared_odd_numbers: u32 =\n        (0..).map(|n| n * n)                             // All natural numbers squared\n             .take_while(|&n_squared| n_squared < upper) // Below upper limit\n             .filter(|&n_squared| is_odd(n_squared))     // That are odd\n             .sum();                                     // Sum them\n    println!("functional style: {}", sum_of_squared_odd_numbers);\n}\n'})}),"\n",(0,r.jsx)(e.h2,{id:"\u53d1\u6563\u51fd\u6570",children:"\u53d1\u6563\u51fd\u6570"}),"\n",(0,r.jsx)(e.p,{children:"\u53d1\u6563\u7684\u51fd\u6570\u6c38\u8fdc\u4e0d\u4f1a\u8fd4\u56de\u3002\u5b83\u4eec\u4f7f\u7528 ! \u8fdb\u884c\u6807\u8bb0\uff0c\u8fd9\u662f\u4e00\u4e2a\u7a7a\u7c7b\u578b\u3002"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-rust",children:'fn foo() -> ! {\n    panic!("This call never returns.");\n}\n'})}),"\n",(0,r.jsx)(e.p,{children:"\u4e0e\u6240\u6709\u5176\u4ed6\u7c7b\u578b\u76f8\u53cd\uff0c\u8be5\u7c7b\u578b\u65e0\u6cd5\u5b9e\u4f8b\u5316\uff0c\u56e0\u4e3a\u8be5\u7c7b\u578b\u53ef\u4ee5\u5177\u6709\u7684\u6240\u6709\u53ef\u80fd\u503c\u7684\u96c6\u5408\u662f\u7a7a\u7684\u3002\u8bf7\u6ce8\u610f\uff0c\u5b83\u4e0e () \u7c7b\u578b\u4e0d\u540c\uff0c\u540e\u8005\u53ea\u6709\u4e00\u4e2a\u53ef\u80fd\u7684\u503c\u3002"}),"\n",(0,r.jsx)(e.p,{children:"\u4f8b\u5982\uff0c\u8be5\u51fd\u6570\u7167\u5e38\u8fd4\u56de\uff0c\u5c3d\u7ba1\u8fd4\u56de\u503c\u4e2d\u6ca1\u6709\u4efb\u4f55\u4fe1\u606f\u3002"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-rust",children:'fn some_fn() {\n    ()\n}\n\nfn main() {\n    let _a: () = some_fn();\n    println!("This function returns and you can see this line.");\n}\n'})}),"\n",(0,r.jsx)(e.p,{children:"\u4e0e\u6b64\u51fd\u6570\u76f8\u53cd\uff0c\u5b83\u6c38\u8fdc\u4e0d\u4f1a\u5c06\u63a7\u5236\u6743\u8fd4\u56de\u7ed9\u8c03\u7528\u8005\u3002"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-rust",children:'#![feature(never_type)]\n\nfn main() {\n    let x: ! = panic!("This call never returns.");\n    println!("You will never see this line!");\n}\n'})}),"\n",(0,r.jsx)(e.p,{children:"\u5c3d\u7ba1\u8fd9\u770b\u8d77\u6765\u50cf\u662f\u4e00\u4e2a\u62bd\u8c61\u7684\u6982\u5ff5\uff0c\u4f46\u5b9e\u9645\u4e0a\u5b83\u975e\u5e38\u6709\u7528\u5e76\u4e14\u901a\u5e38\u5f88\u65b9\u4fbf\u3002\u8fd9\u79cd\u7c7b\u578b\u7684\u4e3b\u8981\u4f18\u70b9\u662f\u5b83\u53ef\u4ee5\u8f6c\u6362\u4e3a\u4efb\u4f55\u5176\u4ed6\u7c7b\u578b\uff0c\u56e0\u6b64\u53ef\u4ee5\u5728\u9700\u8981\u7cbe\u786e\u7c7b\u578b\u7684\u5730\u65b9\u4f7f\u7528\uff0c\u4f8b\u5982\u5728 match \u5206\u652f\u4e2d\u3002\u8fd9\u5141\u8bb8\u6211\u4eec\u7f16\u5199\u5982\u4e0b\u4ee3\u7801\uff1a"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-rust",children:'fn main() {\n    fn sum_odd_numbers(up_to: u32) -> u32 {\n        let mut acc = 0;\n        for i in 0..up_to {\n            // Notice that the return type of this match expression must be u32\n            // because of the type of the "addition" variable.\n            let addition: u32 = match i%2 == 1 {\n                // The "i" variable is of type u32, which is perfectly fine.\n                true => i,\n                // On the other hand, the "continue" expression does not return\n                // u32, but it is still fine, because it never returns and therefore\n                // does not violate the type requirements of the match expression.\n                false => continue,\n            };\n            acc += addition;\n        }\n        acc\n    }\n    println!("Sum of odd numbers up to 9 (excluding): {}", sum_odd_numbers(9));\n}\n'})}),"\n",(0,r.jsxs)(e.p,{children:["\u5b83\u4e5f\u662f\u6c38\u8fdc\u5faa\u73af\u7684\u51fd\u6570\uff08\u4f8b\u5982 loop "," \uff09\u7684\u8fd4\u56de\u7c7b\u578b\uff0c\u4f8b\u5982\u7f51\u7edc\u670d\u52a1\u5668\u6216\u7ec8\u6b62\u8fdb\u7a0b\u7684\u51fd\u6570\uff08\u4f8b\u5982 exit() \uff09\u3002"]})]})}function d(n={}){const{wrapper:e}={...(0,i.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(u,{...n})}):u(n)}},8453:(n,e,t)=>{t.d(e,{R:()=>l,x:()=>a});var r=t(6540);const i={},s=r.createContext(i);function l(n){const e=r.useContext(s);return r.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:l(n.components),r.createElement(s.Provider,{value:e},n.children)}}}]);